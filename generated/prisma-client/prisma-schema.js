module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateAnnualExamSubjectSeries {
  count: Int!
}

type AggregateAnotherType {
  count: Int!
}

type AggregateCandidate {
  count: Int!
}

type AggregateCenterAdmin {
  count: Int!
}

type AggregateDivision {
  count: Int!
}

type AggregateEducationType {
  count: Int!
}

type AggregateExam {
  count: Int!
}

type AggregateExamCenter {
  count: Int!
}

type AggregateGender {
  count: Int!
}

type AggregateItem {
  count: Int!
}

type AggregatePresence {
  count: Int!
}

type AggregateRank {
  count: Int!
}

type AggregateRegion {
  count: Int!
}

type AggregateRegistration {
  count: Int!
}

type AggregateReport {
  count: Int!
}

type AggregateScore {
  count: Int!
}

type AggregateSeries {
  count: Int!
}

type AggregateSession {
  count: Int!
}

type AggregateSubDivision {
  count: Int!
}

type AggregateSubject {
  count: Int!
}

type AggregateTown {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AnnualExamSubjectSeries {
  id: ID!
  exam: Exam!
  session: Session!
  center: ExamCenter!
  rankCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  score(where: ScoreWhereInput, orderBy: ScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Score!]
}

type AnnualExamSubjectSeriesConnection {
  pageInfo: PageInfo!
  edges: [AnnualExamSubjectSeriesEdge]!
  aggregate: AggregateAnnualExamSubjectSeries!
}

input AnnualExamSubjectSeriesCreateInput {
  id: ID
  exam: ExamCreateOneWithoutAnnExamSeriesSubjInput!
  session: SessionCreateOneWithoutAnnExamSeriesSubjInput!
  center: ExamCenterCreateOneInput!
  rankCode: String!
  score: ScoreCreateManyWithoutAnnExamSeriesSubjInput
}

input AnnualExamSubjectSeriesCreateManyInput {
  create: [AnnualExamSubjectSeriesCreateInput!]
  connect: [AnnualExamSubjectSeriesWhereUniqueInput!]
}

input AnnualExamSubjectSeriesCreateManyWithoutExamInput {
  create: [AnnualExamSubjectSeriesCreateWithoutExamInput!]
  connect: [AnnualExamSubjectSeriesWhereUniqueInput!]
}

input AnnualExamSubjectSeriesCreateManyWithoutSessionInput {
  create: [AnnualExamSubjectSeriesCreateWithoutSessionInput!]
  connect: [AnnualExamSubjectSeriesWhereUniqueInput!]
}

input AnnualExamSubjectSeriesCreateOneWithoutScoreInput {
  create: AnnualExamSubjectSeriesCreateWithoutScoreInput
  connect: AnnualExamSubjectSeriesWhereUniqueInput
}

input AnnualExamSubjectSeriesCreateWithoutExamInput {
  id: ID
  session: SessionCreateOneWithoutAnnExamSeriesSubjInput!
  center: ExamCenterCreateOneInput!
  rankCode: String!
  score: ScoreCreateManyWithoutAnnExamSeriesSubjInput
}

input AnnualExamSubjectSeriesCreateWithoutScoreInput {
  id: ID
  exam: ExamCreateOneWithoutAnnExamSeriesSubjInput!
  session: SessionCreateOneWithoutAnnExamSeriesSubjInput!
  center: ExamCenterCreateOneInput!
  rankCode: String!
}

input AnnualExamSubjectSeriesCreateWithoutSessionInput {
  id: ID
  exam: ExamCreateOneWithoutAnnExamSeriesSubjInput!
  center: ExamCenterCreateOneInput!
  rankCode: String!
  score: ScoreCreateManyWithoutAnnExamSeriesSubjInput
}

type AnnualExamSubjectSeriesEdge {
  node: AnnualExamSubjectSeries!
  cursor: String!
}

enum AnnualExamSubjectSeriesOrderByInput {
  id_ASC
  id_DESC
  rankCode_ASC
  rankCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AnnualExamSubjectSeriesPreviousValues {
  id: ID!
  rankCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AnnualExamSubjectSeriesScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  rankCode: String
  rankCode_not: String
  rankCode_in: [String!]
  rankCode_not_in: [String!]
  rankCode_lt: String
  rankCode_lte: String
  rankCode_gt: String
  rankCode_gte: String
  rankCode_contains: String
  rankCode_not_contains: String
  rankCode_starts_with: String
  rankCode_not_starts_with: String
  rankCode_ends_with: String
  rankCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AnnualExamSubjectSeriesScalarWhereInput!]
  OR: [AnnualExamSubjectSeriesScalarWhereInput!]
  NOT: [AnnualExamSubjectSeriesScalarWhereInput!]
}

type AnnualExamSubjectSeriesSubscriptionPayload {
  mutation: MutationType!
  node: AnnualExamSubjectSeries
  updatedFields: [String!]
  previousValues: AnnualExamSubjectSeriesPreviousValues
}

input AnnualExamSubjectSeriesSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AnnualExamSubjectSeriesWhereInput
  AND: [AnnualExamSubjectSeriesSubscriptionWhereInput!]
  OR: [AnnualExamSubjectSeriesSubscriptionWhereInput!]
  NOT: [AnnualExamSubjectSeriesSubscriptionWhereInput!]
}

input AnnualExamSubjectSeriesUpdateDataInput {
  exam: ExamUpdateOneRequiredWithoutAnnExamSeriesSubjInput
  session: SessionUpdateOneRequiredWithoutAnnExamSeriesSubjInput
  center: ExamCenterUpdateOneRequiredInput
  rankCode: String
  score: ScoreUpdateManyWithoutAnnExamSeriesSubjInput
}

input AnnualExamSubjectSeriesUpdateInput {
  exam: ExamUpdateOneRequiredWithoutAnnExamSeriesSubjInput
  session: SessionUpdateOneRequiredWithoutAnnExamSeriesSubjInput
  center: ExamCenterUpdateOneRequiredInput
  rankCode: String
  score: ScoreUpdateManyWithoutAnnExamSeriesSubjInput
}

input AnnualExamSubjectSeriesUpdateManyDataInput {
  rankCode: String
}

input AnnualExamSubjectSeriesUpdateManyInput {
  create: [AnnualExamSubjectSeriesCreateInput!]
  update: [AnnualExamSubjectSeriesUpdateWithWhereUniqueNestedInput!]
  upsert: [AnnualExamSubjectSeriesUpsertWithWhereUniqueNestedInput!]
  delete: [AnnualExamSubjectSeriesWhereUniqueInput!]
  connect: [AnnualExamSubjectSeriesWhereUniqueInput!]
  set: [AnnualExamSubjectSeriesWhereUniqueInput!]
  disconnect: [AnnualExamSubjectSeriesWhereUniqueInput!]
  deleteMany: [AnnualExamSubjectSeriesScalarWhereInput!]
  updateMany: [AnnualExamSubjectSeriesUpdateManyWithWhereNestedInput!]
}

input AnnualExamSubjectSeriesUpdateManyMutationInput {
  rankCode: String
}

input AnnualExamSubjectSeriesUpdateManyWithoutExamInput {
  create: [AnnualExamSubjectSeriesCreateWithoutExamInput!]
  delete: [AnnualExamSubjectSeriesWhereUniqueInput!]
  connect: [AnnualExamSubjectSeriesWhereUniqueInput!]
  set: [AnnualExamSubjectSeriesWhereUniqueInput!]
  disconnect: [AnnualExamSubjectSeriesWhereUniqueInput!]
  update: [AnnualExamSubjectSeriesUpdateWithWhereUniqueWithoutExamInput!]
  upsert: [AnnualExamSubjectSeriesUpsertWithWhereUniqueWithoutExamInput!]
  deleteMany: [AnnualExamSubjectSeriesScalarWhereInput!]
  updateMany: [AnnualExamSubjectSeriesUpdateManyWithWhereNestedInput!]
}

input AnnualExamSubjectSeriesUpdateManyWithoutSessionInput {
  create: [AnnualExamSubjectSeriesCreateWithoutSessionInput!]
  delete: [AnnualExamSubjectSeriesWhereUniqueInput!]
  connect: [AnnualExamSubjectSeriesWhereUniqueInput!]
  set: [AnnualExamSubjectSeriesWhereUniqueInput!]
  disconnect: [AnnualExamSubjectSeriesWhereUniqueInput!]
  update: [AnnualExamSubjectSeriesUpdateWithWhereUniqueWithoutSessionInput!]
  upsert: [AnnualExamSubjectSeriesUpsertWithWhereUniqueWithoutSessionInput!]
  deleteMany: [AnnualExamSubjectSeriesScalarWhereInput!]
  updateMany: [AnnualExamSubjectSeriesUpdateManyWithWhereNestedInput!]
}

input AnnualExamSubjectSeriesUpdateManyWithWhereNestedInput {
  where: AnnualExamSubjectSeriesScalarWhereInput!
  data: AnnualExamSubjectSeriesUpdateManyDataInput!
}

input AnnualExamSubjectSeriesUpdateOneRequiredWithoutScoreInput {
  create: AnnualExamSubjectSeriesCreateWithoutScoreInput
  update: AnnualExamSubjectSeriesUpdateWithoutScoreDataInput
  upsert: AnnualExamSubjectSeriesUpsertWithoutScoreInput
  connect: AnnualExamSubjectSeriesWhereUniqueInput
}

input AnnualExamSubjectSeriesUpdateWithoutExamDataInput {
  session: SessionUpdateOneRequiredWithoutAnnExamSeriesSubjInput
  center: ExamCenterUpdateOneRequiredInput
  rankCode: String
  score: ScoreUpdateManyWithoutAnnExamSeriesSubjInput
}

input AnnualExamSubjectSeriesUpdateWithoutScoreDataInput {
  exam: ExamUpdateOneRequiredWithoutAnnExamSeriesSubjInput
  session: SessionUpdateOneRequiredWithoutAnnExamSeriesSubjInput
  center: ExamCenterUpdateOneRequiredInput
  rankCode: String
}

input AnnualExamSubjectSeriesUpdateWithoutSessionDataInput {
  exam: ExamUpdateOneRequiredWithoutAnnExamSeriesSubjInput
  center: ExamCenterUpdateOneRequiredInput
  rankCode: String
  score: ScoreUpdateManyWithoutAnnExamSeriesSubjInput
}

input AnnualExamSubjectSeriesUpdateWithWhereUniqueNestedInput {
  where: AnnualExamSubjectSeriesWhereUniqueInput!
  data: AnnualExamSubjectSeriesUpdateDataInput!
}

input AnnualExamSubjectSeriesUpdateWithWhereUniqueWithoutExamInput {
  where: AnnualExamSubjectSeriesWhereUniqueInput!
  data: AnnualExamSubjectSeriesUpdateWithoutExamDataInput!
}

input AnnualExamSubjectSeriesUpdateWithWhereUniqueWithoutSessionInput {
  where: AnnualExamSubjectSeriesWhereUniqueInput!
  data: AnnualExamSubjectSeriesUpdateWithoutSessionDataInput!
}

input AnnualExamSubjectSeriesUpsertWithoutScoreInput {
  update: AnnualExamSubjectSeriesUpdateWithoutScoreDataInput!
  create: AnnualExamSubjectSeriesCreateWithoutScoreInput!
}

input AnnualExamSubjectSeriesUpsertWithWhereUniqueNestedInput {
  where: AnnualExamSubjectSeriesWhereUniqueInput!
  update: AnnualExamSubjectSeriesUpdateDataInput!
  create: AnnualExamSubjectSeriesCreateInput!
}

input AnnualExamSubjectSeriesUpsertWithWhereUniqueWithoutExamInput {
  where: AnnualExamSubjectSeriesWhereUniqueInput!
  update: AnnualExamSubjectSeriesUpdateWithoutExamDataInput!
  create: AnnualExamSubjectSeriesCreateWithoutExamInput!
}

input AnnualExamSubjectSeriesUpsertWithWhereUniqueWithoutSessionInput {
  where: AnnualExamSubjectSeriesWhereUniqueInput!
  update: AnnualExamSubjectSeriesUpdateWithoutSessionDataInput!
  create: AnnualExamSubjectSeriesCreateWithoutSessionInput!
}

input AnnualExamSubjectSeriesWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  exam: ExamWhereInput
  session: SessionWhereInput
  center: ExamCenterWhereInput
  rankCode: String
  rankCode_not: String
  rankCode_in: [String!]
  rankCode_not_in: [String!]
  rankCode_lt: String
  rankCode_lte: String
  rankCode_gt: String
  rankCode_gte: String
  rankCode_contains: String
  rankCode_not_contains: String
  rankCode_starts_with: String
  rankCode_not_starts_with: String
  rankCode_ends_with: String
  rankCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  score_every: ScoreWhereInput
  score_some: ScoreWhereInput
  score_none: ScoreWhereInput
  AND: [AnnualExamSubjectSeriesWhereInput!]
  OR: [AnnualExamSubjectSeriesWhereInput!]
  NOT: [AnnualExamSubjectSeriesWhereInput!]
}

input AnnualExamSubjectSeriesWhereUniqueInput {
  id: ID
}

type AnotherType {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AnotherTypeConnection {
  pageInfo: PageInfo!
  edges: [AnotherTypeEdge]!
  aggregate: AggregateAnotherType!
}

input AnotherTypeCreateInput {
  id: ID
}

type AnotherTypeEdge {
  node: AnotherType!
  cursor: String!
}

enum AnotherTypeOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AnotherTypePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AnotherTypeSubscriptionPayload {
  mutation: MutationType!
  node: AnotherType
  updatedFields: [String!]
  previousValues: AnotherTypePreviousValues
}

input AnotherTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AnotherTypeWhereInput
  AND: [AnotherTypeSubscriptionWhereInput!]
  OR: [AnotherTypeSubscriptionWhereInput!]
  NOT: [AnotherTypeSubscriptionWhereInput!]
}

input AnotherTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AnotherTypeWhereInput!]
  OR: [AnotherTypeWhereInput!]
  NOT: [AnotherTypeWhereInput!]
}

input AnotherTypeWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Candidate {
  id: ID!
  cand1stName: String
  cand2ndName: String
  cand3rdName: String
  placeOfBirth: String
  candCode: String
  image: String
  birthCertNumber: String
  email: String
  phoneNumb: Int
  dateOfBirth: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  gender: Gender!
  registration(where: RegistrationWhereInput, orderBy: RegistrationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Registration!]
}

type CandidateConnection {
  pageInfo: PageInfo!
  edges: [CandidateEdge]!
  aggregate: AggregateCandidate!
}

input CandidateCreateInput {
  id: ID
  cand1stName: String
  cand2ndName: String
  cand3rdName: String
  placeOfBirth: String
  candCode: String
  image: String
  birthCertNumber: String
  email: String
  phoneNumb: Int
  dateOfBirth: DateTime
  gender: GenderCreateOneWithoutCandidateInput!
  registration: RegistrationCreateManyWithoutCandidateInput
}

input CandidateCreateManyWithoutGenderInput {
  create: [CandidateCreateWithoutGenderInput!]
  connect: [CandidateWhereUniqueInput!]
}

input CandidateCreateOneWithoutRegistrationInput {
  create: CandidateCreateWithoutRegistrationInput
  connect: CandidateWhereUniqueInput
}

input CandidateCreateWithoutGenderInput {
  id: ID
  cand1stName: String
  cand2ndName: String
  cand3rdName: String
  placeOfBirth: String
  candCode: String
  image: String
  birthCertNumber: String
  email: String
  phoneNumb: Int
  dateOfBirth: DateTime
  registration: RegistrationCreateManyWithoutCandidateInput
}

input CandidateCreateWithoutRegistrationInput {
  id: ID
  cand1stName: String
  cand2ndName: String
  cand3rdName: String
  placeOfBirth: String
  candCode: String
  image: String
  birthCertNumber: String
  email: String
  phoneNumb: Int
  dateOfBirth: DateTime
  gender: GenderCreateOneWithoutCandidateInput!
}

type CandidateEdge {
  node: Candidate!
  cursor: String!
}

enum CandidateOrderByInput {
  id_ASC
  id_DESC
  cand1stName_ASC
  cand1stName_DESC
  cand2ndName_ASC
  cand2ndName_DESC
  cand3rdName_ASC
  cand3rdName_DESC
  placeOfBirth_ASC
  placeOfBirth_DESC
  candCode_ASC
  candCode_DESC
  image_ASC
  image_DESC
  birthCertNumber_ASC
  birthCertNumber_DESC
  email_ASC
  email_DESC
  phoneNumb_ASC
  phoneNumb_DESC
  dateOfBirth_ASC
  dateOfBirth_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CandidatePreviousValues {
  id: ID!
  cand1stName: String
  cand2ndName: String
  cand3rdName: String
  placeOfBirth: String
  candCode: String
  image: String
  birthCertNumber: String
  email: String
  phoneNumb: Int
  dateOfBirth: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

input CandidateScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  cand1stName: String
  cand1stName_not: String
  cand1stName_in: [String!]
  cand1stName_not_in: [String!]
  cand1stName_lt: String
  cand1stName_lte: String
  cand1stName_gt: String
  cand1stName_gte: String
  cand1stName_contains: String
  cand1stName_not_contains: String
  cand1stName_starts_with: String
  cand1stName_not_starts_with: String
  cand1stName_ends_with: String
  cand1stName_not_ends_with: String
  cand2ndName: String
  cand2ndName_not: String
  cand2ndName_in: [String!]
  cand2ndName_not_in: [String!]
  cand2ndName_lt: String
  cand2ndName_lte: String
  cand2ndName_gt: String
  cand2ndName_gte: String
  cand2ndName_contains: String
  cand2ndName_not_contains: String
  cand2ndName_starts_with: String
  cand2ndName_not_starts_with: String
  cand2ndName_ends_with: String
  cand2ndName_not_ends_with: String
  cand3rdName: String
  cand3rdName_not: String
  cand3rdName_in: [String!]
  cand3rdName_not_in: [String!]
  cand3rdName_lt: String
  cand3rdName_lte: String
  cand3rdName_gt: String
  cand3rdName_gte: String
  cand3rdName_contains: String
  cand3rdName_not_contains: String
  cand3rdName_starts_with: String
  cand3rdName_not_starts_with: String
  cand3rdName_ends_with: String
  cand3rdName_not_ends_with: String
  placeOfBirth: String
  placeOfBirth_not: String
  placeOfBirth_in: [String!]
  placeOfBirth_not_in: [String!]
  placeOfBirth_lt: String
  placeOfBirth_lte: String
  placeOfBirth_gt: String
  placeOfBirth_gte: String
  placeOfBirth_contains: String
  placeOfBirth_not_contains: String
  placeOfBirth_starts_with: String
  placeOfBirth_not_starts_with: String
  placeOfBirth_ends_with: String
  placeOfBirth_not_ends_with: String
  candCode: String
  candCode_not: String
  candCode_in: [String!]
  candCode_not_in: [String!]
  candCode_lt: String
  candCode_lte: String
  candCode_gt: String
  candCode_gte: String
  candCode_contains: String
  candCode_not_contains: String
  candCode_starts_with: String
  candCode_not_starts_with: String
  candCode_ends_with: String
  candCode_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  birthCertNumber: String
  birthCertNumber_not: String
  birthCertNumber_in: [String!]
  birthCertNumber_not_in: [String!]
  birthCertNumber_lt: String
  birthCertNumber_lte: String
  birthCertNumber_gt: String
  birthCertNumber_gte: String
  birthCertNumber_contains: String
  birthCertNumber_not_contains: String
  birthCertNumber_starts_with: String
  birthCertNumber_not_starts_with: String
  birthCertNumber_ends_with: String
  birthCertNumber_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phoneNumb: Int
  phoneNumb_not: Int
  phoneNumb_in: [Int!]
  phoneNumb_not_in: [Int!]
  phoneNumb_lt: Int
  phoneNumb_lte: Int
  phoneNumb_gt: Int
  phoneNumb_gte: Int
  dateOfBirth: DateTime
  dateOfBirth_not: DateTime
  dateOfBirth_in: [DateTime!]
  dateOfBirth_not_in: [DateTime!]
  dateOfBirth_lt: DateTime
  dateOfBirth_lte: DateTime
  dateOfBirth_gt: DateTime
  dateOfBirth_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CandidateScalarWhereInput!]
  OR: [CandidateScalarWhereInput!]
  NOT: [CandidateScalarWhereInput!]
}

type CandidateSubscriptionPayload {
  mutation: MutationType!
  node: Candidate
  updatedFields: [String!]
  previousValues: CandidatePreviousValues
}

input CandidateSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CandidateWhereInput
  AND: [CandidateSubscriptionWhereInput!]
  OR: [CandidateSubscriptionWhereInput!]
  NOT: [CandidateSubscriptionWhereInput!]
}

input CandidateUpdateInput {
  cand1stName: String
  cand2ndName: String
  cand3rdName: String
  placeOfBirth: String
  candCode: String
  image: String
  birthCertNumber: String
  email: String
  phoneNumb: Int
  dateOfBirth: DateTime
  gender: GenderUpdateOneRequiredWithoutCandidateInput
  registration: RegistrationUpdateManyWithoutCandidateInput
}

input CandidateUpdateManyDataInput {
  cand1stName: String
  cand2ndName: String
  cand3rdName: String
  placeOfBirth: String
  candCode: String
  image: String
  birthCertNumber: String
  email: String
  phoneNumb: Int
  dateOfBirth: DateTime
}

input CandidateUpdateManyMutationInput {
  cand1stName: String
  cand2ndName: String
  cand3rdName: String
  placeOfBirth: String
  candCode: String
  image: String
  birthCertNumber: String
  email: String
  phoneNumb: Int
  dateOfBirth: DateTime
}

input CandidateUpdateManyWithoutGenderInput {
  create: [CandidateCreateWithoutGenderInput!]
  delete: [CandidateWhereUniqueInput!]
  connect: [CandidateWhereUniqueInput!]
  set: [CandidateWhereUniqueInput!]
  disconnect: [CandidateWhereUniqueInput!]
  update: [CandidateUpdateWithWhereUniqueWithoutGenderInput!]
  upsert: [CandidateUpsertWithWhereUniqueWithoutGenderInput!]
  deleteMany: [CandidateScalarWhereInput!]
  updateMany: [CandidateUpdateManyWithWhereNestedInput!]
}

input CandidateUpdateManyWithWhereNestedInput {
  where: CandidateScalarWhereInput!
  data: CandidateUpdateManyDataInput!
}

input CandidateUpdateOneRequiredWithoutRegistrationInput {
  create: CandidateCreateWithoutRegistrationInput
  update: CandidateUpdateWithoutRegistrationDataInput
  upsert: CandidateUpsertWithoutRegistrationInput
  connect: CandidateWhereUniqueInput
}

input CandidateUpdateWithoutGenderDataInput {
  cand1stName: String
  cand2ndName: String
  cand3rdName: String
  placeOfBirth: String
  candCode: String
  image: String
  birthCertNumber: String
  email: String
  phoneNumb: Int
  dateOfBirth: DateTime
  registration: RegistrationUpdateManyWithoutCandidateInput
}

input CandidateUpdateWithoutRegistrationDataInput {
  cand1stName: String
  cand2ndName: String
  cand3rdName: String
  placeOfBirth: String
  candCode: String
  image: String
  birthCertNumber: String
  email: String
  phoneNumb: Int
  dateOfBirth: DateTime
  gender: GenderUpdateOneRequiredWithoutCandidateInput
}

input CandidateUpdateWithWhereUniqueWithoutGenderInput {
  where: CandidateWhereUniqueInput!
  data: CandidateUpdateWithoutGenderDataInput!
}

input CandidateUpsertWithoutRegistrationInput {
  update: CandidateUpdateWithoutRegistrationDataInput!
  create: CandidateCreateWithoutRegistrationInput!
}

input CandidateUpsertWithWhereUniqueWithoutGenderInput {
  where: CandidateWhereUniqueInput!
  update: CandidateUpdateWithoutGenderDataInput!
  create: CandidateCreateWithoutGenderInput!
}

input CandidateWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  cand1stName: String
  cand1stName_not: String
  cand1stName_in: [String!]
  cand1stName_not_in: [String!]
  cand1stName_lt: String
  cand1stName_lte: String
  cand1stName_gt: String
  cand1stName_gte: String
  cand1stName_contains: String
  cand1stName_not_contains: String
  cand1stName_starts_with: String
  cand1stName_not_starts_with: String
  cand1stName_ends_with: String
  cand1stName_not_ends_with: String
  cand2ndName: String
  cand2ndName_not: String
  cand2ndName_in: [String!]
  cand2ndName_not_in: [String!]
  cand2ndName_lt: String
  cand2ndName_lte: String
  cand2ndName_gt: String
  cand2ndName_gte: String
  cand2ndName_contains: String
  cand2ndName_not_contains: String
  cand2ndName_starts_with: String
  cand2ndName_not_starts_with: String
  cand2ndName_ends_with: String
  cand2ndName_not_ends_with: String
  cand3rdName: String
  cand3rdName_not: String
  cand3rdName_in: [String!]
  cand3rdName_not_in: [String!]
  cand3rdName_lt: String
  cand3rdName_lte: String
  cand3rdName_gt: String
  cand3rdName_gte: String
  cand3rdName_contains: String
  cand3rdName_not_contains: String
  cand3rdName_starts_with: String
  cand3rdName_not_starts_with: String
  cand3rdName_ends_with: String
  cand3rdName_not_ends_with: String
  placeOfBirth: String
  placeOfBirth_not: String
  placeOfBirth_in: [String!]
  placeOfBirth_not_in: [String!]
  placeOfBirth_lt: String
  placeOfBirth_lte: String
  placeOfBirth_gt: String
  placeOfBirth_gte: String
  placeOfBirth_contains: String
  placeOfBirth_not_contains: String
  placeOfBirth_starts_with: String
  placeOfBirth_not_starts_with: String
  placeOfBirth_ends_with: String
  placeOfBirth_not_ends_with: String
  candCode: String
  candCode_not: String
  candCode_in: [String!]
  candCode_not_in: [String!]
  candCode_lt: String
  candCode_lte: String
  candCode_gt: String
  candCode_gte: String
  candCode_contains: String
  candCode_not_contains: String
  candCode_starts_with: String
  candCode_not_starts_with: String
  candCode_ends_with: String
  candCode_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  birthCertNumber: String
  birthCertNumber_not: String
  birthCertNumber_in: [String!]
  birthCertNumber_not_in: [String!]
  birthCertNumber_lt: String
  birthCertNumber_lte: String
  birthCertNumber_gt: String
  birthCertNumber_gte: String
  birthCertNumber_contains: String
  birthCertNumber_not_contains: String
  birthCertNumber_starts_with: String
  birthCertNumber_not_starts_with: String
  birthCertNumber_ends_with: String
  birthCertNumber_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phoneNumb: Int
  phoneNumb_not: Int
  phoneNumb_in: [Int!]
  phoneNumb_not_in: [Int!]
  phoneNumb_lt: Int
  phoneNumb_lte: Int
  phoneNumb_gt: Int
  phoneNumb_gte: Int
  dateOfBirth: DateTime
  dateOfBirth_not: DateTime
  dateOfBirth_in: [DateTime!]
  dateOfBirth_not_in: [DateTime!]
  dateOfBirth_lt: DateTime
  dateOfBirth_lte: DateTime
  dateOfBirth_gt: DateTime
  dateOfBirth_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  gender: GenderWhereInput
  registration_every: RegistrationWhereInput
  registration_some: RegistrationWhereInput
  registration_none: RegistrationWhereInput
  AND: [CandidateWhereInput!]
  OR: [CandidateWhereInput!]
  NOT: [CandidateWhereInput!]
}

input CandidateWhereUniqueInput {
  id: ID
}

type CenterAdmin {
  id: ID!
  authName: String!
  authInstitution: String!
  authPhone: Int!
  authMatricue: String!
  rank: Rank!
  exam: Exam!
  session: Session!
  center: ExamCenter!
  createdAt: DateTime!
  updatedAt: DateTime!
  report(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Report!]
}

type CenterAdminConnection {
  pageInfo: PageInfo!
  edges: [CenterAdminEdge]!
  aggregate: AggregateCenterAdmin!
}

input CenterAdminCreateInput {
  id: ID
  authName: String!
  authInstitution: String!
  authPhone: Int!
  authMatricue: String!
  rank: RankCreateOneWithoutCenterAdminInput!
  exam: ExamCreateOneWithoutCenterAdminInput!
  session: SessionCreateOneWithoutCenterAdminInput!
  center: ExamCenterCreateOneWithoutCenterAdminInput!
  report: ReportCreateManyWithoutCenterAdminInput
}

input CenterAdminCreateManyWithoutCenterInput {
  create: [CenterAdminCreateWithoutCenterInput!]
  connect: [CenterAdminWhereUniqueInput!]
}

input CenterAdminCreateManyWithoutExamInput {
  create: [CenterAdminCreateWithoutExamInput!]
  connect: [CenterAdminWhereUniqueInput!]
}

input CenterAdminCreateManyWithoutRankInput {
  create: [CenterAdminCreateWithoutRankInput!]
  connect: [CenterAdminWhereUniqueInput!]
}

input CenterAdminCreateManyWithoutSessionInput {
  create: [CenterAdminCreateWithoutSessionInput!]
  connect: [CenterAdminWhereUniqueInput!]
}

input CenterAdminCreateOneWithoutReportInput {
  create: CenterAdminCreateWithoutReportInput
  connect: CenterAdminWhereUniqueInput
}

input CenterAdminCreateWithoutCenterInput {
  id: ID
  authName: String!
  authInstitution: String!
  authPhone: Int!
  authMatricue: String!
  rank: RankCreateOneWithoutCenterAdminInput!
  exam: ExamCreateOneWithoutCenterAdminInput!
  session: SessionCreateOneWithoutCenterAdminInput!
  report: ReportCreateManyWithoutCenterAdminInput
}

input CenterAdminCreateWithoutExamInput {
  id: ID
  authName: String!
  authInstitution: String!
  authPhone: Int!
  authMatricue: String!
  rank: RankCreateOneWithoutCenterAdminInput!
  session: SessionCreateOneWithoutCenterAdminInput!
  center: ExamCenterCreateOneWithoutCenterAdminInput!
  report: ReportCreateManyWithoutCenterAdminInput
}

input CenterAdminCreateWithoutRankInput {
  id: ID
  authName: String!
  authInstitution: String!
  authPhone: Int!
  authMatricue: String!
  exam: ExamCreateOneWithoutCenterAdminInput!
  session: SessionCreateOneWithoutCenterAdminInput!
  center: ExamCenterCreateOneWithoutCenterAdminInput!
  report: ReportCreateManyWithoutCenterAdminInput
}

input CenterAdminCreateWithoutReportInput {
  id: ID
  authName: String!
  authInstitution: String!
  authPhone: Int!
  authMatricue: String!
  rank: RankCreateOneWithoutCenterAdminInput!
  exam: ExamCreateOneWithoutCenterAdminInput!
  session: SessionCreateOneWithoutCenterAdminInput!
  center: ExamCenterCreateOneWithoutCenterAdminInput!
}

input CenterAdminCreateWithoutSessionInput {
  id: ID
  authName: String!
  authInstitution: String!
  authPhone: Int!
  authMatricue: String!
  rank: RankCreateOneWithoutCenterAdminInput!
  exam: ExamCreateOneWithoutCenterAdminInput!
  center: ExamCenterCreateOneWithoutCenterAdminInput!
  report: ReportCreateManyWithoutCenterAdminInput
}

type CenterAdminEdge {
  node: CenterAdmin!
  cursor: String!
}

enum CenterAdminOrderByInput {
  id_ASC
  id_DESC
  authName_ASC
  authName_DESC
  authInstitution_ASC
  authInstitution_DESC
  authPhone_ASC
  authPhone_DESC
  authMatricue_ASC
  authMatricue_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CenterAdminPreviousValues {
  id: ID!
  authName: String!
  authInstitution: String!
  authPhone: Int!
  authMatricue: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input CenterAdminScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  authName: String
  authName_not: String
  authName_in: [String!]
  authName_not_in: [String!]
  authName_lt: String
  authName_lte: String
  authName_gt: String
  authName_gte: String
  authName_contains: String
  authName_not_contains: String
  authName_starts_with: String
  authName_not_starts_with: String
  authName_ends_with: String
  authName_not_ends_with: String
  authInstitution: String
  authInstitution_not: String
  authInstitution_in: [String!]
  authInstitution_not_in: [String!]
  authInstitution_lt: String
  authInstitution_lte: String
  authInstitution_gt: String
  authInstitution_gte: String
  authInstitution_contains: String
  authInstitution_not_contains: String
  authInstitution_starts_with: String
  authInstitution_not_starts_with: String
  authInstitution_ends_with: String
  authInstitution_not_ends_with: String
  authPhone: Int
  authPhone_not: Int
  authPhone_in: [Int!]
  authPhone_not_in: [Int!]
  authPhone_lt: Int
  authPhone_lte: Int
  authPhone_gt: Int
  authPhone_gte: Int
  authMatricue: String
  authMatricue_not: String
  authMatricue_in: [String!]
  authMatricue_not_in: [String!]
  authMatricue_lt: String
  authMatricue_lte: String
  authMatricue_gt: String
  authMatricue_gte: String
  authMatricue_contains: String
  authMatricue_not_contains: String
  authMatricue_starts_with: String
  authMatricue_not_starts_with: String
  authMatricue_ends_with: String
  authMatricue_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CenterAdminScalarWhereInput!]
  OR: [CenterAdminScalarWhereInput!]
  NOT: [CenterAdminScalarWhereInput!]
}

type CenterAdminSubscriptionPayload {
  mutation: MutationType!
  node: CenterAdmin
  updatedFields: [String!]
  previousValues: CenterAdminPreviousValues
}

input CenterAdminSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CenterAdminWhereInput
  AND: [CenterAdminSubscriptionWhereInput!]
  OR: [CenterAdminSubscriptionWhereInput!]
  NOT: [CenterAdminSubscriptionWhereInput!]
}

input CenterAdminUpdateInput {
  authName: String
  authInstitution: String
  authPhone: Int
  authMatricue: String
  rank: RankUpdateOneRequiredWithoutCenterAdminInput
  exam: ExamUpdateOneRequiredWithoutCenterAdminInput
  session: SessionUpdateOneRequiredWithoutCenterAdminInput
  center: ExamCenterUpdateOneRequiredWithoutCenterAdminInput
  report: ReportUpdateManyWithoutCenterAdminInput
}

input CenterAdminUpdateManyDataInput {
  authName: String
  authInstitution: String
  authPhone: Int
  authMatricue: String
}

input CenterAdminUpdateManyMutationInput {
  authName: String
  authInstitution: String
  authPhone: Int
  authMatricue: String
}

input CenterAdminUpdateManyWithoutCenterInput {
  create: [CenterAdminCreateWithoutCenterInput!]
  delete: [CenterAdminWhereUniqueInput!]
  connect: [CenterAdminWhereUniqueInput!]
  set: [CenterAdminWhereUniqueInput!]
  disconnect: [CenterAdminWhereUniqueInput!]
  update: [CenterAdminUpdateWithWhereUniqueWithoutCenterInput!]
  upsert: [CenterAdminUpsertWithWhereUniqueWithoutCenterInput!]
  deleteMany: [CenterAdminScalarWhereInput!]
  updateMany: [CenterAdminUpdateManyWithWhereNestedInput!]
}

input CenterAdminUpdateManyWithoutExamInput {
  create: [CenterAdminCreateWithoutExamInput!]
  delete: [CenterAdminWhereUniqueInput!]
  connect: [CenterAdminWhereUniqueInput!]
  set: [CenterAdminWhereUniqueInput!]
  disconnect: [CenterAdminWhereUniqueInput!]
  update: [CenterAdminUpdateWithWhereUniqueWithoutExamInput!]
  upsert: [CenterAdminUpsertWithWhereUniqueWithoutExamInput!]
  deleteMany: [CenterAdminScalarWhereInput!]
  updateMany: [CenterAdminUpdateManyWithWhereNestedInput!]
}

input CenterAdminUpdateManyWithoutRankInput {
  create: [CenterAdminCreateWithoutRankInput!]
  delete: [CenterAdminWhereUniqueInput!]
  connect: [CenterAdminWhereUniqueInput!]
  set: [CenterAdminWhereUniqueInput!]
  disconnect: [CenterAdminWhereUniqueInput!]
  update: [CenterAdminUpdateWithWhereUniqueWithoutRankInput!]
  upsert: [CenterAdminUpsertWithWhereUniqueWithoutRankInput!]
  deleteMany: [CenterAdminScalarWhereInput!]
  updateMany: [CenterAdminUpdateManyWithWhereNestedInput!]
}

input CenterAdminUpdateManyWithoutSessionInput {
  create: [CenterAdminCreateWithoutSessionInput!]
  delete: [CenterAdminWhereUniqueInput!]
  connect: [CenterAdminWhereUniqueInput!]
  set: [CenterAdminWhereUniqueInput!]
  disconnect: [CenterAdminWhereUniqueInput!]
  update: [CenterAdminUpdateWithWhereUniqueWithoutSessionInput!]
  upsert: [CenterAdminUpsertWithWhereUniqueWithoutSessionInput!]
  deleteMany: [CenterAdminScalarWhereInput!]
  updateMany: [CenterAdminUpdateManyWithWhereNestedInput!]
}

input CenterAdminUpdateManyWithWhereNestedInput {
  where: CenterAdminScalarWhereInput!
  data: CenterAdminUpdateManyDataInput!
}

input CenterAdminUpdateOneRequiredWithoutReportInput {
  create: CenterAdminCreateWithoutReportInput
  update: CenterAdminUpdateWithoutReportDataInput
  upsert: CenterAdminUpsertWithoutReportInput
  connect: CenterAdminWhereUniqueInput
}

input CenterAdminUpdateWithoutCenterDataInput {
  authName: String
  authInstitution: String
  authPhone: Int
  authMatricue: String
  rank: RankUpdateOneRequiredWithoutCenterAdminInput
  exam: ExamUpdateOneRequiredWithoutCenterAdminInput
  session: SessionUpdateOneRequiredWithoutCenterAdminInput
  report: ReportUpdateManyWithoutCenterAdminInput
}

input CenterAdminUpdateWithoutExamDataInput {
  authName: String
  authInstitution: String
  authPhone: Int
  authMatricue: String
  rank: RankUpdateOneRequiredWithoutCenterAdminInput
  session: SessionUpdateOneRequiredWithoutCenterAdminInput
  center: ExamCenterUpdateOneRequiredWithoutCenterAdminInput
  report: ReportUpdateManyWithoutCenterAdminInput
}

input CenterAdminUpdateWithoutRankDataInput {
  authName: String
  authInstitution: String
  authPhone: Int
  authMatricue: String
  exam: ExamUpdateOneRequiredWithoutCenterAdminInput
  session: SessionUpdateOneRequiredWithoutCenterAdminInput
  center: ExamCenterUpdateOneRequiredWithoutCenterAdminInput
  report: ReportUpdateManyWithoutCenterAdminInput
}

input CenterAdminUpdateWithoutReportDataInput {
  authName: String
  authInstitution: String
  authPhone: Int
  authMatricue: String
  rank: RankUpdateOneRequiredWithoutCenterAdminInput
  exam: ExamUpdateOneRequiredWithoutCenterAdminInput
  session: SessionUpdateOneRequiredWithoutCenterAdminInput
  center: ExamCenterUpdateOneRequiredWithoutCenterAdminInput
}

input CenterAdminUpdateWithoutSessionDataInput {
  authName: String
  authInstitution: String
  authPhone: Int
  authMatricue: String
  rank: RankUpdateOneRequiredWithoutCenterAdminInput
  exam: ExamUpdateOneRequiredWithoutCenterAdminInput
  center: ExamCenterUpdateOneRequiredWithoutCenterAdminInput
  report: ReportUpdateManyWithoutCenterAdminInput
}

input CenterAdminUpdateWithWhereUniqueWithoutCenterInput {
  where: CenterAdminWhereUniqueInput!
  data: CenterAdminUpdateWithoutCenterDataInput!
}

input CenterAdminUpdateWithWhereUniqueWithoutExamInput {
  where: CenterAdminWhereUniqueInput!
  data: CenterAdminUpdateWithoutExamDataInput!
}

input CenterAdminUpdateWithWhereUniqueWithoutRankInput {
  where: CenterAdminWhereUniqueInput!
  data: CenterAdminUpdateWithoutRankDataInput!
}

input CenterAdminUpdateWithWhereUniqueWithoutSessionInput {
  where: CenterAdminWhereUniqueInput!
  data: CenterAdminUpdateWithoutSessionDataInput!
}

input CenterAdminUpsertWithoutReportInput {
  update: CenterAdminUpdateWithoutReportDataInput!
  create: CenterAdminCreateWithoutReportInput!
}

input CenterAdminUpsertWithWhereUniqueWithoutCenterInput {
  where: CenterAdminWhereUniqueInput!
  update: CenterAdminUpdateWithoutCenterDataInput!
  create: CenterAdminCreateWithoutCenterInput!
}

input CenterAdminUpsertWithWhereUniqueWithoutExamInput {
  where: CenterAdminWhereUniqueInput!
  update: CenterAdminUpdateWithoutExamDataInput!
  create: CenterAdminCreateWithoutExamInput!
}

input CenterAdminUpsertWithWhereUniqueWithoutRankInput {
  where: CenterAdminWhereUniqueInput!
  update: CenterAdminUpdateWithoutRankDataInput!
  create: CenterAdminCreateWithoutRankInput!
}

input CenterAdminUpsertWithWhereUniqueWithoutSessionInput {
  where: CenterAdminWhereUniqueInput!
  update: CenterAdminUpdateWithoutSessionDataInput!
  create: CenterAdminCreateWithoutSessionInput!
}

input CenterAdminWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  authName: String
  authName_not: String
  authName_in: [String!]
  authName_not_in: [String!]
  authName_lt: String
  authName_lte: String
  authName_gt: String
  authName_gte: String
  authName_contains: String
  authName_not_contains: String
  authName_starts_with: String
  authName_not_starts_with: String
  authName_ends_with: String
  authName_not_ends_with: String
  authInstitution: String
  authInstitution_not: String
  authInstitution_in: [String!]
  authInstitution_not_in: [String!]
  authInstitution_lt: String
  authInstitution_lte: String
  authInstitution_gt: String
  authInstitution_gte: String
  authInstitution_contains: String
  authInstitution_not_contains: String
  authInstitution_starts_with: String
  authInstitution_not_starts_with: String
  authInstitution_ends_with: String
  authInstitution_not_ends_with: String
  authPhone: Int
  authPhone_not: Int
  authPhone_in: [Int!]
  authPhone_not_in: [Int!]
  authPhone_lt: Int
  authPhone_lte: Int
  authPhone_gt: Int
  authPhone_gte: Int
  authMatricue: String
  authMatricue_not: String
  authMatricue_in: [String!]
  authMatricue_not_in: [String!]
  authMatricue_lt: String
  authMatricue_lte: String
  authMatricue_gt: String
  authMatricue_gte: String
  authMatricue_contains: String
  authMatricue_not_contains: String
  authMatricue_starts_with: String
  authMatricue_not_starts_with: String
  authMatricue_ends_with: String
  authMatricue_not_ends_with: String
  rank: RankWhereInput
  exam: ExamWhereInput
  session: SessionWhereInput
  center: ExamCenterWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  report_every: ReportWhereInput
  report_some: ReportWhereInput
  report_none: ReportWhereInput
  AND: [CenterAdminWhereInput!]
  OR: [CenterAdminWhereInput!]
  NOT: [CenterAdminWhereInput!]
}

input CenterAdminWhereUniqueInput {
  id: ID
}

scalar DateTime

type Division {
  id: ID!
  divName: String!
  divCode: String!
  region: Region!
  subDivision(where: SubDivisionWhereInput, orderBy: SubDivisionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SubDivision!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DivisionConnection {
  pageInfo: PageInfo!
  edges: [DivisionEdge]!
  aggregate: AggregateDivision!
}

input DivisionCreateInput {
  id: ID
  divName: String!
  divCode: String!
  region: RegionCreateOneWithoutDivisionInput!
  subDivision: SubDivisionCreateManyWithoutDivisionInput
}

input DivisionCreateManyWithoutRegionInput {
  create: [DivisionCreateWithoutRegionInput!]
  connect: [DivisionWhereUniqueInput!]
}

input DivisionCreateOneWithoutSubDivisionInput {
  create: DivisionCreateWithoutSubDivisionInput
  connect: DivisionWhereUniqueInput
}

input DivisionCreateWithoutRegionInput {
  id: ID
  divName: String!
  divCode: String!
  subDivision: SubDivisionCreateManyWithoutDivisionInput
}

input DivisionCreateWithoutSubDivisionInput {
  id: ID
  divName: String!
  divCode: String!
  region: RegionCreateOneWithoutDivisionInput!
}

type DivisionEdge {
  node: Division!
  cursor: String!
}

enum DivisionOrderByInput {
  id_ASC
  id_DESC
  divName_ASC
  divName_DESC
  divCode_ASC
  divCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type DivisionPreviousValues {
  id: ID!
  divName: String!
  divCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input DivisionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  divName: String
  divName_not: String
  divName_in: [String!]
  divName_not_in: [String!]
  divName_lt: String
  divName_lte: String
  divName_gt: String
  divName_gte: String
  divName_contains: String
  divName_not_contains: String
  divName_starts_with: String
  divName_not_starts_with: String
  divName_ends_with: String
  divName_not_ends_with: String
  divCode: String
  divCode_not: String
  divCode_in: [String!]
  divCode_not_in: [String!]
  divCode_lt: String
  divCode_lte: String
  divCode_gt: String
  divCode_gte: String
  divCode_contains: String
  divCode_not_contains: String
  divCode_starts_with: String
  divCode_not_starts_with: String
  divCode_ends_with: String
  divCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [DivisionScalarWhereInput!]
  OR: [DivisionScalarWhereInput!]
  NOT: [DivisionScalarWhereInput!]
}

type DivisionSubscriptionPayload {
  mutation: MutationType!
  node: Division
  updatedFields: [String!]
  previousValues: DivisionPreviousValues
}

input DivisionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DivisionWhereInput
  AND: [DivisionSubscriptionWhereInput!]
  OR: [DivisionSubscriptionWhereInput!]
  NOT: [DivisionSubscriptionWhereInput!]
}

input DivisionUpdateInput {
  divName: String
  divCode: String
  region: RegionUpdateOneRequiredWithoutDivisionInput
  subDivision: SubDivisionUpdateManyWithoutDivisionInput
}

input DivisionUpdateManyDataInput {
  divName: String
  divCode: String
}

input DivisionUpdateManyMutationInput {
  divName: String
  divCode: String
}

input DivisionUpdateManyWithoutRegionInput {
  create: [DivisionCreateWithoutRegionInput!]
  delete: [DivisionWhereUniqueInput!]
  connect: [DivisionWhereUniqueInput!]
  set: [DivisionWhereUniqueInput!]
  disconnect: [DivisionWhereUniqueInput!]
  update: [DivisionUpdateWithWhereUniqueWithoutRegionInput!]
  upsert: [DivisionUpsertWithWhereUniqueWithoutRegionInput!]
  deleteMany: [DivisionScalarWhereInput!]
  updateMany: [DivisionUpdateManyWithWhereNestedInput!]
}

input DivisionUpdateManyWithWhereNestedInput {
  where: DivisionScalarWhereInput!
  data: DivisionUpdateManyDataInput!
}

input DivisionUpdateOneRequiredWithoutSubDivisionInput {
  create: DivisionCreateWithoutSubDivisionInput
  update: DivisionUpdateWithoutSubDivisionDataInput
  upsert: DivisionUpsertWithoutSubDivisionInput
  connect: DivisionWhereUniqueInput
}

input DivisionUpdateWithoutRegionDataInput {
  divName: String
  divCode: String
  subDivision: SubDivisionUpdateManyWithoutDivisionInput
}

input DivisionUpdateWithoutSubDivisionDataInput {
  divName: String
  divCode: String
  region: RegionUpdateOneRequiredWithoutDivisionInput
}

input DivisionUpdateWithWhereUniqueWithoutRegionInput {
  where: DivisionWhereUniqueInput!
  data: DivisionUpdateWithoutRegionDataInput!
}

input DivisionUpsertWithoutSubDivisionInput {
  update: DivisionUpdateWithoutSubDivisionDataInput!
  create: DivisionCreateWithoutSubDivisionInput!
}

input DivisionUpsertWithWhereUniqueWithoutRegionInput {
  where: DivisionWhereUniqueInput!
  update: DivisionUpdateWithoutRegionDataInput!
  create: DivisionCreateWithoutRegionInput!
}

input DivisionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  divName: String
  divName_not: String
  divName_in: [String!]
  divName_not_in: [String!]
  divName_lt: String
  divName_lte: String
  divName_gt: String
  divName_gte: String
  divName_contains: String
  divName_not_contains: String
  divName_starts_with: String
  divName_not_starts_with: String
  divName_ends_with: String
  divName_not_ends_with: String
  divCode: String
  divCode_not: String
  divCode_in: [String!]
  divCode_not_in: [String!]
  divCode_lt: String
  divCode_lte: String
  divCode_gt: String
  divCode_gte: String
  divCode_contains: String
  divCode_not_contains: String
  divCode_starts_with: String
  divCode_not_starts_with: String
  divCode_ends_with: String
  divCode_not_ends_with: String
  region: RegionWhereInput
  subDivision_every: SubDivisionWhereInput
  subDivision_some: SubDivisionWhereInput
  subDivision_none: SubDivisionWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [DivisionWhereInput!]
  OR: [DivisionWhereInput!]
  NOT: [DivisionWhereInput!]
}

input DivisionWhereUniqueInput {
  id: ID
}

type EducationType {
  id: ID!
  educationTypeName: String
  educationTypeCode: String
  createdAt: DateTime!
  updatedAt: DateTime!
  series(where: SeriesWhereInput, orderBy: SeriesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Series!]
}

type EducationTypeConnection {
  pageInfo: PageInfo!
  edges: [EducationTypeEdge]!
  aggregate: AggregateEducationType!
}

input EducationTypeCreateInput {
  id: ID
  educationTypeName: String
  educationTypeCode: String
  series: SeriesCreateManyWithoutEducationTypeInput
}

input EducationTypeCreateOneWithoutSeriesInput {
  create: EducationTypeCreateWithoutSeriesInput
  connect: EducationTypeWhereUniqueInput
}

input EducationTypeCreateWithoutSeriesInput {
  id: ID
  educationTypeName: String
  educationTypeCode: String
}

type EducationTypeEdge {
  node: EducationType!
  cursor: String!
}

enum EducationTypeOrderByInput {
  id_ASC
  id_DESC
  educationTypeName_ASC
  educationTypeName_DESC
  educationTypeCode_ASC
  educationTypeCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type EducationTypePreviousValues {
  id: ID!
  educationTypeName: String
  educationTypeCode: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type EducationTypeSubscriptionPayload {
  mutation: MutationType!
  node: EducationType
  updatedFields: [String!]
  previousValues: EducationTypePreviousValues
}

input EducationTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EducationTypeWhereInput
  AND: [EducationTypeSubscriptionWhereInput!]
  OR: [EducationTypeSubscriptionWhereInput!]
  NOT: [EducationTypeSubscriptionWhereInput!]
}

input EducationTypeUpdateInput {
  educationTypeName: String
  educationTypeCode: String
  series: SeriesUpdateManyWithoutEducationTypeInput
}

input EducationTypeUpdateManyMutationInput {
  educationTypeName: String
  educationTypeCode: String
}

input EducationTypeUpdateOneRequiredWithoutSeriesInput {
  create: EducationTypeCreateWithoutSeriesInput
  update: EducationTypeUpdateWithoutSeriesDataInput
  upsert: EducationTypeUpsertWithoutSeriesInput
  connect: EducationTypeWhereUniqueInput
}

input EducationTypeUpdateWithoutSeriesDataInput {
  educationTypeName: String
  educationTypeCode: String
}

input EducationTypeUpsertWithoutSeriesInput {
  update: EducationTypeUpdateWithoutSeriesDataInput!
  create: EducationTypeCreateWithoutSeriesInput!
}

input EducationTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  educationTypeName: String
  educationTypeName_not: String
  educationTypeName_in: [String!]
  educationTypeName_not_in: [String!]
  educationTypeName_lt: String
  educationTypeName_lte: String
  educationTypeName_gt: String
  educationTypeName_gte: String
  educationTypeName_contains: String
  educationTypeName_not_contains: String
  educationTypeName_starts_with: String
  educationTypeName_not_starts_with: String
  educationTypeName_ends_with: String
  educationTypeName_not_ends_with: String
  educationTypeCode: String
  educationTypeCode_not: String
  educationTypeCode_in: [String!]
  educationTypeCode_not_in: [String!]
  educationTypeCode_lt: String
  educationTypeCode_lte: String
  educationTypeCode_gt: String
  educationTypeCode_gte: String
  educationTypeCode_contains: String
  educationTypeCode_not_contains: String
  educationTypeCode_starts_with: String
  educationTypeCode_not_starts_with: String
  educationTypeCode_ends_with: String
  educationTypeCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  series_every: SeriesWhereInput
  series_some: SeriesWhereInput
  series_none: SeriesWhereInput
  AND: [EducationTypeWhereInput!]
  OR: [EducationTypeWhereInput!]
  NOT: [EducationTypeWhereInput!]
}

input EducationTypeWhereUniqueInput {
  id: ID
}

type Exam {
  id: ID!
  examName: String!
  examCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  centerAdmin(where: CenterAdminWhereInput, orderBy: CenterAdminOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CenterAdmin!]
  annExamSeriesSubj(where: AnnualExamSubjectSeriesWhereInput, orderBy: AnnualExamSubjectSeriesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AnnualExamSubjectSeries!]
  registration(where: RegistrationWhereInput, orderBy: RegistrationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Registration!]
}

type ExamCenter {
  id: ID!
  centerName: String!
  centerCode: String!
  town: Town!
  centerNumber: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  registration(where: RegistrationWhereInput, orderBy: RegistrationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Registration!]
  centerAdmin(where: CenterAdminWhereInput, orderBy: CenterAdminOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CenterAdmin!]
}

type ExamCenterConnection {
  pageInfo: PageInfo!
  edges: [ExamCenterEdge]!
  aggregate: AggregateExamCenter!
}

input ExamCenterCreateInput {
  id: ID
  centerName: String!
  centerCode: String!
  town: TownCreateOneWithoutCenterInput!
  centerNumber: Int!
  registration: RegistrationCreateManyWithoutCenterInput
  centerAdmin: CenterAdminCreateManyWithoutCenterInput
}

input ExamCenterCreateManyWithoutTownInput {
  create: [ExamCenterCreateWithoutTownInput!]
  connect: [ExamCenterWhereUniqueInput!]
}

input ExamCenterCreateOneInput {
  create: ExamCenterCreateInput
  connect: ExamCenterWhereUniqueInput
}

input ExamCenterCreateOneWithoutCenterAdminInput {
  create: ExamCenterCreateWithoutCenterAdminInput
  connect: ExamCenterWhereUniqueInput
}

input ExamCenterCreateOneWithoutRegistrationInput {
  create: ExamCenterCreateWithoutRegistrationInput
  connect: ExamCenterWhereUniqueInput
}

input ExamCenterCreateWithoutCenterAdminInput {
  id: ID
  centerName: String!
  centerCode: String!
  town: TownCreateOneWithoutCenterInput!
  centerNumber: Int!
  registration: RegistrationCreateManyWithoutCenterInput
}

input ExamCenterCreateWithoutRegistrationInput {
  id: ID
  centerName: String!
  centerCode: String!
  town: TownCreateOneWithoutCenterInput!
  centerNumber: Int!
  centerAdmin: CenterAdminCreateManyWithoutCenterInput
}

input ExamCenterCreateWithoutTownInput {
  id: ID
  centerName: String!
  centerCode: String!
  centerNumber: Int!
  registration: RegistrationCreateManyWithoutCenterInput
  centerAdmin: CenterAdminCreateManyWithoutCenterInput
}

type ExamCenterEdge {
  node: ExamCenter!
  cursor: String!
}

enum ExamCenterOrderByInput {
  id_ASC
  id_DESC
  centerName_ASC
  centerName_DESC
  centerCode_ASC
  centerCode_DESC
  centerNumber_ASC
  centerNumber_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ExamCenterPreviousValues {
  id: ID!
  centerName: String!
  centerCode: String!
  centerNumber: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ExamCenterScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  centerName: String
  centerName_not: String
  centerName_in: [String!]
  centerName_not_in: [String!]
  centerName_lt: String
  centerName_lte: String
  centerName_gt: String
  centerName_gte: String
  centerName_contains: String
  centerName_not_contains: String
  centerName_starts_with: String
  centerName_not_starts_with: String
  centerName_ends_with: String
  centerName_not_ends_with: String
  centerCode: String
  centerCode_not: String
  centerCode_in: [String!]
  centerCode_not_in: [String!]
  centerCode_lt: String
  centerCode_lte: String
  centerCode_gt: String
  centerCode_gte: String
  centerCode_contains: String
  centerCode_not_contains: String
  centerCode_starts_with: String
  centerCode_not_starts_with: String
  centerCode_ends_with: String
  centerCode_not_ends_with: String
  centerNumber: Int
  centerNumber_not: Int
  centerNumber_in: [Int!]
  centerNumber_not_in: [Int!]
  centerNumber_lt: Int
  centerNumber_lte: Int
  centerNumber_gt: Int
  centerNumber_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ExamCenterScalarWhereInput!]
  OR: [ExamCenterScalarWhereInput!]
  NOT: [ExamCenterScalarWhereInput!]
}

type ExamCenterSubscriptionPayload {
  mutation: MutationType!
  node: ExamCenter
  updatedFields: [String!]
  previousValues: ExamCenterPreviousValues
}

input ExamCenterSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExamCenterWhereInput
  AND: [ExamCenterSubscriptionWhereInput!]
  OR: [ExamCenterSubscriptionWhereInput!]
  NOT: [ExamCenterSubscriptionWhereInput!]
}

input ExamCenterUpdateDataInput {
  centerName: String
  centerCode: String
  town: TownUpdateOneRequiredWithoutCenterInput
  centerNumber: Int
  registration: RegistrationUpdateManyWithoutCenterInput
  centerAdmin: CenterAdminUpdateManyWithoutCenterInput
}

input ExamCenterUpdateInput {
  centerName: String
  centerCode: String
  town: TownUpdateOneRequiredWithoutCenterInput
  centerNumber: Int
  registration: RegistrationUpdateManyWithoutCenterInput
  centerAdmin: CenterAdminUpdateManyWithoutCenterInput
}

input ExamCenterUpdateManyDataInput {
  centerName: String
  centerCode: String
  centerNumber: Int
}

input ExamCenterUpdateManyMutationInput {
  centerName: String
  centerCode: String
  centerNumber: Int
}

input ExamCenterUpdateManyWithoutTownInput {
  create: [ExamCenterCreateWithoutTownInput!]
  delete: [ExamCenterWhereUniqueInput!]
  connect: [ExamCenterWhereUniqueInput!]
  set: [ExamCenterWhereUniqueInput!]
  disconnect: [ExamCenterWhereUniqueInput!]
  update: [ExamCenterUpdateWithWhereUniqueWithoutTownInput!]
  upsert: [ExamCenterUpsertWithWhereUniqueWithoutTownInput!]
  deleteMany: [ExamCenterScalarWhereInput!]
  updateMany: [ExamCenterUpdateManyWithWhereNestedInput!]
}

input ExamCenterUpdateManyWithWhereNestedInput {
  where: ExamCenterScalarWhereInput!
  data: ExamCenterUpdateManyDataInput!
}

input ExamCenterUpdateOneRequiredInput {
  create: ExamCenterCreateInput
  update: ExamCenterUpdateDataInput
  upsert: ExamCenterUpsertNestedInput
  connect: ExamCenterWhereUniqueInput
}

input ExamCenterUpdateOneRequiredWithoutCenterAdminInput {
  create: ExamCenterCreateWithoutCenterAdminInput
  update: ExamCenterUpdateWithoutCenterAdminDataInput
  upsert: ExamCenterUpsertWithoutCenterAdminInput
  connect: ExamCenterWhereUniqueInput
}

input ExamCenterUpdateOneRequiredWithoutRegistrationInput {
  create: ExamCenterCreateWithoutRegistrationInput
  update: ExamCenterUpdateWithoutRegistrationDataInput
  upsert: ExamCenterUpsertWithoutRegistrationInput
  connect: ExamCenterWhereUniqueInput
}

input ExamCenterUpdateWithoutCenterAdminDataInput {
  centerName: String
  centerCode: String
  town: TownUpdateOneRequiredWithoutCenterInput
  centerNumber: Int
  registration: RegistrationUpdateManyWithoutCenterInput
}

input ExamCenterUpdateWithoutRegistrationDataInput {
  centerName: String
  centerCode: String
  town: TownUpdateOneRequiredWithoutCenterInput
  centerNumber: Int
  centerAdmin: CenterAdminUpdateManyWithoutCenterInput
}

input ExamCenterUpdateWithoutTownDataInput {
  centerName: String
  centerCode: String
  centerNumber: Int
  registration: RegistrationUpdateManyWithoutCenterInput
  centerAdmin: CenterAdminUpdateManyWithoutCenterInput
}

input ExamCenterUpdateWithWhereUniqueWithoutTownInput {
  where: ExamCenterWhereUniqueInput!
  data: ExamCenterUpdateWithoutTownDataInput!
}

input ExamCenterUpsertNestedInput {
  update: ExamCenterUpdateDataInput!
  create: ExamCenterCreateInput!
}

input ExamCenterUpsertWithoutCenterAdminInput {
  update: ExamCenterUpdateWithoutCenterAdminDataInput!
  create: ExamCenterCreateWithoutCenterAdminInput!
}

input ExamCenterUpsertWithoutRegistrationInput {
  update: ExamCenterUpdateWithoutRegistrationDataInput!
  create: ExamCenterCreateWithoutRegistrationInput!
}

input ExamCenterUpsertWithWhereUniqueWithoutTownInput {
  where: ExamCenterWhereUniqueInput!
  update: ExamCenterUpdateWithoutTownDataInput!
  create: ExamCenterCreateWithoutTownInput!
}

input ExamCenterWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  centerName: String
  centerName_not: String
  centerName_in: [String!]
  centerName_not_in: [String!]
  centerName_lt: String
  centerName_lte: String
  centerName_gt: String
  centerName_gte: String
  centerName_contains: String
  centerName_not_contains: String
  centerName_starts_with: String
  centerName_not_starts_with: String
  centerName_ends_with: String
  centerName_not_ends_with: String
  centerCode: String
  centerCode_not: String
  centerCode_in: [String!]
  centerCode_not_in: [String!]
  centerCode_lt: String
  centerCode_lte: String
  centerCode_gt: String
  centerCode_gte: String
  centerCode_contains: String
  centerCode_not_contains: String
  centerCode_starts_with: String
  centerCode_not_starts_with: String
  centerCode_ends_with: String
  centerCode_not_ends_with: String
  town: TownWhereInput
  centerNumber: Int
  centerNumber_not: Int
  centerNumber_in: [Int!]
  centerNumber_not_in: [Int!]
  centerNumber_lt: Int
  centerNumber_lte: Int
  centerNumber_gt: Int
  centerNumber_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  registration_every: RegistrationWhereInput
  registration_some: RegistrationWhereInput
  registration_none: RegistrationWhereInput
  centerAdmin_every: CenterAdminWhereInput
  centerAdmin_some: CenterAdminWhereInput
  centerAdmin_none: CenterAdminWhereInput
  AND: [ExamCenterWhereInput!]
  OR: [ExamCenterWhereInput!]
  NOT: [ExamCenterWhereInput!]
}

input ExamCenterWhereUniqueInput {
  id: ID
  centerNumber: Int
}

type ExamConnection {
  pageInfo: PageInfo!
  edges: [ExamEdge]!
  aggregate: AggregateExam!
}

input ExamCreateInput {
  id: ID
  examName: String!
  examCode: String!
  centerAdmin: CenterAdminCreateManyWithoutExamInput
  annExamSeriesSubj: AnnualExamSubjectSeriesCreateManyWithoutExamInput
  registration: RegistrationCreateManyWithoutExamInput
}

input ExamCreateOneWithoutAnnExamSeriesSubjInput {
  create: ExamCreateWithoutAnnExamSeriesSubjInput
  connect: ExamWhereUniqueInput
}

input ExamCreateOneWithoutCenterAdminInput {
  create: ExamCreateWithoutCenterAdminInput
  connect: ExamWhereUniqueInput
}

input ExamCreateOneWithoutRegistrationInput {
  create: ExamCreateWithoutRegistrationInput
  connect: ExamWhereUniqueInput
}

input ExamCreateWithoutAnnExamSeriesSubjInput {
  id: ID
  examName: String!
  examCode: String!
  centerAdmin: CenterAdminCreateManyWithoutExamInput
  registration: RegistrationCreateManyWithoutExamInput
}

input ExamCreateWithoutCenterAdminInput {
  id: ID
  examName: String!
  examCode: String!
  annExamSeriesSubj: AnnualExamSubjectSeriesCreateManyWithoutExamInput
  registration: RegistrationCreateManyWithoutExamInput
}

input ExamCreateWithoutRegistrationInput {
  id: ID
  examName: String!
  examCode: String!
  centerAdmin: CenterAdminCreateManyWithoutExamInput
  annExamSeriesSubj: AnnualExamSubjectSeriesCreateManyWithoutExamInput
}

type ExamEdge {
  node: Exam!
  cursor: String!
}

enum ExamOrderByInput {
  id_ASC
  id_DESC
  examName_ASC
  examName_DESC
  examCode_ASC
  examCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ExamPreviousValues {
  id: ID!
  examName: String!
  examCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ExamSubscriptionPayload {
  mutation: MutationType!
  node: Exam
  updatedFields: [String!]
  previousValues: ExamPreviousValues
}

input ExamSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExamWhereInput
  AND: [ExamSubscriptionWhereInput!]
  OR: [ExamSubscriptionWhereInput!]
  NOT: [ExamSubscriptionWhereInput!]
}

input ExamUpdateInput {
  examName: String
  examCode: String
  centerAdmin: CenterAdminUpdateManyWithoutExamInput
  annExamSeriesSubj: AnnualExamSubjectSeriesUpdateManyWithoutExamInput
  registration: RegistrationUpdateManyWithoutExamInput
}

input ExamUpdateManyMutationInput {
  examName: String
  examCode: String
}

input ExamUpdateOneRequiredWithoutAnnExamSeriesSubjInput {
  create: ExamCreateWithoutAnnExamSeriesSubjInput
  update: ExamUpdateWithoutAnnExamSeriesSubjDataInput
  upsert: ExamUpsertWithoutAnnExamSeriesSubjInput
  connect: ExamWhereUniqueInput
}

input ExamUpdateOneRequiredWithoutCenterAdminInput {
  create: ExamCreateWithoutCenterAdminInput
  update: ExamUpdateWithoutCenterAdminDataInput
  upsert: ExamUpsertWithoutCenterAdminInput
  connect: ExamWhereUniqueInput
}

input ExamUpdateOneRequiredWithoutRegistrationInput {
  create: ExamCreateWithoutRegistrationInput
  update: ExamUpdateWithoutRegistrationDataInput
  upsert: ExamUpsertWithoutRegistrationInput
  connect: ExamWhereUniqueInput
}

input ExamUpdateWithoutAnnExamSeriesSubjDataInput {
  examName: String
  examCode: String
  centerAdmin: CenterAdminUpdateManyWithoutExamInput
  registration: RegistrationUpdateManyWithoutExamInput
}

input ExamUpdateWithoutCenterAdminDataInput {
  examName: String
  examCode: String
  annExamSeriesSubj: AnnualExamSubjectSeriesUpdateManyWithoutExamInput
  registration: RegistrationUpdateManyWithoutExamInput
}

input ExamUpdateWithoutRegistrationDataInput {
  examName: String
  examCode: String
  centerAdmin: CenterAdminUpdateManyWithoutExamInput
  annExamSeriesSubj: AnnualExamSubjectSeriesUpdateManyWithoutExamInput
}

input ExamUpsertWithoutAnnExamSeriesSubjInput {
  update: ExamUpdateWithoutAnnExamSeriesSubjDataInput!
  create: ExamCreateWithoutAnnExamSeriesSubjInput!
}

input ExamUpsertWithoutCenterAdminInput {
  update: ExamUpdateWithoutCenterAdminDataInput!
  create: ExamCreateWithoutCenterAdminInput!
}

input ExamUpsertWithoutRegistrationInput {
  update: ExamUpdateWithoutRegistrationDataInput!
  create: ExamCreateWithoutRegistrationInput!
}

input ExamWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  examName: String
  examName_not: String
  examName_in: [String!]
  examName_not_in: [String!]
  examName_lt: String
  examName_lte: String
  examName_gt: String
  examName_gte: String
  examName_contains: String
  examName_not_contains: String
  examName_starts_with: String
  examName_not_starts_with: String
  examName_ends_with: String
  examName_not_ends_with: String
  examCode: String
  examCode_not: String
  examCode_in: [String!]
  examCode_not_in: [String!]
  examCode_lt: String
  examCode_lte: String
  examCode_gt: String
  examCode_gte: String
  examCode_contains: String
  examCode_not_contains: String
  examCode_starts_with: String
  examCode_not_starts_with: String
  examCode_ends_with: String
  examCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  centerAdmin_every: CenterAdminWhereInput
  centerAdmin_some: CenterAdminWhereInput
  centerAdmin_none: CenterAdminWhereInput
  annExamSeriesSubj_every: AnnualExamSubjectSeriesWhereInput
  annExamSeriesSubj_some: AnnualExamSubjectSeriesWhereInput
  annExamSeriesSubj_none: AnnualExamSubjectSeriesWhereInput
  registration_every: RegistrationWhereInput
  registration_some: RegistrationWhereInput
  registration_none: RegistrationWhereInput
  AND: [ExamWhereInput!]
  OR: [ExamWhereInput!]
  NOT: [ExamWhereInput!]
}

input ExamWhereUniqueInput {
  id: ID
}

type Gender {
  id: ID!
  genderName: String!
  genderCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  candidate(where: CandidateWhereInput, orderBy: CandidateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Candidate!]
}

type GenderConnection {
  pageInfo: PageInfo!
  edges: [GenderEdge]!
  aggregate: AggregateGender!
}

input GenderCreateInput {
  id: ID
  genderName: String!
  genderCode: String!
  candidate: CandidateCreateManyWithoutGenderInput
}

input GenderCreateOneWithoutCandidateInput {
  create: GenderCreateWithoutCandidateInput
  connect: GenderWhereUniqueInput
}

input GenderCreateWithoutCandidateInput {
  id: ID
  genderName: String!
  genderCode: String!
}

type GenderEdge {
  node: Gender!
  cursor: String!
}

enum GenderOrderByInput {
  id_ASC
  id_DESC
  genderName_ASC
  genderName_DESC
  genderCode_ASC
  genderCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type GenderPreviousValues {
  id: ID!
  genderName: String!
  genderCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type GenderSubscriptionPayload {
  mutation: MutationType!
  node: Gender
  updatedFields: [String!]
  previousValues: GenderPreviousValues
}

input GenderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GenderWhereInput
  AND: [GenderSubscriptionWhereInput!]
  OR: [GenderSubscriptionWhereInput!]
  NOT: [GenderSubscriptionWhereInput!]
}

input GenderUpdateInput {
  genderName: String
  genderCode: String
  candidate: CandidateUpdateManyWithoutGenderInput
}

input GenderUpdateManyMutationInput {
  genderName: String
  genderCode: String
}

input GenderUpdateOneRequiredWithoutCandidateInput {
  create: GenderCreateWithoutCandidateInput
  update: GenderUpdateWithoutCandidateDataInput
  upsert: GenderUpsertWithoutCandidateInput
  connect: GenderWhereUniqueInput
}

input GenderUpdateWithoutCandidateDataInput {
  genderName: String
  genderCode: String
}

input GenderUpsertWithoutCandidateInput {
  update: GenderUpdateWithoutCandidateDataInput!
  create: GenderCreateWithoutCandidateInput!
}

input GenderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  genderName: String
  genderName_not: String
  genderName_in: [String!]
  genderName_not_in: [String!]
  genderName_lt: String
  genderName_lte: String
  genderName_gt: String
  genderName_gte: String
  genderName_contains: String
  genderName_not_contains: String
  genderName_starts_with: String
  genderName_not_starts_with: String
  genderName_ends_with: String
  genderName_not_ends_with: String
  genderCode: String
  genderCode_not: String
  genderCode_in: [String!]
  genderCode_not_in: [String!]
  genderCode_lt: String
  genderCode_lte: String
  genderCode_gt: String
  genderCode_gte: String
  genderCode_contains: String
  genderCode_not_contains: String
  genderCode_starts_with: String
  genderCode_not_starts_with: String
  genderCode_ends_with: String
  genderCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  candidate_every: CandidateWhereInput
  candidate_some: CandidateWhereInput
  candidate_none: CandidateWhereInput
  AND: [GenderWhereInput!]
  OR: [GenderWhereInput!]
  NOT: [GenderWhereInput!]
}

input GenderWhereUniqueInput {
  id: ID
}

type Item {
  id: ID!
  title: String!
  descrption: String!
  image: String
  largeImage: String
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User!
}

type ItemConnection {
  pageInfo: PageInfo!
  edges: [ItemEdge]!
  aggregate: AggregateItem!
}

input ItemCreateInput {
  id: ID
  title: String!
  descrption: String!
  image: String
  largeImage: String
  user: UserCreateOneWithoutItemInput!
}

input ItemCreateManyWithoutUserInput {
  create: [ItemCreateWithoutUserInput!]
  connect: [ItemWhereUniqueInput!]
}

input ItemCreateWithoutUserInput {
  id: ID
  title: String!
  descrption: String!
  image: String
  largeImage: String
}

type ItemEdge {
  node: Item!
  cursor: String!
}

enum ItemOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  descrption_ASC
  descrption_DESC
  image_ASC
  image_DESC
  largeImage_ASC
  largeImage_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ItemPreviousValues {
  id: ID!
  title: String!
  descrption: String!
  image: String
  largeImage: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  descrption: String
  descrption_not: String
  descrption_in: [String!]
  descrption_not_in: [String!]
  descrption_lt: String
  descrption_lte: String
  descrption_gt: String
  descrption_gte: String
  descrption_contains: String
  descrption_not_contains: String
  descrption_starts_with: String
  descrption_not_starts_with: String
  descrption_ends_with: String
  descrption_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  largeImage: String
  largeImage_not: String
  largeImage_in: [String!]
  largeImage_not_in: [String!]
  largeImage_lt: String
  largeImage_lte: String
  largeImage_gt: String
  largeImage_gte: String
  largeImage_contains: String
  largeImage_not_contains: String
  largeImage_starts_with: String
  largeImage_not_starts_with: String
  largeImage_ends_with: String
  largeImage_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ItemScalarWhereInput!]
  OR: [ItemScalarWhereInput!]
  NOT: [ItemScalarWhereInput!]
}

type ItemSubscriptionPayload {
  mutation: MutationType!
  node: Item
  updatedFields: [String!]
  previousValues: ItemPreviousValues
}

input ItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ItemWhereInput
  AND: [ItemSubscriptionWhereInput!]
  OR: [ItemSubscriptionWhereInput!]
  NOT: [ItemSubscriptionWhereInput!]
}

input ItemUpdateInput {
  title: String
  descrption: String
  image: String
  largeImage: String
  user: UserUpdateOneRequiredWithoutItemInput
}

input ItemUpdateManyDataInput {
  title: String
  descrption: String
  image: String
  largeImage: String
}

input ItemUpdateManyMutationInput {
  title: String
  descrption: String
  image: String
  largeImage: String
}

input ItemUpdateManyWithoutUserInput {
  create: [ItemCreateWithoutUserInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput!
  data: ItemUpdateManyDataInput!
}

input ItemUpdateWithoutUserDataInput {
  title: String
  descrption: String
  image: String
  largeImage: String
}

input ItemUpdateWithWhereUniqueWithoutUserInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateWithoutUserDataInput!
}

input ItemUpsertWithWhereUniqueWithoutUserInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateWithoutUserDataInput!
  create: ItemCreateWithoutUserInput!
}

input ItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  descrption: String
  descrption_not: String
  descrption_in: [String!]
  descrption_not_in: [String!]
  descrption_lt: String
  descrption_lte: String
  descrption_gt: String
  descrption_gte: String
  descrption_contains: String
  descrption_not_contains: String
  descrption_starts_with: String
  descrption_not_starts_with: String
  descrption_ends_with: String
  descrption_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  largeImage: String
  largeImage_not: String
  largeImage_in: [String!]
  largeImage_not_in: [String!]
  largeImage_lt: String
  largeImage_lte: String
  largeImage_gt: String
  largeImage_gte: String
  largeImage_contains: String
  largeImage_not_contains: String
  largeImage_starts_with: String
  largeImage_not_starts_with: String
  largeImage_ends_with: String
  largeImage_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  user: UserWhereInput
  AND: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
}

input ItemWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createAnnualExamSubjectSeries(data: AnnualExamSubjectSeriesCreateInput!): AnnualExamSubjectSeries!
  updateAnnualExamSubjectSeries(data: AnnualExamSubjectSeriesUpdateInput!, where: AnnualExamSubjectSeriesWhereUniqueInput!): AnnualExamSubjectSeries
  updateManyAnnualExamSubjectSerieses(data: AnnualExamSubjectSeriesUpdateManyMutationInput!, where: AnnualExamSubjectSeriesWhereInput): BatchPayload!
  upsertAnnualExamSubjectSeries(where: AnnualExamSubjectSeriesWhereUniqueInput!, create: AnnualExamSubjectSeriesCreateInput!, update: AnnualExamSubjectSeriesUpdateInput!): AnnualExamSubjectSeries!
  deleteAnnualExamSubjectSeries(where: AnnualExamSubjectSeriesWhereUniqueInput!): AnnualExamSubjectSeries
  deleteManyAnnualExamSubjectSerieses(where: AnnualExamSubjectSeriesWhereInput): BatchPayload!
  createAnotherType(data: AnotherTypeCreateInput!): AnotherType!
  deleteAnotherType(where: AnotherTypeWhereUniqueInput!): AnotherType
  deleteManyAnotherTypes(where: AnotherTypeWhereInput): BatchPayload!
  createCandidate(data: CandidateCreateInput!): Candidate!
  updateCandidate(data: CandidateUpdateInput!, where: CandidateWhereUniqueInput!): Candidate
  updateManyCandidates(data: CandidateUpdateManyMutationInput!, where: CandidateWhereInput): BatchPayload!
  upsertCandidate(where: CandidateWhereUniqueInput!, create: CandidateCreateInput!, update: CandidateUpdateInput!): Candidate!
  deleteCandidate(where: CandidateWhereUniqueInput!): Candidate
  deleteManyCandidates(where: CandidateWhereInput): BatchPayload!
  createCenterAdmin(data: CenterAdminCreateInput!): CenterAdmin!
  updateCenterAdmin(data: CenterAdminUpdateInput!, where: CenterAdminWhereUniqueInput!): CenterAdmin
  updateManyCenterAdmins(data: CenterAdminUpdateManyMutationInput!, where: CenterAdminWhereInput): BatchPayload!
  upsertCenterAdmin(where: CenterAdminWhereUniqueInput!, create: CenterAdminCreateInput!, update: CenterAdminUpdateInput!): CenterAdmin!
  deleteCenterAdmin(where: CenterAdminWhereUniqueInput!): CenterAdmin
  deleteManyCenterAdmins(where: CenterAdminWhereInput): BatchPayload!
  createDivision(data: DivisionCreateInput!): Division!
  updateDivision(data: DivisionUpdateInput!, where: DivisionWhereUniqueInput!): Division
  updateManyDivisions(data: DivisionUpdateManyMutationInput!, where: DivisionWhereInput): BatchPayload!
  upsertDivision(where: DivisionWhereUniqueInput!, create: DivisionCreateInput!, update: DivisionUpdateInput!): Division!
  deleteDivision(where: DivisionWhereUniqueInput!): Division
  deleteManyDivisions(where: DivisionWhereInput): BatchPayload!
  createEducationType(data: EducationTypeCreateInput!): EducationType!
  updateEducationType(data: EducationTypeUpdateInput!, where: EducationTypeWhereUniqueInput!): EducationType
  updateManyEducationTypes(data: EducationTypeUpdateManyMutationInput!, where: EducationTypeWhereInput): BatchPayload!
  upsertEducationType(where: EducationTypeWhereUniqueInput!, create: EducationTypeCreateInput!, update: EducationTypeUpdateInput!): EducationType!
  deleteEducationType(where: EducationTypeWhereUniqueInput!): EducationType
  deleteManyEducationTypes(where: EducationTypeWhereInput): BatchPayload!
  createExam(data: ExamCreateInput!): Exam!
  updateExam(data: ExamUpdateInput!, where: ExamWhereUniqueInput!): Exam
  updateManyExams(data: ExamUpdateManyMutationInput!, where: ExamWhereInput): BatchPayload!
  upsertExam(where: ExamWhereUniqueInput!, create: ExamCreateInput!, update: ExamUpdateInput!): Exam!
  deleteExam(where: ExamWhereUniqueInput!): Exam
  deleteManyExams(where: ExamWhereInput): BatchPayload!
  createExamCenter(data: ExamCenterCreateInput!): ExamCenter!
  updateExamCenter(data: ExamCenterUpdateInput!, where: ExamCenterWhereUniqueInput!): ExamCenter
  updateManyExamCenters(data: ExamCenterUpdateManyMutationInput!, where: ExamCenterWhereInput): BatchPayload!
  upsertExamCenter(where: ExamCenterWhereUniqueInput!, create: ExamCenterCreateInput!, update: ExamCenterUpdateInput!): ExamCenter!
  deleteExamCenter(where: ExamCenterWhereUniqueInput!): ExamCenter
  deleteManyExamCenters(where: ExamCenterWhereInput): BatchPayload!
  createGender(data: GenderCreateInput!): Gender!
  updateGender(data: GenderUpdateInput!, where: GenderWhereUniqueInput!): Gender
  updateManyGenders(data: GenderUpdateManyMutationInput!, where: GenderWhereInput): BatchPayload!
  upsertGender(where: GenderWhereUniqueInput!, create: GenderCreateInput!, update: GenderUpdateInput!): Gender!
  deleteGender(where: GenderWhereUniqueInput!): Gender
  deleteManyGenders(where: GenderWhereInput): BatchPayload!
  createItem(data: ItemCreateInput!): Item!
  updateItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
  updateManyItems(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): BatchPayload!
  upsertItem(where: ItemWhereUniqueInput!, create: ItemCreateInput!, update: ItemUpdateInput!): Item!
  deleteItem(where: ItemWhereUniqueInput!): Item
  deleteManyItems(where: ItemWhereInput): BatchPayload!
  createPresence(data: PresenceCreateInput!): Presence!
  updatePresence(data: PresenceUpdateInput!, where: PresenceWhereUniqueInput!): Presence
  updateManyPresences(data: PresenceUpdateManyMutationInput!, where: PresenceWhereInput): BatchPayload!
  upsertPresence(where: PresenceWhereUniqueInput!, create: PresenceCreateInput!, update: PresenceUpdateInput!): Presence!
  deletePresence(where: PresenceWhereUniqueInput!): Presence
  deleteManyPresences(where: PresenceWhereInput): BatchPayload!
  createRank(data: RankCreateInput!): Rank!
  updateRank(data: RankUpdateInput!, where: RankWhereUniqueInput!): Rank
  updateManyRanks(data: RankUpdateManyMutationInput!, where: RankWhereInput): BatchPayload!
  upsertRank(where: RankWhereUniqueInput!, create: RankCreateInput!, update: RankUpdateInput!): Rank!
  deleteRank(where: RankWhereUniqueInput!): Rank
  deleteManyRanks(where: RankWhereInput): BatchPayload!
  createRegion(data: RegionCreateInput!): Region!
  updateRegion(data: RegionUpdateInput!, where: RegionWhereUniqueInput!): Region
  updateManyRegions(data: RegionUpdateManyMutationInput!, where: RegionWhereInput): BatchPayload!
  upsertRegion(where: RegionWhereUniqueInput!, create: RegionCreateInput!, update: RegionUpdateInput!): Region!
  deleteRegion(where: RegionWhereUniqueInput!): Region
  deleteManyRegions(where: RegionWhereInput): BatchPayload!
  createRegistration(data: RegistrationCreateInput!): Registration!
  updateRegistration(data: RegistrationUpdateInput!, where: RegistrationWhereUniqueInput!): Registration
  upsertRegistration(where: RegistrationWhereUniqueInput!, create: RegistrationCreateInput!, update: RegistrationUpdateInput!): Registration!
  deleteRegistration(where: RegistrationWhereUniqueInput!): Registration
  deleteManyRegistrations(where: RegistrationWhereInput): BatchPayload!
  createReport(data: ReportCreateInput!): Report!
  updateReport(data: ReportUpdateInput!, where: ReportWhereUniqueInput!): Report
  updateManyReports(data: ReportUpdateManyMutationInput!, where: ReportWhereInput): BatchPayload!
  upsertReport(where: ReportWhereUniqueInput!, create: ReportCreateInput!, update: ReportUpdateInput!): Report!
  deleteReport(where: ReportWhereUniqueInput!): Report
  deleteManyReports(where: ReportWhereInput): BatchPayload!
  createScore(data: ScoreCreateInput!): Score!
  updateScore(data: ScoreUpdateInput!, where: ScoreWhereUniqueInput!): Score
  updateManyScores(data: ScoreUpdateManyMutationInput!, where: ScoreWhereInput): BatchPayload!
  upsertScore(where: ScoreWhereUniqueInput!, create: ScoreCreateInput!, update: ScoreUpdateInput!): Score!
  deleteScore(where: ScoreWhereUniqueInput!): Score
  deleteManyScores(where: ScoreWhereInput): BatchPayload!
  createSeries(data: SeriesCreateInput!): Series!
  updateSeries(data: SeriesUpdateInput!, where: SeriesWhereUniqueInput!): Series
  updateManySerieses(data: SeriesUpdateManyMutationInput!, where: SeriesWhereInput): BatchPayload!
  upsertSeries(where: SeriesWhereUniqueInput!, create: SeriesCreateInput!, update: SeriesUpdateInput!): Series!
  deleteSeries(where: SeriesWhereUniqueInput!): Series
  deleteManySerieses(where: SeriesWhereInput): BatchPayload!
  createSession(data: SessionCreateInput!): Session!
  updateSession(data: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session
  updateManySessions(data: SessionUpdateManyMutationInput!, where: SessionWhereInput): BatchPayload!
  upsertSession(where: SessionWhereUniqueInput!, create: SessionCreateInput!, update: SessionUpdateInput!): Session!
  deleteSession(where: SessionWhereUniqueInput!): Session
  deleteManySessions(where: SessionWhereInput): BatchPayload!
  createSubDivision(data: SubDivisionCreateInput!): SubDivision!
  updateSubDivision(data: SubDivisionUpdateInput!, where: SubDivisionWhereUniqueInput!): SubDivision
  updateManySubDivisions(data: SubDivisionUpdateManyMutationInput!, where: SubDivisionWhereInput): BatchPayload!
  upsertSubDivision(where: SubDivisionWhereUniqueInput!, create: SubDivisionCreateInput!, update: SubDivisionUpdateInput!): SubDivision!
  deleteSubDivision(where: SubDivisionWhereUniqueInput!): SubDivision
  deleteManySubDivisions(where: SubDivisionWhereInput): BatchPayload!
  createSubject(data: SubjectCreateInput!): Subject!
  updateSubject(data: SubjectUpdateInput!, where: SubjectWhereUniqueInput!): Subject
  updateManySubjects(data: SubjectUpdateManyMutationInput!, where: SubjectWhereInput): BatchPayload!
  upsertSubject(where: SubjectWhereUniqueInput!, create: SubjectCreateInput!, update: SubjectUpdateInput!): Subject!
  deleteSubject(where: SubjectWhereUniqueInput!): Subject
  deleteManySubjects(where: SubjectWhereInput): BatchPayload!
  createTown(data: TownCreateInput!): Town!
  updateTown(data: TownUpdateInput!, where: TownWhereUniqueInput!): Town
  updateManyTowns(data: TownUpdateManyMutationInput!, where: TownWhereInput): BatchPayload!
  upsertTown(where: TownWhereUniqueInput!, create: TownCreateInput!, update: TownUpdateInput!): Town!
  deleteTown(where: TownWhereUniqueInput!): Town
  deleteManyTowns(where: TownWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Presence {
  id: ID!
  presenceName: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  score(where: ScoreWhereInput, orderBy: ScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Score!]
}

type PresenceConnection {
  pageInfo: PageInfo!
  edges: [PresenceEdge]!
  aggregate: AggregatePresence!
}

input PresenceCreateInput {
  id: ID
  presenceName: Boolean!
  score: ScoreCreateManyWithoutPresenceInput
}

input PresenceCreateOneWithoutScoreInput {
  create: PresenceCreateWithoutScoreInput
  connect: PresenceWhereUniqueInput
}

input PresenceCreateWithoutScoreInput {
  id: ID
  presenceName: Boolean!
}

type PresenceEdge {
  node: Presence!
  cursor: String!
}

enum PresenceOrderByInput {
  id_ASC
  id_DESC
  presenceName_ASC
  presenceName_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PresencePreviousValues {
  id: ID!
  presenceName: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PresenceSubscriptionPayload {
  mutation: MutationType!
  node: Presence
  updatedFields: [String!]
  previousValues: PresencePreviousValues
}

input PresenceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PresenceWhereInput
  AND: [PresenceSubscriptionWhereInput!]
  OR: [PresenceSubscriptionWhereInput!]
  NOT: [PresenceSubscriptionWhereInput!]
}

input PresenceUpdateInput {
  presenceName: Boolean
  score: ScoreUpdateManyWithoutPresenceInput
}

input PresenceUpdateManyMutationInput {
  presenceName: Boolean
}

input PresenceUpdateOneRequiredWithoutScoreInput {
  create: PresenceCreateWithoutScoreInput
  update: PresenceUpdateWithoutScoreDataInput
  upsert: PresenceUpsertWithoutScoreInput
  connect: PresenceWhereUniqueInput
}

input PresenceUpdateWithoutScoreDataInput {
  presenceName: Boolean
}

input PresenceUpsertWithoutScoreInput {
  update: PresenceUpdateWithoutScoreDataInput!
  create: PresenceCreateWithoutScoreInput!
}

input PresenceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  presenceName: Boolean
  presenceName_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  score_every: ScoreWhereInput
  score_some: ScoreWhereInput
  score_none: ScoreWhereInput
  AND: [PresenceWhereInput!]
  OR: [PresenceWhereInput!]
  NOT: [PresenceWhereInput!]
}

input PresenceWhereUniqueInput {
  id: ID
}

type Query {
  annualExamSubjectSeries(where: AnnualExamSubjectSeriesWhereUniqueInput!): AnnualExamSubjectSeries
  annualExamSubjectSerieses(where: AnnualExamSubjectSeriesWhereInput, orderBy: AnnualExamSubjectSeriesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AnnualExamSubjectSeries]!
  annualExamSubjectSeriesesConnection(where: AnnualExamSubjectSeriesWhereInput, orderBy: AnnualExamSubjectSeriesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AnnualExamSubjectSeriesConnection!
  anotherType(where: AnotherTypeWhereUniqueInput!): AnotherType
  anotherTypes(where: AnotherTypeWhereInput, orderBy: AnotherTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AnotherType]!
  anotherTypesConnection(where: AnotherTypeWhereInput, orderBy: AnotherTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AnotherTypeConnection!
  candidate(where: CandidateWhereUniqueInput!): Candidate
  candidates(where: CandidateWhereInput, orderBy: CandidateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Candidate]!
  candidatesConnection(where: CandidateWhereInput, orderBy: CandidateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CandidateConnection!
  centerAdmin(where: CenterAdminWhereUniqueInput!): CenterAdmin
  centerAdmins(where: CenterAdminWhereInput, orderBy: CenterAdminOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CenterAdmin]!
  centerAdminsConnection(where: CenterAdminWhereInput, orderBy: CenterAdminOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CenterAdminConnection!
  division(where: DivisionWhereUniqueInput!): Division
  divisions(where: DivisionWhereInput, orderBy: DivisionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Division]!
  divisionsConnection(where: DivisionWhereInput, orderBy: DivisionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DivisionConnection!
  educationType(where: EducationTypeWhereUniqueInput!): EducationType
  educationTypes(where: EducationTypeWhereInput, orderBy: EducationTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [EducationType]!
  educationTypesConnection(where: EducationTypeWhereInput, orderBy: EducationTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EducationTypeConnection!
  exam(where: ExamWhereUniqueInput!): Exam
  exams(where: ExamWhereInput, orderBy: ExamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Exam]!
  examsConnection(where: ExamWhereInput, orderBy: ExamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExamConnection!
  examCenter(where: ExamCenterWhereUniqueInput!): ExamCenter
  examCenters(where: ExamCenterWhereInput, orderBy: ExamCenterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExamCenter]!
  examCentersConnection(where: ExamCenterWhereInput, orderBy: ExamCenterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExamCenterConnection!
  gender(where: GenderWhereUniqueInput!): Gender
  genders(where: GenderWhereInput, orderBy: GenderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Gender]!
  gendersConnection(where: GenderWhereInput, orderBy: GenderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GenderConnection!
  item(where: ItemWhereUniqueInput!): Item
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item]!
  itemsConnection(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ItemConnection!
  presence(where: PresenceWhereUniqueInput!): Presence
  presences(where: PresenceWhereInput, orderBy: PresenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Presence]!
  presencesConnection(where: PresenceWhereInput, orderBy: PresenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PresenceConnection!
  rank(where: RankWhereUniqueInput!): Rank
  ranks(where: RankWhereInput, orderBy: RankOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Rank]!
  ranksConnection(where: RankWhereInput, orderBy: RankOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RankConnection!
  region(where: RegionWhereUniqueInput!): Region
  regions(where: RegionWhereInput, orderBy: RegionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Region]!
  regionsConnection(where: RegionWhereInput, orderBy: RegionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RegionConnection!
  registration(where: RegistrationWhereUniqueInput!): Registration
  registrations(where: RegistrationWhereInput, orderBy: RegistrationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Registration]!
  registrationsConnection(where: RegistrationWhereInput, orderBy: RegistrationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RegistrationConnection!
  report(where: ReportWhereUniqueInput!): Report
  reports(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Report]!
  reportsConnection(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReportConnection!
  score(where: ScoreWhereUniqueInput!): Score
  scores(where: ScoreWhereInput, orderBy: ScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Score]!
  scoresConnection(where: ScoreWhereInput, orderBy: ScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ScoreConnection!
  series(where: SeriesWhereUniqueInput!): Series
  serieses(where: SeriesWhereInput, orderBy: SeriesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Series]!
  seriesesConnection(where: SeriesWhereInput, orderBy: SeriesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SeriesConnection!
  session(where: SessionWhereUniqueInput!): Session
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session]!
  sessionsConnection(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SessionConnection!
  subDivision(where: SubDivisionWhereUniqueInput!): SubDivision
  subDivisions(where: SubDivisionWhereInput, orderBy: SubDivisionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SubDivision]!
  subDivisionsConnection(where: SubDivisionWhereInput, orderBy: SubDivisionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SubDivisionConnection!
  subject(where: SubjectWhereUniqueInput!): Subject
  subjects(where: SubjectWhereInput, orderBy: SubjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Subject]!
  subjectsConnection(where: SubjectWhereInput, orderBy: SubjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SubjectConnection!
  town(where: TownWhereUniqueInput!): Town
  towns(where: TownWhereInput, orderBy: TownOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Town]!
  townsConnection(where: TownWhereInput, orderBy: TownOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TownConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Rank {
  id: ID!
  rankName: String!
  rankCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  centerAdmin(where: CenterAdminWhereInput, orderBy: CenterAdminOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CenterAdmin!]
}

type RankConnection {
  pageInfo: PageInfo!
  edges: [RankEdge]!
  aggregate: AggregateRank!
}

input RankCreateInput {
  id: ID
  rankName: String!
  rankCode: String!
  centerAdmin: CenterAdminCreateManyWithoutRankInput
}

input RankCreateOneWithoutCenterAdminInput {
  create: RankCreateWithoutCenterAdminInput
  connect: RankWhereUniqueInput
}

input RankCreateWithoutCenterAdminInput {
  id: ID
  rankName: String!
  rankCode: String!
}

type RankEdge {
  node: Rank!
  cursor: String!
}

enum RankOrderByInput {
  id_ASC
  id_DESC
  rankName_ASC
  rankName_DESC
  rankCode_ASC
  rankCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type RankPreviousValues {
  id: ID!
  rankName: String!
  rankCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type RankSubscriptionPayload {
  mutation: MutationType!
  node: Rank
  updatedFields: [String!]
  previousValues: RankPreviousValues
}

input RankSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RankWhereInput
  AND: [RankSubscriptionWhereInput!]
  OR: [RankSubscriptionWhereInput!]
  NOT: [RankSubscriptionWhereInput!]
}

input RankUpdateInput {
  rankName: String
  rankCode: String
  centerAdmin: CenterAdminUpdateManyWithoutRankInput
}

input RankUpdateManyMutationInput {
  rankName: String
  rankCode: String
}

input RankUpdateOneRequiredWithoutCenterAdminInput {
  create: RankCreateWithoutCenterAdminInput
  update: RankUpdateWithoutCenterAdminDataInput
  upsert: RankUpsertWithoutCenterAdminInput
  connect: RankWhereUniqueInput
}

input RankUpdateWithoutCenterAdminDataInput {
  rankName: String
  rankCode: String
}

input RankUpsertWithoutCenterAdminInput {
  update: RankUpdateWithoutCenterAdminDataInput!
  create: RankCreateWithoutCenterAdminInput!
}

input RankWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  rankName: String
  rankName_not: String
  rankName_in: [String!]
  rankName_not_in: [String!]
  rankName_lt: String
  rankName_lte: String
  rankName_gt: String
  rankName_gte: String
  rankName_contains: String
  rankName_not_contains: String
  rankName_starts_with: String
  rankName_not_starts_with: String
  rankName_ends_with: String
  rankName_not_ends_with: String
  rankCode: String
  rankCode_not: String
  rankCode_in: [String!]
  rankCode_not_in: [String!]
  rankCode_lt: String
  rankCode_lte: String
  rankCode_gt: String
  rankCode_gte: String
  rankCode_contains: String
  rankCode_not_contains: String
  rankCode_starts_with: String
  rankCode_not_starts_with: String
  rankCode_ends_with: String
  rankCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  centerAdmin_every: CenterAdminWhereInput
  centerAdmin_some: CenterAdminWhereInput
  centerAdmin_none: CenterAdminWhereInput
  AND: [RankWhereInput!]
  OR: [RankWhereInput!]
  NOT: [RankWhereInput!]
}

input RankWhereUniqueInput {
  id: ID
}

type Region {
  id: ID!
  regName: String!
  regCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  division(where: DivisionWhereInput, orderBy: DivisionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Division!]
}

type RegionConnection {
  pageInfo: PageInfo!
  edges: [RegionEdge]!
  aggregate: AggregateRegion!
}

input RegionCreateInput {
  id: ID
  regName: String!
  regCode: String!
  division: DivisionCreateManyWithoutRegionInput
}

input RegionCreateOneWithoutDivisionInput {
  create: RegionCreateWithoutDivisionInput
  connect: RegionWhereUniqueInput
}

input RegionCreateWithoutDivisionInput {
  id: ID
  regName: String!
  regCode: String!
}

type RegionEdge {
  node: Region!
  cursor: String!
}

enum RegionOrderByInput {
  id_ASC
  id_DESC
  regName_ASC
  regName_DESC
  regCode_ASC
  regCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type RegionPreviousValues {
  id: ID!
  regName: String!
  regCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type RegionSubscriptionPayload {
  mutation: MutationType!
  node: Region
  updatedFields: [String!]
  previousValues: RegionPreviousValues
}

input RegionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RegionWhereInput
  AND: [RegionSubscriptionWhereInput!]
  OR: [RegionSubscriptionWhereInput!]
  NOT: [RegionSubscriptionWhereInput!]
}

input RegionUpdateInput {
  regName: String
  regCode: String
  division: DivisionUpdateManyWithoutRegionInput
}

input RegionUpdateManyMutationInput {
  regName: String
  regCode: String
}

input RegionUpdateOneRequiredWithoutDivisionInput {
  create: RegionCreateWithoutDivisionInput
  update: RegionUpdateWithoutDivisionDataInput
  upsert: RegionUpsertWithoutDivisionInput
  connect: RegionWhereUniqueInput
}

input RegionUpdateWithoutDivisionDataInput {
  regName: String
  regCode: String
}

input RegionUpsertWithoutDivisionInput {
  update: RegionUpdateWithoutDivisionDataInput!
  create: RegionCreateWithoutDivisionInput!
}

input RegionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  regName: String
  regName_not: String
  regName_in: [String!]
  regName_not_in: [String!]
  regName_lt: String
  regName_lte: String
  regName_gt: String
  regName_gte: String
  regName_contains: String
  regName_not_contains: String
  regName_starts_with: String
  regName_not_starts_with: String
  regName_ends_with: String
  regName_not_ends_with: String
  regCode: String
  regCode_not: String
  regCode_in: [String!]
  regCode_not_in: [String!]
  regCode_lt: String
  regCode_lte: String
  regCode_gt: String
  regCode_gte: String
  regCode_contains: String
  regCode_not_contains: String
  regCode_starts_with: String
  regCode_not_starts_with: String
  regCode_ends_with: String
  regCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  division_every: DivisionWhereInput
  division_some: DivisionWhereInput
  division_none: DivisionWhereInput
  AND: [RegionWhereInput!]
  OR: [RegionWhereInput!]
  NOT: [RegionWhereInput!]
}

input RegionWhereUniqueInput {
  id: ID
}

type Registration {
  id: ID!
  candidate: Candidate!
  createdAt: DateTime!
  updatedAt: DateTime!
  exam: Exam!
  series: Series!
  session: Session!
  center: ExamCenter!
}

type RegistrationConnection {
  pageInfo: PageInfo!
  edges: [RegistrationEdge]!
  aggregate: AggregateRegistration!
}

input RegistrationCreateInput {
  id: ID
  candidate: CandidateCreateOneWithoutRegistrationInput!
  exam: ExamCreateOneWithoutRegistrationInput!
  series: SeriesCreateOneWithoutRegistrationInput!
  session: SessionCreateOneWithoutRegistrationInput!
  center: ExamCenterCreateOneWithoutRegistrationInput!
}

input RegistrationCreateManyWithoutCandidateInput {
  create: [RegistrationCreateWithoutCandidateInput!]
  connect: [RegistrationWhereUniqueInput!]
}

input RegistrationCreateManyWithoutCenterInput {
  create: [RegistrationCreateWithoutCenterInput!]
  connect: [RegistrationWhereUniqueInput!]
}

input RegistrationCreateManyWithoutExamInput {
  create: [RegistrationCreateWithoutExamInput!]
  connect: [RegistrationWhereUniqueInput!]
}

input RegistrationCreateManyWithoutSeriesInput {
  create: [RegistrationCreateWithoutSeriesInput!]
  connect: [RegistrationWhereUniqueInput!]
}

input RegistrationCreateManyWithoutSessionInput {
  create: [RegistrationCreateWithoutSessionInput!]
  connect: [RegistrationWhereUniqueInput!]
}

input RegistrationCreateOneInput {
  create: RegistrationCreateInput
  connect: RegistrationWhereUniqueInput
}

input RegistrationCreateWithoutCandidateInput {
  id: ID
  exam: ExamCreateOneWithoutRegistrationInput!
  series: SeriesCreateOneWithoutRegistrationInput!
  session: SessionCreateOneWithoutRegistrationInput!
  center: ExamCenterCreateOneWithoutRegistrationInput!
}

input RegistrationCreateWithoutCenterInput {
  id: ID
  candidate: CandidateCreateOneWithoutRegistrationInput!
  exam: ExamCreateOneWithoutRegistrationInput!
  series: SeriesCreateOneWithoutRegistrationInput!
  session: SessionCreateOneWithoutRegistrationInput!
}

input RegistrationCreateWithoutExamInput {
  id: ID
  candidate: CandidateCreateOneWithoutRegistrationInput!
  series: SeriesCreateOneWithoutRegistrationInput!
  session: SessionCreateOneWithoutRegistrationInput!
  center: ExamCenterCreateOneWithoutRegistrationInput!
}

input RegistrationCreateWithoutSeriesInput {
  id: ID
  candidate: CandidateCreateOneWithoutRegistrationInput!
  exam: ExamCreateOneWithoutRegistrationInput!
  session: SessionCreateOneWithoutRegistrationInput!
  center: ExamCenterCreateOneWithoutRegistrationInput!
}

input RegistrationCreateWithoutSessionInput {
  id: ID
  candidate: CandidateCreateOneWithoutRegistrationInput!
  exam: ExamCreateOneWithoutRegistrationInput!
  series: SeriesCreateOneWithoutRegistrationInput!
  center: ExamCenterCreateOneWithoutRegistrationInput!
}

type RegistrationEdge {
  node: Registration!
  cursor: String!
}

enum RegistrationOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type RegistrationPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input RegistrationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [RegistrationScalarWhereInput!]
  OR: [RegistrationScalarWhereInput!]
  NOT: [RegistrationScalarWhereInput!]
}

type RegistrationSubscriptionPayload {
  mutation: MutationType!
  node: Registration
  updatedFields: [String!]
  previousValues: RegistrationPreviousValues
}

input RegistrationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RegistrationWhereInput
  AND: [RegistrationSubscriptionWhereInput!]
  OR: [RegistrationSubscriptionWhereInput!]
  NOT: [RegistrationSubscriptionWhereInput!]
}

input RegistrationUpdateDataInput {
  candidate: CandidateUpdateOneRequiredWithoutRegistrationInput
  exam: ExamUpdateOneRequiredWithoutRegistrationInput
  series: SeriesUpdateOneRequiredWithoutRegistrationInput
  session: SessionUpdateOneRequiredWithoutRegistrationInput
  center: ExamCenterUpdateOneRequiredWithoutRegistrationInput
}

input RegistrationUpdateInput {
  candidate: CandidateUpdateOneRequiredWithoutRegistrationInput
  exam: ExamUpdateOneRequiredWithoutRegistrationInput
  series: SeriesUpdateOneRequiredWithoutRegistrationInput
  session: SessionUpdateOneRequiredWithoutRegistrationInput
  center: ExamCenterUpdateOneRequiredWithoutRegistrationInput
}

input RegistrationUpdateManyWithoutCandidateInput {
  create: [RegistrationCreateWithoutCandidateInput!]
  delete: [RegistrationWhereUniqueInput!]
  connect: [RegistrationWhereUniqueInput!]
  set: [RegistrationWhereUniqueInput!]
  disconnect: [RegistrationWhereUniqueInput!]
  update: [RegistrationUpdateWithWhereUniqueWithoutCandidateInput!]
  upsert: [RegistrationUpsertWithWhereUniqueWithoutCandidateInput!]
  deleteMany: [RegistrationScalarWhereInput!]
}

input RegistrationUpdateManyWithoutCenterInput {
  create: [RegistrationCreateWithoutCenterInput!]
  delete: [RegistrationWhereUniqueInput!]
  connect: [RegistrationWhereUniqueInput!]
  set: [RegistrationWhereUniqueInput!]
  disconnect: [RegistrationWhereUniqueInput!]
  update: [RegistrationUpdateWithWhereUniqueWithoutCenterInput!]
  upsert: [RegistrationUpsertWithWhereUniqueWithoutCenterInput!]
  deleteMany: [RegistrationScalarWhereInput!]
}

input RegistrationUpdateManyWithoutExamInput {
  create: [RegistrationCreateWithoutExamInput!]
  delete: [RegistrationWhereUniqueInput!]
  connect: [RegistrationWhereUniqueInput!]
  set: [RegistrationWhereUniqueInput!]
  disconnect: [RegistrationWhereUniqueInput!]
  update: [RegistrationUpdateWithWhereUniqueWithoutExamInput!]
  upsert: [RegistrationUpsertWithWhereUniqueWithoutExamInput!]
  deleteMany: [RegistrationScalarWhereInput!]
}

input RegistrationUpdateManyWithoutSeriesInput {
  create: [RegistrationCreateWithoutSeriesInput!]
  delete: [RegistrationWhereUniqueInput!]
  connect: [RegistrationWhereUniqueInput!]
  set: [RegistrationWhereUniqueInput!]
  disconnect: [RegistrationWhereUniqueInput!]
  update: [RegistrationUpdateWithWhereUniqueWithoutSeriesInput!]
  upsert: [RegistrationUpsertWithWhereUniqueWithoutSeriesInput!]
  deleteMany: [RegistrationScalarWhereInput!]
}

input RegistrationUpdateManyWithoutSessionInput {
  create: [RegistrationCreateWithoutSessionInput!]
  delete: [RegistrationWhereUniqueInput!]
  connect: [RegistrationWhereUniqueInput!]
  set: [RegistrationWhereUniqueInput!]
  disconnect: [RegistrationWhereUniqueInput!]
  update: [RegistrationUpdateWithWhereUniqueWithoutSessionInput!]
  upsert: [RegistrationUpsertWithWhereUniqueWithoutSessionInput!]
  deleteMany: [RegistrationScalarWhereInput!]
}

input RegistrationUpdateOneRequiredInput {
  create: RegistrationCreateInput
  update: RegistrationUpdateDataInput
  upsert: RegistrationUpsertNestedInput
  connect: RegistrationWhereUniqueInput
}

input RegistrationUpdateWithoutCandidateDataInput {
  exam: ExamUpdateOneRequiredWithoutRegistrationInput
  series: SeriesUpdateOneRequiredWithoutRegistrationInput
  session: SessionUpdateOneRequiredWithoutRegistrationInput
  center: ExamCenterUpdateOneRequiredWithoutRegistrationInput
}

input RegistrationUpdateWithoutCenterDataInput {
  candidate: CandidateUpdateOneRequiredWithoutRegistrationInput
  exam: ExamUpdateOneRequiredWithoutRegistrationInput
  series: SeriesUpdateOneRequiredWithoutRegistrationInput
  session: SessionUpdateOneRequiredWithoutRegistrationInput
}

input RegistrationUpdateWithoutExamDataInput {
  candidate: CandidateUpdateOneRequiredWithoutRegistrationInput
  series: SeriesUpdateOneRequiredWithoutRegistrationInput
  session: SessionUpdateOneRequiredWithoutRegistrationInput
  center: ExamCenterUpdateOneRequiredWithoutRegistrationInput
}

input RegistrationUpdateWithoutSeriesDataInput {
  candidate: CandidateUpdateOneRequiredWithoutRegistrationInput
  exam: ExamUpdateOneRequiredWithoutRegistrationInput
  session: SessionUpdateOneRequiredWithoutRegistrationInput
  center: ExamCenterUpdateOneRequiredWithoutRegistrationInput
}

input RegistrationUpdateWithoutSessionDataInput {
  candidate: CandidateUpdateOneRequiredWithoutRegistrationInput
  exam: ExamUpdateOneRequiredWithoutRegistrationInput
  series: SeriesUpdateOneRequiredWithoutRegistrationInput
  center: ExamCenterUpdateOneRequiredWithoutRegistrationInput
}

input RegistrationUpdateWithWhereUniqueWithoutCandidateInput {
  where: RegistrationWhereUniqueInput!
  data: RegistrationUpdateWithoutCandidateDataInput!
}

input RegistrationUpdateWithWhereUniqueWithoutCenterInput {
  where: RegistrationWhereUniqueInput!
  data: RegistrationUpdateWithoutCenterDataInput!
}

input RegistrationUpdateWithWhereUniqueWithoutExamInput {
  where: RegistrationWhereUniqueInput!
  data: RegistrationUpdateWithoutExamDataInput!
}

input RegistrationUpdateWithWhereUniqueWithoutSeriesInput {
  where: RegistrationWhereUniqueInput!
  data: RegistrationUpdateWithoutSeriesDataInput!
}

input RegistrationUpdateWithWhereUniqueWithoutSessionInput {
  where: RegistrationWhereUniqueInput!
  data: RegistrationUpdateWithoutSessionDataInput!
}

input RegistrationUpsertNestedInput {
  update: RegistrationUpdateDataInput!
  create: RegistrationCreateInput!
}

input RegistrationUpsertWithWhereUniqueWithoutCandidateInput {
  where: RegistrationWhereUniqueInput!
  update: RegistrationUpdateWithoutCandidateDataInput!
  create: RegistrationCreateWithoutCandidateInput!
}

input RegistrationUpsertWithWhereUniqueWithoutCenterInput {
  where: RegistrationWhereUniqueInput!
  update: RegistrationUpdateWithoutCenterDataInput!
  create: RegistrationCreateWithoutCenterInput!
}

input RegistrationUpsertWithWhereUniqueWithoutExamInput {
  where: RegistrationWhereUniqueInput!
  update: RegistrationUpdateWithoutExamDataInput!
  create: RegistrationCreateWithoutExamInput!
}

input RegistrationUpsertWithWhereUniqueWithoutSeriesInput {
  where: RegistrationWhereUniqueInput!
  update: RegistrationUpdateWithoutSeriesDataInput!
  create: RegistrationCreateWithoutSeriesInput!
}

input RegistrationUpsertWithWhereUniqueWithoutSessionInput {
  where: RegistrationWhereUniqueInput!
  update: RegistrationUpdateWithoutSessionDataInput!
  create: RegistrationCreateWithoutSessionInput!
}

input RegistrationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  candidate: CandidateWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  exam: ExamWhereInput
  series: SeriesWhereInput
  session: SessionWhereInput
  center: ExamCenterWhereInput
  AND: [RegistrationWhereInput!]
  OR: [RegistrationWhereInput!]
  NOT: [RegistrationWhereInput!]
}

input RegistrationWhereUniqueInput {
  id: ID
}

type Report {
  id: ID!
  reportName: String!
  reportCode: String!
  centerAdmin: CenterAdmin!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReportConnection {
  pageInfo: PageInfo!
  edges: [ReportEdge]!
  aggregate: AggregateReport!
}

input ReportCreateInput {
  id: ID
  reportName: String!
  reportCode: String!
  centerAdmin: CenterAdminCreateOneWithoutReportInput!
}

input ReportCreateManyWithoutCenterAdminInput {
  create: [ReportCreateWithoutCenterAdminInput!]
  connect: [ReportWhereUniqueInput!]
}

input ReportCreateWithoutCenterAdminInput {
  id: ID
  reportName: String!
  reportCode: String!
}

type ReportEdge {
  node: Report!
  cursor: String!
}

enum ReportOrderByInput {
  id_ASC
  id_DESC
  reportName_ASC
  reportName_DESC
  reportCode_ASC
  reportCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ReportPreviousValues {
  id: ID!
  reportName: String!
  reportCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ReportScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  reportName: String
  reportName_not: String
  reportName_in: [String!]
  reportName_not_in: [String!]
  reportName_lt: String
  reportName_lte: String
  reportName_gt: String
  reportName_gte: String
  reportName_contains: String
  reportName_not_contains: String
  reportName_starts_with: String
  reportName_not_starts_with: String
  reportName_ends_with: String
  reportName_not_ends_with: String
  reportCode: String
  reportCode_not: String
  reportCode_in: [String!]
  reportCode_not_in: [String!]
  reportCode_lt: String
  reportCode_lte: String
  reportCode_gt: String
  reportCode_gte: String
  reportCode_contains: String
  reportCode_not_contains: String
  reportCode_starts_with: String
  reportCode_not_starts_with: String
  reportCode_ends_with: String
  reportCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ReportScalarWhereInput!]
  OR: [ReportScalarWhereInput!]
  NOT: [ReportScalarWhereInput!]
}

type ReportSubscriptionPayload {
  mutation: MutationType!
  node: Report
  updatedFields: [String!]
  previousValues: ReportPreviousValues
}

input ReportSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReportWhereInput
  AND: [ReportSubscriptionWhereInput!]
  OR: [ReportSubscriptionWhereInput!]
  NOT: [ReportSubscriptionWhereInput!]
}

input ReportUpdateInput {
  reportName: String
  reportCode: String
  centerAdmin: CenterAdminUpdateOneRequiredWithoutReportInput
}

input ReportUpdateManyDataInput {
  reportName: String
  reportCode: String
}

input ReportUpdateManyMutationInput {
  reportName: String
  reportCode: String
}

input ReportUpdateManyWithoutCenterAdminInput {
  create: [ReportCreateWithoutCenterAdminInput!]
  delete: [ReportWhereUniqueInput!]
  connect: [ReportWhereUniqueInput!]
  set: [ReportWhereUniqueInput!]
  disconnect: [ReportWhereUniqueInput!]
  update: [ReportUpdateWithWhereUniqueWithoutCenterAdminInput!]
  upsert: [ReportUpsertWithWhereUniqueWithoutCenterAdminInput!]
  deleteMany: [ReportScalarWhereInput!]
  updateMany: [ReportUpdateManyWithWhereNestedInput!]
}

input ReportUpdateManyWithWhereNestedInput {
  where: ReportScalarWhereInput!
  data: ReportUpdateManyDataInput!
}

input ReportUpdateWithoutCenterAdminDataInput {
  reportName: String
  reportCode: String
}

input ReportUpdateWithWhereUniqueWithoutCenterAdminInput {
  where: ReportWhereUniqueInput!
  data: ReportUpdateWithoutCenterAdminDataInput!
}

input ReportUpsertWithWhereUniqueWithoutCenterAdminInput {
  where: ReportWhereUniqueInput!
  update: ReportUpdateWithoutCenterAdminDataInput!
  create: ReportCreateWithoutCenterAdminInput!
}

input ReportWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  reportName: String
  reportName_not: String
  reportName_in: [String!]
  reportName_not_in: [String!]
  reportName_lt: String
  reportName_lte: String
  reportName_gt: String
  reportName_gte: String
  reportName_contains: String
  reportName_not_contains: String
  reportName_starts_with: String
  reportName_not_starts_with: String
  reportName_ends_with: String
  reportName_not_ends_with: String
  reportCode: String
  reportCode_not: String
  reportCode_in: [String!]
  reportCode_not_in: [String!]
  reportCode_lt: String
  reportCode_lte: String
  reportCode_gt: String
  reportCode_gte: String
  reportCode_contains: String
  reportCode_not_contains: String
  reportCode_starts_with: String
  reportCode_not_starts_with: String
  reportCode_ends_with: String
  reportCode_not_ends_with: String
  centerAdmin: CenterAdminWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ReportWhereInput!]
  OR: [ReportWhereInput!]
  NOT: [ReportWhereInput!]
}

input ReportWhereUniqueInput {
  id: ID
}

type Score {
  id: ID!
  subjectAve: Float
  subjectTotal: Float
  registration: Registration!
  createdAt: DateTime!
  updatedAt: DateTime!
  presence: Presence!
  annExamSeriesSubj: AnnualExamSubjectSeries!
}

type ScoreConnection {
  pageInfo: PageInfo!
  edges: [ScoreEdge]!
  aggregate: AggregateScore!
}

input ScoreCreateInput {
  id: ID
  subjectAve: Float
  subjectTotal: Float
  registration: RegistrationCreateOneInput!
  presence: PresenceCreateOneWithoutScoreInput!
  annExamSeriesSubj: AnnualExamSubjectSeriesCreateOneWithoutScoreInput!
}

input ScoreCreateManyWithoutAnnExamSeriesSubjInput {
  create: [ScoreCreateWithoutAnnExamSeriesSubjInput!]
  connect: [ScoreWhereUniqueInput!]
}

input ScoreCreateManyWithoutPresenceInput {
  create: [ScoreCreateWithoutPresenceInput!]
  connect: [ScoreWhereUniqueInput!]
}

input ScoreCreateWithoutAnnExamSeriesSubjInput {
  id: ID
  subjectAve: Float
  subjectTotal: Float
  registration: RegistrationCreateOneInput!
  presence: PresenceCreateOneWithoutScoreInput!
}

input ScoreCreateWithoutPresenceInput {
  id: ID
  subjectAve: Float
  subjectTotal: Float
  registration: RegistrationCreateOneInput!
  annExamSeriesSubj: AnnualExamSubjectSeriesCreateOneWithoutScoreInput!
}

type ScoreEdge {
  node: Score!
  cursor: String!
}

enum ScoreOrderByInput {
  id_ASC
  id_DESC
  subjectAve_ASC
  subjectAve_DESC
  subjectTotal_ASC
  subjectTotal_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ScorePreviousValues {
  id: ID!
  subjectAve: Float
  subjectTotal: Float
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ScoreScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  subjectAve: Float
  subjectAve_not: Float
  subjectAve_in: [Float!]
  subjectAve_not_in: [Float!]
  subjectAve_lt: Float
  subjectAve_lte: Float
  subjectAve_gt: Float
  subjectAve_gte: Float
  subjectTotal: Float
  subjectTotal_not: Float
  subjectTotal_in: [Float!]
  subjectTotal_not_in: [Float!]
  subjectTotal_lt: Float
  subjectTotal_lte: Float
  subjectTotal_gt: Float
  subjectTotal_gte: Float
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ScoreScalarWhereInput!]
  OR: [ScoreScalarWhereInput!]
  NOT: [ScoreScalarWhereInput!]
}

type ScoreSubscriptionPayload {
  mutation: MutationType!
  node: Score
  updatedFields: [String!]
  previousValues: ScorePreviousValues
}

input ScoreSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ScoreWhereInput
  AND: [ScoreSubscriptionWhereInput!]
  OR: [ScoreSubscriptionWhereInput!]
  NOT: [ScoreSubscriptionWhereInput!]
}

input ScoreUpdateInput {
  subjectAve: Float
  subjectTotal: Float
  registration: RegistrationUpdateOneRequiredInput
  presence: PresenceUpdateOneRequiredWithoutScoreInput
  annExamSeriesSubj: AnnualExamSubjectSeriesUpdateOneRequiredWithoutScoreInput
}

input ScoreUpdateManyDataInput {
  subjectAve: Float
  subjectTotal: Float
}

input ScoreUpdateManyMutationInput {
  subjectAve: Float
  subjectTotal: Float
}

input ScoreUpdateManyWithoutAnnExamSeriesSubjInput {
  create: [ScoreCreateWithoutAnnExamSeriesSubjInput!]
  delete: [ScoreWhereUniqueInput!]
  connect: [ScoreWhereUniqueInput!]
  set: [ScoreWhereUniqueInput!]
  disconnect: [ScoreWhereUniqueInput!]
  update: [ScoreUpdateWithWhereUniqueWithoutAnnExamSeriesSubjInput!]
  upsert: [ScoreUpsertWithWhereUniqueWithoutAnnExamSeriesSubjInput!]
  deleteMany: [ScoreScalarWhereInput!]
  updateMany: [ScoreUpdateManyWithWhereNestedInput!]
}

input ScoreUpdateManyWithoutPresenceInput {
  create: [ScoreCreateWithoutPresenceInput!]
  delete: [ScoreWhereUniqueInput!]
  connect: [ScoreWhereUniqueInput!]
  set: [ScoreWhereUniqueInput!]
  disconnect: [ScoreWhereUniqueInput!]
  update: [ScoreUpdateWithWhereUniqueWithoutPresenceInput!]
  upsert: [ScoreUpsertWithWhereUniqueWithoutPresenceInput!]
  deleteMany: [ScoreScalarWhereInput!]
  updateMany: [ScoreUpdateManyWithWhereNestedInput!]
}

input ScoreUpdateManyWithWhereNestedInput {
  where: ScoreScalarWhereInput!
  data: ScoreUpdateManyDataInput!
}

input ScoreUpdateWithoutAnnExamSeriesSubjDataInput {
  subjectAve: Float
  subjectTotal: Float
  registration: RegistrationUpdateOneRequiredInput
  presence: PresenceUpdateOneRequiredWithoutScoreInput
}

input ScoreUpdateWithoutPresenceDataInput {
  subjectAve: Float
  subjectTotal: Float
  registration: RegistrationUpdateOneRequiredInput
  annExamSeriesSubj: AnnualExamSubjectSeriesUpdateOneRequiredWithoutScoreInput
}

input ScoreUpdateWithWhereUniqueWithoutAnnExamSeriesSubjInput {
  where: ScoreWhereUniqueInput!
  data: ScoreUpdateWithoutAnnExamSeriesSubjDataInput!
}

input ScoreUpdateWithWhereUniqueWithoutPresenceInput {
  where: ScoreWhereUniqueInput!
  data: ScoreUpdateWithoutPresenceDataInput!
}

input ScoreUpsertWithWhereUniqueWithoutAnnExamSeriesSubjInput {
  where: ScoreWhereUniqueInput!
  update: ScoreUpdateWithoutAnnExamSeriesSubjDataInput!
  create: ScoreCreateWithoutAnnExamSeriesSubjInput!
}

input ScoreUpsertWithWhereUniqueWithoutPresenceInput {
  where: ScoreWhereUniqueInput!
  update: ScoreUpdateWithoutPresenceDataInput!
  create: ScoreCreateWithoutPresenceInput!
}

input ScoreWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  subjectAve: Float
  subjectAve_not: Float
  subjectAve_in: [Float!]
  subjectAve_not_in: [Float!]
  subjectAve_lt: Float
  subjectAve_lte: Float
  subjectAve_gt: Float
  subjectAve_gte: Float
  subjectTotal: Float
  subjectTotal_not: Float
  subjectTotal_in: [Float!]
  subjectTotal_not_in: [Float!]
  subjectTotal_lt: Float
  subjectTotal_lte: Float
  subjectTotal_gt: Float
  subjectTotal_gte: Float
  registration: RegistrationWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  presence: PresenceWhereInput
  annExamSeriesSubj: AnnualExamSubjectSeriesWhereInput
  AND: [ScoreWhereInput!]
  OR: [ScoreWhereInput!]
  NOT: [ScoreWhereInput!]
}

input ScoreWhereUniqueInput {
  id: ID
}

type Series {
  id: ID!
  seriesName: String!
  seriesCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  educationType: EducationType!
  registration(where: RegistrationWhereInput, orderBy: RegistrationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Registration!]
}

type SeriesConnection {
  pageInfo: PageInfo!
  edges: [SeriesEdge]!
  aggregate: AggregateSeries!
}

input SeriesCreateInput {
  id: ID
  seriesName: String!
  seriesCode: String!
  educationType: EducationTypeCreateOneWithoutSeriesInput!
  registration: RegistrationCreateManyWithoutSeriesInput
}

input SeriesCreateManyWithoutEducationTypeInput {
  create: [SeriesCreateWithoutEducationTypeInput!]
  connect: [SeriesWhereUniqueInput!]
}

input SeriesCreateOneWithoutRegistrationInput {
  create: SeriesCreateWithoutRegistrationInput
  connect: SeriesWhereUniqueInput
}

input SeriesCreateWithoutEducationTypeInput {
  id: ID
  seriesName: String!
  seriesCode: String!
  registration: RegistrationCreateManyWithoutSeriesInput
}

input SeriesCreateWithoutRegistrationInput {
  id: ID
  seriesName: String!
  seriesCode: String!
  educationType: EducationTypeCreateOneWithoutSeriesInput!
}

type SeriesEdge {
  node: Series!
  cursor: String!
}

enum SeriesOrderByInput {
  id_ASC
  id_DESC
  seriesName_ASC
  seriesName_DESC
  seriesCode_ASC
  seriesCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SeriesPreviousValues {
  id: ID!
  seriesName: String!
  seriesCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input SeriesScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  seriesName: String
  seriesName_not: String
  seriesName_in: [String!]
  seriesName_not_in: [String!]
  seriesName_lt: String
  seriesName_lte: String
  seriesName_gt: String
  seriesName_gte: String
  seriesName_contains: String
  seriesName_not_contains: String
  seriesName_starts_with: String
  seriesName_not_starts_with: String
  seriesName_ends_with: String
  seriesName_not_ends_with: String
  seriesCode: String
  seriesCode_not: String
  seriesCode_in: [String!]
  seriesCode_not_in: [String!]
  seriesCode_lt: String
  seriesCode_lte: String
  seriesCode_gt: String
  seriesCode_gte: String
  seriesCode_contains: String
  seriesCode_not_contains: String
  seriesCode_starts_with: String
  seriesCode_not_starts_with: String
  seriesCode_ends_with: String
  seriesCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SeriesScalarWhereInput!]
  OR: [SeriesScalarWhereInput!]
  NOT: [SeriesScalarWhereInput!]
}

type SeriesSubscriptionPayload {
  mutation: MutationType!
  node: Series
  updatedFields: [String!]
  previousValues: SeriesPreviousValues
}

input SeriesSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SeriesWhereInput
  AND: [SeriesSubscriptionWhereInput!]
  OR: [SeriesSubscriptionWhereInput!]
  NOT: [SeriesSubscriptionWhereInput!]
}

input SeriesUpdateInput {
  seriesName: String
  seriesCode: String
  educationType: EducationTypeUpdateOneRequiredWithoutSeriesInput
  registration: RegistrationUpdateManyWithoutSeriesInput
}

input SeriesUpdateManyDataInput {
  seriesName: String
  seriesCode: String
}

input SeriesUpdateManyMutationInput {
  seriesName: String
  seriesCode: String
}

input SeriesUpdateManyWithoutEducationTypeInput {
  create: [SeriesCreateWithoutEducationTypeInput!]
  delete: [SeriesWhereUniqueInput!]
  connect: [SeriesWhereUniqueInput!]
  set: [SeriesWhereUniqueInput!]
  disconnect: [SeriesWhereUniqueInput!]
  update: [SeriesUpdateWithWhereUniqueWithoutEducationTypeInput!]
  upsert: [SeriesUpsertWithWhereUniqueWithoutEducationTypeInput!]
  deleteMany: [SeriesScalarWhereInput!]
  updateMany: [SeriesUpdateManyWithWhereNestedInput!]
}

input SeriesUpdateManyWithWhereNestedInput {
  where: SeriesScalarWhereInput!
  data: SeriesUpdateManyDataInput!
}

input SeriesUpdateOneRequiredWithoutRegistrationInput {
  create: SeriesCreateWithoutRegistrationInput
  update: SeriesUpdateWithoutRegistrationDataInput
  upsert: SeriesUpsertWithoutRegistrationInput
  connect: SeriesWhereUniqueInput
}

input SeriesUpdateWithoutEducationTypeDataInput {
  seriesName: String
  seriesCode: String
  registration: RegistrationUpdateManyWithoutSeriesInput
}

input SeriesUpdateWithoutRegistrationDataInput {
  seriesName: String
  seriesCode: String
  educationType: EducationTypeUpdateOneRequiredWithoutSeriesInput
}

input SeriesUpdateWithWhereUniqueWithoutEducationTypeInput {
  where: SeriesWhereUniqueInput!
  data: SeriesUpdateWithoutEducationTypeDataInput!
}

input SeriesUpsertWithoutRegistrationInput {
  update: SeriesUpdateWithoutRegistrationDataInput!
  create: SeriesCreateWithoutRegistrationInput!
}

input SeriesUpsertWithWhereUniqueWithoutEducationTypeInput {
  where: SeriesWhereUniqueInput!
  update: SeriesUpdateWithoutEducationTypeDataInput!
  create: SeriesCreateWithoutEducationTypeInput!
}

input SeriesWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  seriesName: String
  seriesName_not: String
  seriesName_in: [String!]
  seriesName_not_in: [String!]
  seriesName_lt: String
  seriesName_lte: String
  seriesName_gt: String
  seriesName_gte: String
  seriesName_contains: String
  seriesName_not_contains: String
  seriesName_starts_with: String
  seriesName_not_starts_with: String
  seriesName_ends_with: String
  seriesName_not_ends_with: String
  seriesCode: String
  seriesCode_not: String
  seriesCode_in: [String!]
  seriesCode_not_in: [String!]
  seriesCode_lt: String
  seriesCode_lte: String
  seriesCode_gt: String
  seriesCode_gte: String
  seriesCode_contains: String
  seriesCode_not_contains: String
  seriesCode_starts_with: String
  seriesCode_not_starts_with: String
  seriesCode_ends_with: String
  seriesCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  educationType: EducationTypeWhereInput
  registration_every: RegistrationWhereInput
  registration_some: RegistrationWhereInput
  registration_none: RegistrationWhereInput
  AND: [SeriesWhereInput!]
  OR: [SeriesWhereInput!]
  NOT: [SeriesWhereInput!]
}

input SeriesWhereUniqueInput {
  id: ID
}

type Session {
  id: ID!
  sessionName: String!
  sessionCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  centerAdmin(where: CenterAdminWhereInput, orderBy: CenterAdminOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CenterAdmin!]
  annExamSeriesSubj(where: AnnualExamSubjectSeriesWhereInput, orderBy: AnnualExamSubjectSeriesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AnnualExamSubjectSeries!]
  registration(where: RegistrationWhereInput, orderBy: RegistrationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Registration!]
}

type SessionConnection {
  pageInfo: PageInfo!
  edges: [SessionEdge]!
  aggregate: AggregateSession!
}

input SessionCreateInput {
  id: ID
  sessionName: String!
  sessionCode: String!
  centerAdmin: CenterAdminCreateManyWithoutSessionInput
  annExamSeriesSubj: AnnualExamSubjectSeriesCreateManyWithoutSessionInput
  registration: RegistrationCreateManyWithoutSessionInput
}

input SessionCreateOneWithoutAnnExamSeriesSubjInput {
  create: SessionCreateWithoutAnnExamSeriesSubjInput
  connect: SessionWhereUniqueInput
}

input SessionCreateOneWithoutCenterAdminInput {
  create: SessionCreateWithoutCenterAdminInput
  connect: SessionWhereUniqueInput
}

input SessionCreateOneWithoutRegistrationInput {
  create: SessionCreateWithoutRegistrationInput
  connect: SessionWhereUniqueInput
}

input SessionCreateWithoutAnnExamSeriesSubjInput {
  id: ID
  sessionName: String!
  sessionCode: String!
  centerAdmin: CenterAdminCreateManyWithoutSessionInput
  registration: RegistrationCreateManyWithoutSessionInput
}

input SessionCreateWithoutCenterAdminInput {
  id: ID
  sessionName: String!
  sessionCode: String!
  annExamSeriesSubj: AnnualExamSubjectSeriesCreateManyWithoutSessionInput
  registration: RegistrationCreateManyWithoutSessionInput
}

input SessionCreateWithoutRegistrationInput {
  id: ID
  sessionName: String!
  sessionCode: String!
  centerAdmin: CenterAdminCreateManyWithoutSessionInput
  annExamSeriesSubj: AnnualExamSubjectSeriesCreateManyWithoutSessionInput
}

type SessionEdge {
  node: Session!
  cursor: String!
}

enum SessionOrderByInput {
  id_ASC
  id_DESC
  sessionName_ASC
  sessionName_DESC
  sessionCode_ASC
  sessionCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SessionPreviousValues {
  id: ID!
  sessionName: String!
  sessionCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SessionSubscriptionPayload {
  mutation: MutationType!
  node: Session
  updatedFields: [String!]
  previousValues: SessionPreviousValues
}

input SessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SessionWhereInput
  AND: [SessionSubscriptionWhereInput!]
  OR: [SessionSubscriptionWhereInput!]
  NOT: [SessionSubscriptionWhereInput!]
}

input SessionUpdateInput {
  sessionName: String
  sessionCode: String
  centerAdmin: CenterAdminUpdateManyWithoutSessionInput
  annExamSeriesSubj: AnnualExamSubjectSeriesUpdateManyWithoutSessionInput
  registration: RegistrationUpdateManyWithoutSessionInput
}

input SessionUpdateManyMutationInput {
  sessionName: String
  sessionCode: String
}

input SessionUpdateOneRequiredWithoutAnnExamSeriesSubjInput {
  create: SessionCreateWithoutAnnExamSeriesSubjInput
  update: SessionUpdateWithoutAnnExamSeriesSubjDataInput
  upsert: SessionUpsertWithoutAnnExamSeriesSubjInput
  connect: SessionWhereUniqueInput
}

input SessionUpdateOneRequiredWithoutCenterAdminInput {
  create: SessionCreateWithoutCenterAdminInput
  update: SessionUpdateWithoutCenterAdminDataInput
  upsert: SessionUpsertWithoutCenterAdminInput
  connect: SessionWhereUniqueInput
}

input SessionUpdateOneRequiredWithoutRegistrationInput {
  create: SessionCreateWithoutRegistrationInput
  update: SessionUpdateWithoutRegistrationDataInput
  upsert: SessionUpsertWithoutRegistrationInput
  connect: SessionWhereUniqueInput
}

input SessionUpdateWithoutAnnExamSeriesSubjDataInput {
  sessionName: String
  sessionCode: String
  centerAdmin: CenterAdminUpdateManyWithoutSessionInput
  registration: RegistrationUpdateManyWithoutSessionInput
}

input SessionUpdateWithoutCenterAdminDataInput {
  sessionName: String
  sessionCode: String
  annExamSeriesSubj: AnnualExamSubjectSeriesUpdateManyWithoutSessionInput
  registration: RegistrationUpdateManyWithoutSessionInput
}

input SessionUpdateWithoutRegistrationDataInput {
  sessionName: String
  sessionCode: String
  centerAdmin: CenterAdminUpdateManyWithoutSessionInput
  annExamSeriesSubj: AnnualExamSubjectSeriesUpdateManyWithoutSessionInput
}

input SessionUpsertWithoutAnnExamSeriesSubjInput {
  update: SessionUpdateWithoutAnnExamSeriesSubjDataInput!
  create: SessionCreateWithoutAnnExamSeriesSubjInput!
}

input SessionUpsertWithoutCenterAdminInput {
  update: SessionUpdateWithoutCenterAdminDataInput!
  create: SessionCreateWithoutCenterAdminInput!
}

input SessionUpsertWithoutRegistrationInput {
  update: SessionUpdateWithoutRegistrationDataInput!
  create: SessionCreateWithoutRegistrationInput!
}

input SessionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  sessionName: String
  sessionName_not: String
  sessionName_in: [String!]
  sessionName_not_in: [String!]
  sessionName_lt: String
  sessionName_lte: String
  sessionName_gt: String
  sessionName_gte: String
  sessionName_contains: String
  sessionName_not_contains: String
  sessionName_starts_with: String
  sessionName_not_starts_with: String
  sessionName_ends_with: String
  sessionName_not_ends_with: String
  sessionCode: String
  sessionCode_not: String
  sessionCode_in: [String!]
  sessionCode_not_in: [String!]
  sessionCode_lt: String
  sessionCode_lte: String
  sessionCode_gt: String
  sessionCode_gte: String
  sessionCode_contains: String
  sessionCode_not_contains: String
  sessionCode_starts_with: String
  sessionCode_not_starts_with: String
  sessionCode_ends_with: String
  sessionCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  centerAdmin_every: CenterAdminWhereInput
  centerAdmin_some: CenterAdminWhereInput
  centerAdmin_none: CenterAdminWhereInput
  annExamSeriesSubj_every: AnnualExamSubjectSeriesWhereInput
  annExamSeriesSubj_some: AnnualExamSubjectSeriesWhereInput
  annExamSeriesSubj_none: AnnualExamSubjectSeriesWhereInput
  registration_every: RegistrationWhereInput
  registration_some: RegistrationWhereInput
  registration_none: RegistrationWhereInput
  AND: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
}

input SessionWhereUniqueInput {
  id: ID
}

type SubDivision {
  id: ID!
  subDivName: String!
  subDivCode: String!
  division: Division!
  createdAt: DateTime!
  updatedAt: DateTime!
  town(where: TownWhereInput, orderBy: TownOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Town!]
}

type SubDivisionConnection {
  pageInfo: PageInfo!
  edges: [SubDivisionEdge]!
  aggregate: AggregateSubDivision!
}

input SubDivisionCreateInput {
  id: ID
  subDivName: String!
  subDivCode: String!
  division: DivisionCreateOneWithoutSubDivisionInput!
  town: TownCreateManyWithoutSubDivInput
}

input SubDivisionCreateManyWithoutDivisionInput {
  create: [SubDivisionCreateWithoutDivisionInput!]
  connect: [SubDivisionWhereUniqueInput!]
}

input SubDivisionCreateOneWithoutTownInput {
  create: SubDivisionCreateWithoutTownInput
  connect: SubDivisionWhereUniqueInput
}

input SubDivisionCreateWithoutDivisionInput {
  id: ID
  subDivName: String!
  subDivCode: String!
  town: TownCreateManyWithoutSubDivInput
}

input SubDivisionCreateWithoutTownInput {
  id: ID
  subDivName: String!
  subDivCode: String!
  division: DivisionCreateOneWithoutSubDivisionInput!
}

type SubDivisionEdge {
  node: SubDivision!
  cursor: String!
}

enum SubDivisionOrderByInput {
  id_ASC
  id_DESC
  subDivName_ASC
  subDivName_DESC
  subDivCode_ASC
  subDivCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SubDivisionPreviousValues {
  id: ID!
  subDivName: String!
  subDivCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input SubDivisionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  subDivName: String
  subDivName_not: String
  subDivName_in: [String!]
  subDivName_not_in: [String!]
  subDivName_lt: String
  subDivName_lte: String
  subDivName_gt: String
  subDivName_gte: String
  subDivName_contains: String
  subDivName_not_contains: String
  subDivName_starts_with: String
  subDivName_not_starts_with: String
  subDivName_ends_with: String
  subDivName_not_ends_with: String
  subDivCode: String
  subDivCode_not: String
  subDivCode_in: [String!]
  subDivCode_not_in: [String!]
  subDivCode_lt: String
  subDivCode_lte: String
  subDivCode_gt: String
  subDivCode_gte: String
  subDivCode_contains: String
  subDivCode_not_contains: String
  subDivCode_starts_with: String
  subDivCode_not_starts_with: String
  subDivCode_ends_with: String
  subDivCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SubDivisionScalarWhereInput!]
  OR: [SubDivisionScalarWhereInput!]
  NOT: [SubDivisionScalarWhereInput!]
}

type SubDivisionSubscriptionPayload {
  mutation: MutationType!
  node: SubDivision
  updatedFields: [String!]
  previousValues: SubDivisionPreviousValues
}

input SubDivisionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SubDivisionWhereInput
  AND: [SubDivisionSubscriptionWhereInput!]
  OR: [SubDivisionSubscriptionWhereInput!]
  NOT: [SubDivisionSubscriptionWhereInput!]
}

input SubDivisionUpdateInput {
  subDivName: String
  subDivCode: String
  division: DivisionUpdateOneRequiredWithoutSubDivisionInput
  town: TownUpdateManyWithoutSubDivInput
}

input SubDivisionUpdateManyDataInput {
  subDivName: String
  subDivCode: String
}

input SubDivisionUpdateManyMutationInput {
  subDivName: String
  subDivCode: String
}

input SubDivisionUpdateManyWithoutDivisionInput {
  create: [SubDivisionCreateWithoutDivisionInput!]
  delete: [SubDivisionWhereUniqueInput!]
  connect: [SubDivisionWhereUniqueInput!]
  set: [SubDivisionWhereUniqueInput!]
  disconnect: [SubDivisionWhereUniqueInput!]
  update: [SubDivisionUpdateWithWhereUniqueWithoutDivisionInput!]
  upsert: [SubDivisionUpsertWithWhereUniqueWithoutDivisionInput!]
  deleteMany: [SubDivisionScalarWhereInput!]
  updateMany: [SubDivisionUpdateManyWithWhereNestedInput!]
}

input SubDivisionUpdateManyWithWhereNestedInput {
  where: SubDivisionScalarWhereInput!
  data: SubDivisionUpdateManyDataInput!
}

input SubDivisionUpdateOneRequiredWithoutTownInput {
  create: SubDivisionCreateWithoutTownInput
  update: SubDivisionUpdateWithoutTownDataInput
  upsert: SubDivisionUpsertWithoutTownInput
  connect: SubDivisionWhereUniqueInput
}

input SubDivisionUpdateWithoutDivisionDataInput {
  subDivName: String
  subDivCode: String
  town: TownUpdateManyWithoutSubDivInput
}

input SubDivisionUpdateWithoutTownDataInput {
  subDivName: String
  subDivCode: String
  division: DivisionUpdateOneRequiredWithoutSubDivisionInput
}

input SubDivisionUpdateWithWhereUniqueWithoutDivisionInput {
  where: SubDivisionWhereUniqueInput!
  data: SubDivisionUpdateWithoutDivisionDataInput!
}

input SubDivisionUpsertWithoutTownInput {
  update: SubDivisionUpdateWithoutTownDataInput!
  create: SubDivisionCreateWithoutTownInput!
}

input SubDivisionUpsertWithWhereUniqueWithoutDivisionInput {
  where: SubDivisionWhereUniqueInput!
  update: SubDivisionUpdateWithoutDivisionDataInput!
  create: SubDivisionCreateWithoutDivisionInput!
}

input SubDivisionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  subDivName: String
  subDivName_not: String
  subDivName_in: [String!]
  subDivName_not_in: [String!]
  subDivName_lt: String
  subDivName_lte: String
  subDivName_gt: String
  subDivName_gte: String
  subDivName_contains: String
  subDivName_not_contains: String
  subDivName_starts_with: String
  subDivName_not_starts_with: String
  subDivName_ends_with: String
  subDivName_not_ends_with: String
  subDivCode: String
  subDivCode_not: String
  subDivCode_in: [String!]
  subDivCode_not_in: [String!]
  subDivCode_lt: String
  subDivCode_lte: String
  subDivCode_gt: String
  subDivCode_gte: String
  subDivCode_contains: String
  subDivCode_not_contains: String
  subDivCode_starts_with: String
  subDivCode_not_starts_with: String
  subDivCode_ends_with: String
  subDivCode_not_ends_with: String
  division: DivisionWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  town_every: TownWhereInput
  town_some: TownWhereInput
  town_none: TownWhereInput
  AND: [SubDivisionWhereInput!]
  OR: [SubDivisionWhereInput!]
  NOT: [SubDivisionWhereInput!]
}

input SubDivisionWhereUniqueInput {
  id: ID
}

type Subject {
  id: ID!
  subjName: String!
  subjCode: String!
  annExamSeriesSubj(where: AnnualExamSubjectSeriesWhereInput, orderBy: AnnualExamSubjectSeriesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AnnualExamSubjectSeries!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SubjectConnection {
  pageInfo: PageInfo!
  edges: [SubjectEdge]!
  aggregate: AggregateSubject!
}

input SubjectCreateInput {
  id: ID
  subjName: String!
  subjCode: String!
  annExamSeriesSubj: AnnualExamSubjectSeriesCreateManyInput
}

type SubjectEdge {
  node: Subject!
  cursor: String!
}

enum SubjectOrderByInput {
  id_ASC
  id_DESC
  subjName_ASC
  subjName_DESC
  subjCode_ASC
  subjCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SubjectPreviousValues {
  id: ID!
  subjName: String!
  subjCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SubjectSubscriptionPayload {
  mutation: MutationType!
  node: Subject
  updatedFields: [String!]
  previousValues: SubjectPreviousValues
}

input SubjectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SubjectWhereInput
  AND: [SubjectSubscriptionWhereInput!]
  OR: [SubjectSubscriptionWhereInput!]
  NOT: [SubjectSubscriptionWhereInput!]
}

input SubjectUpdateInput {
  subjName: String
  subjCode: String
  annExamSeriesSubj: AnnualExamSubjectSeriesUpdateManyInput
}

input SubjectUpdateManyMutationInput {
  subjName: String
  subjCode: String
}

input SubjectWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  subjName: String
  subjName_not: String
  subjName_in: [String!]
  subjName_not_in: [String!]
  subjName_lt: String
  subjName_lte: String
  subjName_gt: String
  subjName_gte: String
  subjName_contains: String
  subjName_not_contains: String
  subjName_starts_with: String
  subjName_not_starts_with: String
  subjName_ends_with: String
  subjName_not_ends_with: String
  subjCode: String
  subjCode_not: String
  subjCode_in: [String!]
  subjCode_not_in: [String!]
  subjCode_lt: String
  subjCode_lte: String
  subjCode_gt: String
  subjCode_gte: String
  subjCode_contains: String
  subjCode_not_contains: String
  subjCode_starts_with: String
  subjCode_not_starts_with: String
  subjCode_ends_with: String
  subjCode_not_ends_with: String
  annExamSeriesSubj_every: AnnualExamSubjectSeriesWhereInput
  annExamSeriesSubj_some: AnnualExamSubjectSeriesWhereInput
  annExamSeriesSubj_none: AnnualExamSubjectSeriesWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SubjectWhereInput!]
  OR: [SubjectWhereInput!]
  NOT: [SubjectWhereInput!]
}

input SubjectWhereUniqueInput {
  id: ID
}

type Subscription {
  annualExamSubjectSeries(where: AnnualExamSubjectSeriesSubscriptionWhereInput): AnnualExamSubjectSeriesSubscriptionPayload
  anotherType(where: AnotherTypeSubscriptionWhereInput): AnotherTypeSubscriptionPayload
  candidate(where: CandidateSubscriptionWhereInput): CandidateSubscriptionPayload
  centerAdmin(where: CenterAdminSubscriptionWhereInput): CenterAdminSubscriptionPayload
  division(where: DivisionSubscriptionWhereInput): DivisionSubscriptionPayload
  educationType(where: EducationTypeSubscriptionWhereInput): EducationTypeSubscriptionPayload
  exam(where: ExamSubscriptionWhereInput): ExamSubscriptionPayload
  examCenter(where: ExamCenterSubscriptionWhereInput): ExamCenterSubscriptionPayload
  gender(where: GenderSubscriptionWhereInput): GenderSubscriptionPayload
  item(where: ItemSubscriptionWhereInput): ItemSubscriptionPayload
  presence(where: PresenceSubscriptionWhereInput): PresenceSubscriptionPayload
  rank(where: RankSubscriptionWhereInput): RankSubscriptionPayload
  region(where: RegionSubscriptionWhereInput): RegionSubscriptionPayload
  registration(where: RegistrationSubscriptionWhereInput): RegistrationSubscriptionPayload
  report(where: ReportSubscriptionWhereInput): ReportSubscriptionPayload
  score(where: ScoreSubscriptionWhereInput): ScoreSubscriptionPayload
  series(where: SeriesSubscriptionWhereInput): SeriesSubscriptionPayload
  session(where: SessionSubscriptionWhereInput): SessionSubscriptionPayload
  subDivision(where: SubDivisionSubscriptionWhereInput): SubDivisionSubscriptionPayload
  subject(where: SubjectSubscriptionWhereInput): SubjectSubscriptionPayload
  town(where: TownSubscriptionWhereInput): TownSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Town {
  id: ID!
  townName: String!
  townCode: String!
  subDiv: SubDivision!
  createdAt: DateTime!
  updatedAt: DateTime!
  center(where: ExamCenterWhereInput, orderBy: ExamCenterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExamCenter!]
}

type TownConnection {
  pageInfo: PageInfo!
  edges: [TownEdge]!
  aggregate: AggregateTown!
}

input TownCreateInput {
  id: ID
  townName: String!
  townCode: String!
  subDiv: SubDivisionCreateOneWithoutTownInput!
  center: ExamCenterCreateManyWithoutTownInput
}

input TownCreateManyWithoutSubDivInput {
  create: [TownCreateWithoutSubDivInput!]
  connect: [TownWhereUniqueInput!]
}

input TownCreateOneWithoutCenterInput {
  create: TownCreateWithoutCenterInput
  connect: TownWhereUniqueInput
}

input TownCreateWithoutCenterInput {
  id: ID
  townName: String!
  townCode: String!
  subDiv: SubDivisionCreateOneWithoutTownInput!
}

input TownCreateWithoutSubDivInput {
  id: ID
  townName: String!
  townCode: String!
  center: ExamCenterCreateManyWithoutTownInput
}

type TownEdge {
  node: Town!
  cursor: String!
}

enum TownOrderByInput {
  id_ASC
  id_DESC
  townName_ASC
  townName_DESC
  townCode_ASC
  townCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TownPreviousValues {
  id: ID!
  townName: String!
  townCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input TownScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  townName: String
  townName_not: String
  townName_in: [String!]
  townName_not_in: [String!]
  townName_lt: String
  townName_lte: String
  townName_gt: String
  townName_gte: String
  townName_contains: String
  townName_not_contains: String
  townName_starts_with: String
  townName_not_starts_with: String
  townName_ends_with: String
  townName_not_ends_with: String
  townCode: String
  townCode_not: String
  townCode_in: [String!]
  townCode_not_in: [String!]
  townCode_lt: String
  townCode_lte: String
  townCode_gt: String
  townCode_gte: String
  townCode_contains: String
  townCode_not_contains: String
  townCode_starts_with: String
  townCode_not_starts_with: String
  townCode_ends_with: String
  townCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TownScalarWhereInput!]
  OR: [TownScalarWhereInput!]
  NOT: [TownScalarWhereInput!]
}

type TownSubscriptionPayload {
  mutation: MutationType!
  node: Town
  updatedFields: [String!]
  previousValues: TownPreviousValues
}

input TownSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TownWhereInput
  AND: [TownSubscriptionWhereInput!]
  OR: [TownSubscriptionWhereInput!]
  NOT: [TownSubscriptionWhereInput!]
}

input TownUpdateInput {
  townName: String
  townCode: String
  subDiv: SubDivisionUpdateOneRequiredWithoutTownInput
  center: ExamCenterUpdateManyWithoutTownInput
}

input TownUpdateManyDataInput {
  townName: String
  townCode: String
}

input TownUpdateManyMutationInput {
  townName: String
  townCode: String
}

input TownUpdateManyWithoutSubDivInput {
  create: [TownCreateWithoutSubDivInput!]
  delete: [TownWhereUniqueInput!]
  connect: [TownWhereUniqueInput!]
  set: [TownWhereUniqueInput!]
  disconnect: [TownWhereUniqueInput!]
  update: [TownUpdateWithWhereUniqueWithoutSubDivInput!]
  upsert: [TownUpsertWithWhereUniqueWithoutSubDivInput!]
  deleteMany: [TownScalarWhereInput!]
  updateMany: [TownUpdateManyWithWhereNestedInput!]
}

input TownUpdateManyWithWhereNestedInput {
  where: TownScalarWhereInput!
  data: TownUpdateManyDataInput!
}

input TownUpdateOneRequiredWithoutCenterInput {
  create: TownCreateWithoutCenterInput
  update: TownUpdateWithoutCenterDataInput
  upsert: TownUpsertWithoutCenterInput
  connect: TownWhereUniqueInput
}

input TownUpdateWithoutCenterDataInput {
  townName: String
  townCode: String
  subDiv: SubDivisionUpdateOneRequiredWithoutTownInput
}

input TownUpdateWithoutSubDivDataInput {
  townName: String
  townCode: String
  center: ExamCenterUpdateManyWithoutTownInput
}

input TownUpdateWithWhereUniqueWithoutSubDivInput {
  where: TownWhereUniqueInput!
  data: TownUpdateWithoutSubDivDataInput!
}

input TownUpsertWithoutCenterInput {
  update: TownUpdateWithoutCenterDataInput!
  create: TownCreateWithoutCenterInput!
}

input TownUpsertWithWhereUniqueWithoutSubDivInput {
  where: TownWhereUniqueInput!
  update: TownUpdateWithoutSubDivDataInput!
  create: TownCreateWithoutSubDivInput!
}

input TownWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  townName: String
  townName_not: String
  townName_in: [String!]
  townName_not_in: [String!]
  townName_lt: String
  townName_lte: String
  townName_gt: String
  townName_gte: String
  townName_contains: String
  townName_not_contains: String
  townName_starts_with: String
  townName_not_starts_with: String
  townName_ends_with: String
  townName_not_ends_with: String
  townCode: String
  townCode_not: String
  townCode_in: [String!]
  townCode_not_in: [String!]
  townCode_lt: String
  townCode_lte: String
  townCode_gt: String
  townCode_gte: String
  townCode_contains: String
  townCode_not_contains: String
  townCode_starts_with: String
  townCode_not_starts_with: String
  townCode_ends_with: String
  townCode_not_ends_with: String
  subDiv: SubDivisionWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  center_every: ExamCenterWhereInput
  center_some: ExamCenterWhereInput
  center_none: ExamCenterWhereInput
  AND: [TownWhereInput!]
  OR: [TownWhereInput!]
  NOT: [TownWhereInput!]
}

input TownWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  name: String!
  email: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  item(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  email: String!
  item: ItemCreateManyWithoutUserInput
}

input UserCreateOneWithoutItemInput {
  create: UserCreateWithoutItemInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutItemInput {
  id: ID
  name: String!
  email: String!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  email: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  name: String
  email: String
  item: ItemUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  name: String
  email: String
}

input UserUpdateOneRequiredWithoutItemInput {
  create: UserCreateWithoutItemInput
  update: UserUpdateWithoutItemDataInput
  upsert: UserUpsertWithoutItemInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutItemDataInput {
  name: String
  email: String
}

input UserUpsertWithoutItemInput {
  update: UserUpdateWithoutItemDataInput!
  create: UserCreateWithoutItemInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  item_every: ItemWhereInput
  item_some: ItemWhereInput
  item_none: ItemWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}
`
      }
    