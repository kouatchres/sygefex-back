// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  annualExamSubjectSeries: (
    where?: AnnualExamSubjectSeriesWhereInput
  ) => Promise<boolean>;
  anotherType: (where?: AnotherTypeWhereInput) => Promise<boolean>;
  candidate: (where?: CandidateWhereInput) => Promise<boolean>;
  centerAdmin: (where?: CenterAdminWhereInput) => Promise<boolean>;
  division: (where?: DivisionWhereInput) => Promise<boolean>;
  educationType: (where?: EducationTypeWhereInput) => Promise<boolean>;
  exam: (where?: ExamWhereInput) => Promise<boolean>;
  examCenter: (where?: ExamCenterWhereInput) => Promise<boolean>;
  gender: (where?: GenderWhereInput) => Promise<boolean>;
  item: (where?: ItemWhereInput) => Promise<boolean>;
  presence: (where?: PresenceWhereInput) => Promise<boolean>;
  rank: (where?: RankWhereInput) => Promise<boolean>;
  region: (where?: RegionWhereInput) => Promise<boolean>;
  registration: (where?: RegistrationWhereInput) => Promise<boolean>;
  report: (where?: ReportWhereInput) => Promise<boolean>;
  score: (where?: ScoreWhereInput) => Promise<boolean>;
  series: (where?: SeriesWhereInput) => Promise<boolean>;
  session: (where?: SessionWhereInput) => Promise<boolean>;
  subDivision: (where?: SubDivisionWhereInput) => Promise<boolean>;
  subject: (where?: SubjectWhereInput) => Promise<boolean>;
  town: (where?: TownWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  annualExamSubjectSeries: (
    where: AnnualExamSubjectSeriesWhereUniqueInput
  ) => AnnualExamSubjectSeriesNullablePromise;
  annualExamSubjectSerieses: (args?: {
    where?: AnnualExamSubjectSeriesWhereInput;
    orderBy?: AnnualExamSubjectSeriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AnnualExamSubjectSeries>;
  annualExamSubjectSeriesesConnection: (args?: {
    where?: AnnualExamSubjectSeriesWhereInput;
    orderBy?: AnnualExamSubjectSeriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AnnualExamSubjectSeriesConnectionPromise;
  anotherType: (
    where: AnotherTypeWhereUniqueInput
  ) => AnotherTypeNullablePromise;
  anotherTypes: (args?: {
    where?: AnotherTypeWhereInput;
    orderBy?: AnotherTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AnotherType>;
  anotherTypesConnection: (args?: {
    where?: AnotherTypeWhereInput;
    orderBy?: AnotherTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AnotherTypeConnectionPromise;
  candidate: (where: CandidateWhereUniqueInput) => CandidateNullablePromise;
  candidates: (args?: {
    where?: CandidateWhereInput;
    orderBy?: CandidateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Candidate>;
  candidatesConnection: (args?: {
    where?: CandidateWhereInput;
    orderBy?: CandidateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CandidateConnectionPromise;
  centerAdmin: (
    where: CenterAdminWhereUniqueInput
  ) => CenterAdminNullablePromise;
  centerAdmins: (args?: {
    where?: CenterAdminWhereInput;
    orderBy?: CenterAdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CenterAdmin>;
  centerAdminsConnection: (args?: {
    where?: CenterAdminWhereInput;
    orderBy?: CenterAdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CenterAdminConnectionPromise;
  division: (where: DivisionWhereUniqueInput) => DivisionNullablePromise;
  divisions: (args?: {
    where?: DivisionWhereInput;
    orderBy?: DivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Division>;
  divisionsConnection: (args?: {
    where?: DivisionWhereInput;
    orderBy?: DivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DivisionConnectionPromise;
  educationType: (
    where: EducationTypeWhereUniqueInput
  ) => EducationTypeNullablePromise;
  educationTypes: (args?: {
    where?: EducationTypeWhereInput;
    orderBy?: EducationTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EducationType>;
  educationTypesConnection: (args?: {
    where?: EducationTypeWhereInput;
    orderBy?: EducationTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EducationTypeConnectionPromise;
  exam: (where: ExamWhereUniqueInput) => ExamNullablePromise;
  exams: (args?: {
    where?: ExamWhereInput;
    orderBy?: ExamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Exam>;
  examsConnection: (args?: {
    where?: ExamWhereInput;
    orderBy?: ExamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExamConnectionPromise;
  examCenter: (where: ExamCenterWhereUniqueInput) => ExamCenterNullablePromise;
  examCenters: (args?: {
    where?: ExamCenterWhereInput;
    orderBy?: ExamCenterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ExamCenter>;
  examCentersConnection: (args?: {
    where?: ExamCenterWhereInput;
    orderBy?: ExamCenterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExamCenterConnectionPromise;
  gender: (where: GenderWhereUniqueInput) => GenderNullablePromise;
  genders: (args?: {
    where?: GenderWhereInput;
    orderBy?: GenderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Gender>;
  gendersConnection: (args?: {
    where?: GenderWhereInput;
    orderBy?: GenderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GenderConnectionPromise;
  item: (where: ItemWhereUniqueInput) => ItemNullablePromise;
  items: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Item>;
  itemsConnection: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ItemConnectionPromise;
  presence: (where: PresenceWhereUniqueInput) => PresenceNullablePromise;
  presences: (args?: {
    where?: PresenceWhereInput;
    orderBy?: PresenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Presence>;
  presencesConnection: (args?: {
    where?: PresenceWhereInput;
    orderBy?: PresenceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PresenceConnectionPromise;
  rank: (where: RankWhereUniqueInput) => RankNullablePromise;
  ranks: (args?: {
    where?: RankWhereInput;
    orderBy?: RankOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Rank>;
  ranksConnection: (args?: {
    where?: RankWhereInput;
    orderBy?: RankOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RankConnectionPromise;
  region: (where: RegionWhereUniqueInput) => RegionNullablePromise;
  regions: (args?: {
    where?: RegionWhereInput;
    orderBy?: RegionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Region>;
  regionsConnection: (args?: {
    where?: RegionWhereInput;
    orderBy?: RegionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RegionConnectionPromise;
  registration: (
    where: RegistrationWhereUniqueInput
  ) => RegistrationNullablePromise;
  registrations: (args?: {
    where?: RegistrationWhereInput;
    orderBy?: RegistrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Registration>;
  registrationsConnection: (args?: {
    where?: RegistrationWhereInput;
    orderBy?: RegistrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RegistrationConnectionPromise;
  report: (where: ReportWhereUniqueInput) => ReportNullablePromise;
  reports: (args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Report>;
  reportsConnection: (args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReportConnectionPromise;
  score: (where: ScoreWhereUniqueInput) => ScoreNullablePromise;
  scores: (args?: {
    where?: ScoreWhereInput;
    orderBy?: ScoreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Score>;
  scoresConnection: (args?: {
    where?: ScoreWhereInput;
    orderBy?: ScoreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ScoreConnectionPromise;
  series: (where: SeriesWhereUniqueInput) => SeriesNullablePromise;
  serieses: (args?: {
    where?: SeriesWhereInput;
    orderBy?: SeriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Series>;
  seriesesConnection: (args?: {
    where?: SeriesWhereInput;
    orderBy?: SeriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SeriesConnectionPromise;
  session: (where: SessionWhereUniqueInput) => SessionNullablePromise;
  sessions: (args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Session>;
  sessionsConnection: (args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SessionConnectionPromise;
  subDivision: (
    where: SubDivisionWhereUniqueInput
  ) => SubDivisionNullablePromise;
  subDivisions: (args?: {
    where?: SubDivisionWhereInput;
    orderBy?: SubDivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SubDivision>;
  subDivisionsConnection: (args?: {
    where?: SubDivisionWhereInput;
    orderBy?: SubDivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubDivisionConnectionPromise;
  subject: (where: SubjectWhereUniqueInput) => SubjectNullablePromise;
  subjects: (args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Subject>;
  subjectsConnection: (args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubjectConnectionPromise;
  town: (where: TownWhereUniqueInput) => TownNullablePromise;
  towns: (args?: {
    where?: TownWhereInput;
    orderBy?: TownOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Town>;
  townsConnection: (args?: {
    where?: TownWhereInput;
    orderBy?: TownOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TownConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAnnualExamSubjectSeries: (
    data: AnnualExamSubjectSeriesCreateInput
  ) => AnnualExamSubjectSeriesPromise;
  updateAnnualExamSubjectSeries: (args: {
    data: AnnualExamSubjectSeriesUpdateInput;
    where: AnnualExamSubjectSeriesWhereUniqueInput;
  }) => AnnualExamSubjectSeriesPromise;
  updateManyAnnualExamSubjectSerieses: (args: {
    data: AnnualExamSubjectSeriesUpdateManyMutationInput;
    where?: AnnualExamSubjectSeriesWhereInput;
  }) => BatchPayloadPromise;
  upsertAnnualExamSubjectSeries: (args: {
    where: AnnualExamSubjectSeriesWhereUniqueInput;
    create: AnnualExamSubjectSeriesCreateInput;
    update: AnnualExamSubjectSeriesUpdateInput;
  }) => AnnualExamSubjectSeriesPromise;
  deleteAnnualExamSubjectSeries: (
    where: AnnualExamSubjectSeriesWhereUniqueInput
  ) => AnnualExamSubjectSeriesPromise;
  deleteManyAnnualExamSubjectSerieses: (
    where?: AnnualExamSubjectSeriesWhereInput
  ) => BatchPayloadPromise;
  createAnotherType: (data: AnotherTypeCreateInput) => AnotherTypePromise;
  deleteAnotherType: (where: AnotherTypeWhereUniqueInput) => AnotherTypePromise;
  deleteManyAnotherTypes: (
    where?: AnotherTypeWhereInput
  ) => BatchPayloadPromise;
  createCandidate: (data: CandidateCreateInput) => CandidatePromise;
  updateCandidate: (args: {
    data: CandidateUpdateInput;
    where: CandidateWhereUniqueInput;
  }) => CandidatePromise;
  updateManyCandidates: (args: {
    data: CandidateUpdateManyMutationInput;
    where?: CandidateWhereInput;
  }) => BatchPayloadPromise;
  upsertCandidate: (args: {
    where: CandidateWhereUniqueInput;
    create: CandidateCreateInput;
    update: CandidateUpdateInput;
  }) => CandidatePromise;
  deleteCandidate: (where: CandidateWhereUniqueInput) => CandidatePromise;
  deleteManyCandidates: (where?: CandidateWhereInput) => BatchPayloadPromise;
  createCenterAdmin: (data: CenterAdminCreateInput) => CenterAdminPromise;
  updateCenterAdmin: (args: {
    data: CenterAdminUpdateInput;
    where: CenterAdminWhereUniqueInput;
  }) => CenterAdminPromise;
  updateManyCenterAdmins: (args: {
    data: CenterAdminUpdateManyMutationInput;
    where?: CenterAdminWhereInput;
  }) => BatchPayloadPromise;
  upsertCenterAdmin: (args: {
    where: CenterAdminWhereUniqueInput;
    create: CenterAdminCreateInput;
    update: CenterAdminUpdateInput;
  }) => CenterAdminPromise;
  deleteCenterAdmin: (where: CenterAdminWhereUniqueInput) => CenterAdminPromise;
  deleteManyCenterAdmins: (
    where?: CenterAdminWhereInput
  ) => BatchPayloadPromise;
  createDivision: (data: DivisionCreateInput) => DivisionPromise;
  updateDivision: (args: {
    data: DivisionUpdateInput;
    where: DivisionWhereUniqueInput;
  }) => DivisionPromise;
  updateManyDivisions: (args: {
    data: DivisionUpdateManyMutationInput;
    where?: DivisionWhereInput;
  }) => BatchPayloadPromise;
  upsertDivision: (args: {
    where: DivisionWhereUniqueInput;
    create: DivisionCreateInput;
    update: DivisionUpdateInput;
  }) => DivisionPromise;
  deleteDivision: (where: DivisionWhereUniqueInput) => DivisionPromise;
  deleteManyDivisions: (where?: DivisionWhereInput) => BatchPayloadPromise;
  createEducationType: (data: EducationTypeCreateInput) => EducationTypePromise;
  updateEducationType: (args: {
    data: EducationTypeUpdateInput;
    where: EducationTypeWhereUniqueInput;
  }) => EducationTypePromise;
  updateManyEducationTypes: (args: {
    data: EducationTypeUpdateManyMutationInput;
    where?: EducationTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertEducationType: (args: {
    where: EducationTypeWhereUniqueInput;
    create: EducationTypeCreateInput;
    update: EducationTypeUpdateInput;
  }) => EducationTypePromise;
  deleteEducationType: (
    where: EducationTypeWhereUniqueInput
  ) => EducationTypePromise;
  deleteManyEducationTypes: (
    where?: EducationTypeWhereInput
  ) => BatchPayloadPromise;
  createExam: (data: ExamCreateInput) => ExamPromise;
  updateExam: (args: {
    data: ExamUpdateInput;
    where: ExamWhereUniqueInput;
  }) => ExamPromise;
  updateManyExams: (args: {
    data: ExamUpdateManyMutationInput;
    where?: ExamWhereInput;
  }) => BatchPayloadPromise;
  upsertExam: (args: {
    where: ExamWhereUniqueInput;
    create: ExamCreateInput;
    update: ExamUpdateInput;
  }) => ExamPromise;
  deleteExam: (where: ExamWhereUniqueInput) => ExamPromise;
  deleteManyExams: (where?: ExamWhereInput) => BatchPayloadPromise;
  createExamCenter: (data: ExamCenterCreateInput) => ExamCenterPromise;
  updateExamCenter: (args: {
    data: ExamCenterUpdateInput;
    where: ExamCenterWhereUniqueInput;
  }) => ExamCenterPromise;
  updateManyExamCenters: (args: {
    data: ExamCenterUpdateManyMutationInput;
    where?: ExamCenterWhereInput;
  }) => BatchPayloadPromise;
  upsertExamCenter: (args: {
    where: ExamCenterWhereUniqueInput;
    create: ExamCenterCreateInput;
    update: ExamCenterUpdateInput;
  }) => ExamCenterPromise;
  deleteExamCenter: (where: ExamCenterWhereUniqueInput) => ExamCenterPromise;
  deleteManyExamCenters: (where?: ExamCenterWhereInput) => BatchPayloadPromise;
  createGender: (data: GenderCreateInput) => GenderPromise;
  updateGender: (args: {
    data: GenderUpdateInput;
    where: GenderWhereUniqueInput;
  }) => GenderPromise;
  updateManyGenders: (args: {
    data: GenderUpdateManyMutationInput;
    where?: GenderWhereInput;
  }) => BatchPayloadPromise;
  upsertGender: (args: {
    where: GenderWhereUniqueInput;
    create: GenderCreateInput;
    update: GenderUpdateInput;
  }) => GenderPromise;
  deleteGender: (where: GenderWhereUniqueInput) => GenderPromise;
  deleteManyGenders: (where?: GenderWhereInput) => BatchPayloadPromise;
  createItem: (data: ItemCreateInput) => ItemPromise;
  updateItem: (args: {
    data: ItemUpdateInput;
    where: ItemWhereUniqueInput;
  }) => ItemPromise;
  updateManyItems: (args: {
    data: ItemUpdateManyMutationInput;
    where?: ItemWhereInput;
  }) => BatchPayloadPromise;
  upsertItem: (args: {
    where: ItemWhereUniqueInput;
    create: ItemCreateInput;
    update: ItemUpdateInput;
  }) => ItemPromise;
  deleteItem: (where: ItemWhereUniqueInput) => ItemPromise;
  deleteManyItems: (where?: ItemWhereInput) => BatchPayloadPromise;
  createPresence: (data: PresenceCreateInput) => PresencePromise;
  updatePresence: (args: {
    data: PresenceUpdateInput;
    where: PresenceWhereUniqueInput;
  }) => PresencePromise;
  updateManyPresences: (args: {
    data: PresenceUpdateManyMutationInput;
    where?: PresenceWhereInput;
  }) => BatchPayloadPromise;
  upsertPresence: (args: {
    where: PresenceWhereUniqueInput;
    create: PresenceCreateInput;
    update: PresenceUpdateInput;
  }) => PresencePromise;
  deletePresence: (where: PresenceWhereUniqueInput) => PresencePromise;
  deleteManyPresences: (where?: PresenceWhereInput) => BatchPayloadPromise;
  createRank: (data: RankCreateInput) => RankPromise;
  updateRank: (args: {
    data: RankUpdateInput;
    where: RankWhereUniqueInput;
  }) => RankPromise;
  updateManyRanks: (args: {
    data: RankUpdateManyMutationInput;
    where?: RankWhereInput;
  }) => BatchPayloadPromise;
  upsertRank: (args: {
    where: RankWhereUniqueInput;
    create: RankCreateInput;
    update: RankUpdateInput;
  }) => RankPromise;
  deleteRank: (where: RankWhereUniqueInput) => RankPromise;
  deleteManyRanks: (where?: RankWhereInput) => BatchPayloadPromise;
  createRegion: (data: RegionCreateInput) => RegionPromise;
  updateRegion: (args: {
    data: RegionUpdateInput;
    where: RegionWhereUniqueInput;
  }) => RegionPromise;
  updateManyRegions: (args: {
    data: RegionUpdateManyMutationInput;
    where?: RegionWhereInput;
  }) => BatchPayloadPromise;
  upsertRegion: (args: {
    where: RegionWhereUniqueInput;
    create: RegionCreateInput;
    update: RegionUpdateInput;
  }) => RegionPromise;
  deleteRegion: (where: RegionWhereUniqueInput) => RegionPromise;
  deleteManyRegions: (where?: RegionWhereInput) => BatchPayloadPromise;
  createRegistration: (data: RegistrationCreateInput) => RegistrationPromise;
  updateRegistration: (args: {
    data: RegistrationUpdateInput;
    where: RegistrationWhereUniqueInput;
  }) => RegistrationPromise;
  upsertRegistration: (args: {
    where: RegistrationWhereUniqueInput;
    create: RegistrationCreateInput;
    update: RegistrationUpdateInput;
  }) => RegistrationPromise;
  deleteRegistration: (
    where: RegistrationWhereUniqueInput
  ) => RegistrationPromise;
  deleteManyRegistrations: (
    where?: RegistrationWhereInput
  ) => BatchPayloadPromise;
  createReport: (data: ReportCreateInput) => ReportPromise;
  updateReport: (args: {
    data: ReportUpdateInput;
    where: ReportWhereUniqueInput;
  }) => ReportPromise;
  updateManyReports: (args: {
    data: ReportUpdateManyMutationInput;
    where?: ReportWhereInput;
  }) => BatchPayloadPromise;
  upsertReport: (args: {
    where: ReportWhereUniqueInput;
    create: ReportCreateInput;
    update: ReportUpdateInput;
  }) => ReportPromise;
  deleteReport: (where: ReportWhereUniqueInput) => ReportPromise;
  deleteManyReports: (where?: ReportWhereInput) => BatchPayloadPromise;
  createScore: (data: ScoreCreateInput) => ScorePromise;
  updateScore: (args: {
    data: ScoreUpdateInput;
    where: ScoreWhereUniqueInput;
  }) => ScorePromise;
  updateManyScores: (args: {
    data: ScoreUpdateManyMutationInput;
    where?: ScoreWhereInput;
  }) => BatchPayloadPromise;
  upsertScore: (args: {
    where: ScoreWhereUniqueInput;
    create: ScoreCreateInput;
    update: ScoreUpdateInput;
  }) => ScorePromise;
  deleteScore: (where: ScoreWhereUniqueInput) => ScorePromise;
  deleteManyScores: (where?: ScoreWhereInput) => BatchPayloadPromise;
  createSeries: (data: SeriesCreateInput) => SeriesPromise;
  updateSeries: (args: {
    data: SeriesUpdateInput;
    where: SeriesWhereUniqueInput;
  }) => SeriesPromise;
  updateManySerieses: (args: {
    data: SeriesUpdateManyMutationInput;
    where?: SeriesWhereInput;
  }) => BatchPayloadPromise;
  upsertSeries: (args: {
    where: SeriesWhereUniqueInput;
    create: SeriesCreateInput;
    update: SeriesUpdateInput;
  }) => SeriesPromise;
  deleteSeries: (where: SeriesWhereUniqueInput) => SeriesPromise;
  deleteManySerieses: (where?: SeriesWhereInput) => BatchPayloadPromise;
  createSession: (data: SessionCreateInput) => SessionPromise;
  updateSession: (args: {
    data: SessionUpdateInput;
    where: SessionWhereUniqueInput;
  }) => SessionPromise;
  updateManySessions: (args: {
    data: SessionUpdateManyMutationInput;
    where?: SessionWhereInput;
  }) => BatchPayloadPromise;
  upsertSession: (args: {
    where: SessionWhereUniqueInput;
    create: SessionCreateInput;
    update: SessionUpdateInput;
  }) => SessionPromise;
  deleteSession: (where: SessionWhereUniqueInput) => SessionPromise;
  deleteManySessions: (where?: SessionWhereInput) => BatchPayloadPromise;
  createSubDivision: (data: SubDivisionCreateInput) => SubDivisionPromise;
  updateSubDivision: (args: {
    data: SubDivisionUpdateInput;
    where: SubDivisionWhereUniqueInput;
  }) => SubDivisionPromise;
  updateManySubDivisions: (args: {
    data: SubDivisionUpdateManyMutationInput;
    where?: SubDivisionWhereInput;
  }) => BatchPayloadPromise;
  upsertSubDivision: (args: {
    where: SubDivisionWhereUniqueInput;
    create: SubDivisionCreateInput;
    update: SubDivisionUpdateInput;
  }) => SubDivisionPromise;
  deleteSubDivision: (where: SubDivisionWhereUniqueInput) => SubDivisionPromise;
  deleteManySubDivisions: (
    where?: SubDivisionWhereInput
  ) => BatchPayloadPromise;
  createSubject: (data: SubjectCreateInput) => SubjectPromise;
  updateSubject: (args: {
    data: SubjectUpdateInput;
    where: SubjectWhereUniqueInput;
  }) => SubjectPromise;
  updateManySubjects: (args: {
    data: SubjectUpdateManyMutationInput;
    where?: SubjectWhereInput;
  }) => BatchPayloadPromise;
  upsertSubject: (args: {
    where: SubjectWhereUniqueInput;
    create: SubjectCreateInput;
    update: SubjectUpdateInput;
  }) => SubjectPromise;
  deleteSubject: (where: SubjectWhereUniqueInput) => SubjectPromise;
  deleteManySubjects: (where?: SubjectWhereInput) => BatchPayloadPromise;
  createTown: (data: TownCreateInput) => TownPromise;
  updateTown: (args: {
    data: TownUpdateInput;
    where: TownWhereUniqueInput;
  }) => TownPromise;
  updateManyTowns: (args: {
    data: TownUpdateManyMutationInput;
    where?: TownWhereInput;
  }) => BatchPayloadPromise;
  upsertTown: (args: {
    where: TownWhereUniqueInput;
    create: TownCreateInput;
    update: TownUpdateInput;
  }) => TownPromise;
  deleteTown: (where: TownWhereUniqueInput) => TownPromise;
  deleteManyTowns: (where?: TownWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  annualExamSubjectSeries: (
    where?: AnnualExamSubjectSeriesSubscriptionWhereInput
  ) => AnnualExamSubjectSeriesSubscriptionPayloadSubscription;
  anotherType: (
    where?: AnotherTypeSubscriptionWhereInput
  ) => AnotherTypeSubscriptionPayloadSubscription;
  candidate: (
    where?: CandidateSubscriptionWhereInput
  ) => CandidateSubscriptionPayloadSubscription;
  centerAdmin: (
    where?: CenterAdminSubscriptionWhereInput
  ) => CenterAdminSubscriptionPayloadSubscription;
  division: (
    where?: DivisionSubscriptionWhereInput
  ) => DivisionSubscriptionPayloadSubscription;
  educationType: (
    where?: EducationTypeSubscriptionWhereInput
  ) => EducationTypeSubscriptionPayloadSubscription;
  exam: (
    where?: ExamSubscriptionWhereInput
  ) => ExamSubscriptionPayloadSubscription;
  examCenter: (
    where?: ExamCenterSubscriptionWhereInput
  ) => ExamCenterSubscriptionPayloadSubscription;
  gender: (
    where?: GenderSubscriptionWhereInput
  ) => GenderSubscriptionPayloadSubscription;
  item: (
    where?: ItemSubscriptionWhereInput
  ) => ItemSubscriptionPayloadSubscription;
  presence: (
    where?: PresenceSubscriptionWhereInput
  ) => PresenceSubscriptionPayloadSubscription;
  rank: (
    where?: RankSubscriptionWhereInput
  ) => RankSubscriptionPayloadSubscription;
  region: (
    where?: RegionSubscriptionWhereInput
  ) => RegionSubscriptionPayloadSubscription;
  registration: (
    where?: RegistrationSubscriptionWhereInput
  ) => RegistrationSubscriptionPayloadSubscription;
  report: (
    where?: ReportSubscriptionWhereInput
  ) => ReportSubscriptionPayloadSubscription;
  score: (
    where?: ScoreSubscriptionWhereInput
  ) => ScoreSubscriptionPayloadSubscription;
  series: (
    where?: SeriesSubscriptionWhereInput
  ) => SeriesSubscriptionPayloadSubscription;
  session: (
    where?: SessionSubscriptionWhereInput
  ) => SessionSubscriptionPayloadSubscription;
  subDivision: (
    where?: SubDivisionSubscriptionWhereInput
  ) => SubDivisionSubscriptionPayloadSubscription;
  subject: (
    where?: SubjectSubscriptionWhereInput
  ) => SubjectSubscriptionPayloadSubscription;
  town: (
    where?: TownSubscriptionWhereInput
  ) => TownSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CenterAdminOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "authName_ASC"
  | "authName_DESC"
  | "authInstitution_ASC"
  | "authInstitution_DESC"
  | "authPhone_ASC"
  | "authPhone_DESC"
  | "authMatricue_ASC"
  | "authMatricue_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AnnualExamSubjectSeriesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "rankCode_ASC"
  | "rankCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RegistrationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CandidateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "cand1stName_ASC"
  | "cand1stName_DESC"
  | "cand2ndName_ASC"
  | "cand2ndName_DESC"
  | "cand3rdName_ASC"
  | "cand3rdName_DESC"
  | "placeOfBirth_ASC"
  | "placeOfBirth_DESC"
  | "candCode_ASC"
  | "candCode_DESC"
  | "image_ASC"
  | "image_DESC"
  | "birthCertNumber_ASC"
  | "birthCertNumber_DESC"
  | "email_ASC"
  | "email_DESC"
  | "phoneNumb_ASC"
  | "phoneNumb_DESC"
  | "dateOfBirth_ASC"
  | "dateOfBirth_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SeriesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "seriesName_ASC"
  | "seriesName_DESC"
  | "seriesCode_ASC"
  | "seriesCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DivisionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "divName_ASC"
  | "divName_DESC"
  | "divCode_ASC"
  | "divCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SubDivisionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "subDivName_ASC"
  | "subDivName_DESC"
  | "subDivCode_ASC"
  | "subDivCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TownOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "townName_ASC"
  | "townName_DESC"
  | "townCode_ASC"
  | "townCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExamCenterOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "centerName_ASC"
  | "centerName_DESC"
  | "centerCode_ASC"
  | "centerCode_DESC"
  | "centerNumber_ASC"
  | "centerNumber_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ReportOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "reportName_ASC"
  | "reportName_DESC"
  | "reportCode_ASC"
  | "reportCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ScoreOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "subjectAve_ASC"
  | "subjectAve_DESC"
  | "subjectTotal_ASC"
  | "subjectTotal_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AnotherTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EducationTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "educationTypeName_ASC"
  | "educationTypeName_DESC"
  | "educationTypeCode_ASC"
  | "educationTypeCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExamOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "examName_ASC"
  | "examName_DESC"
  | "examCode_ASC"
  | "examCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GenderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "genderName_ASC"
  | "genderName_DESC"
  | "genderCode_ASC"
  | "genderCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "descrption_ASC"
  | "descrption_DESC"
  | "image_ASC"
  | "image_DESC"
  | "largeImage_ASC"
  | "largeImage_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PresenceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "presenceName_ASC"
  | "presenceName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RankOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "rankName_ASC"
  | "rankName_DESC"
  | "rankCode_ASC"
  | "rankCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RegionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "regName_ASC"
  | "regName_DESC"
  | "regCode_ASC"
  | "regCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SessionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "sessionName_ASC"
  | "sessionName_DESC"
  | "sessionCode_ASC"
  | "sessionCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SubjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "subjName_ASC"
  | "subjName_DESC"
  | "subjCode_ASC"
  | "subjCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AnnualExamSubjectSeriesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CenterAdminWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  authName?: Maybe<String>;
  authName_not?: Maybe<String>;
  authName_in?: Maybe<String[] | String>;
  authName_not_in?: Maybe<String[] | String>;
  authName_lt?: Maybe<String>;
  authName_lte?: Maybe<String>;
  authName_gt?: Maybe<String>;
  authName_gte?: Maybe<String>;
  authName_contains?: Maybe<String>;
  authName_not_contains?: Maybe<String>;
  authName_starts_with?: Maybe<String>;
  authName_not_starts_with?: Maybe<String>;
  authName_ends_with?: Maybe<String>;
  authName_not_ends_with?: Maybe<String>;
  authInstitution?: Maybe<String>;
  authInstitution_not?: Maybe<String>;
  authInstitution_in?: Maybe<String[] | String>;
  authInstitution_not_in?: Maybe<String[] | String>;
  authInstitution_lt?: Maybe<String>;
  authInstitution_lte?: Maybe<String>;
  authInstitution_gt?: Maybe<String>;
  authInstitution_gte?: Maybe<String>;
  authInstitution_contains?: Maybe<String>;
  authInstitution_not_contains?: Maybe<String>;
  authInstitution_starts_with?: Maybe<String>;
  authInstitution_not_starts_with?: Maybe<String>;
  authInstitution_ends_with?: Maybe<String>;
  authInstitution_not_ends_with?: Maybe<String>;
  authPhone?: Maybe<Int>;
  authPhone_not?: Maybe<Int>;
  authPhone_in?: Maybe<Int[] | Int>;
  authPhone_not_in?: Maybe<Int[] | Int>;
  authPhone_lt?: Maybe<Int>;
  authPhone_lte?: Maybe<Int>;
  authPhone_gt?: Maybe<Int>;
  authPhone_gte?: Maybe<Int>;
  authMatricue?: Maybe<String>;
  authMatricue_not?: Maybe<String>;
  authMatricue_in?: Maybe<String[] | String>;
  authMatricue_not_in?: Maybe<String[] | String>;
  authMatricue_lt?: Maybe<String>;
  authMatricue_lte?: Maybe<String>;
  authMatricue_gt?: Maybe<String>;
  authMatricue_gte?: Maybe<String>;
  authMatricue_contains?: Maybe<String>;
  authMatricue_not_contains?: Maybe<String>;
  authMatricue_starts_with?: Maybe<String>;
  authMatricue_not_starts_with?: Maybe<String>;
  authMatricue_ends_with?: Maybe<String>;
  authMatricue_not_ends_with?: Maybe<String>;
  rank?: Maybe<RankWhereInput>;
  exam?: Maybe<ExamWhereInput>;
  session?: Maybe<SessionWhereInput>;
  center?: Maybe<ExamCenterWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  report_every?: Maybe<ReportWhereInput>;
  report_some?: Maybe<ReportWhereInput>;
  report_none?: Maybe<ReportWhereInput>;
  AND?: Maybe<CenterAdminWhereInput[] | CenterAdminWhereInput>;
  OR?: Maybe<CenterAdminWhereInput[] | CenterAdminWhereInput>;
  NOT?: Maybe<CenterAdminWhereInput[] | CenterAdminWhereInput>;
}

export interface RankWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  rankName?: Maybe<String>;
  rankName_not?: Maybe<String>;
  rankName_in?: Maybe<String[] | String>;
  rankName_not_in?: Maybe<String[] | String>;
  rankName_lt?: Maybe<String>;
  rankName_lte?: Maybe<String>;
  rankName_gt?: Maybe<String>;
  rankName_gte?: Maybe<String>;
  rankName_contains?: Maybe<String>;
  rankName_not_contains?: Maybe<String>;
  rankName_starts_with?: Maybe<String>;
  rankName_not_starts_with?: Maybe<String>;
  rankName_ends_with?: Maybe<String>;
  rankName_not_ends_with?: Maybe<String>;
  rankCode?: Maybe<String>;
  rankCode_not?: Maybe<String>;
  rankCode_in?: Maybe<String[] | String>;
  rankCode_not_in?: Maybe<String[] | String>;
  rankCode_lt?: Maybe<String>;
  rankCode_lte?: Maybe<String>;
  rankCode_gt?: Maybe<String>;
  rankCode_gte?: Maybe<String>;
  rankCode_contains?: Maybe<String>;
  rankCode_not_contains?: Maybe<String>;
  rankCode_starts_with?: Maybe<String>;
  rankCode_not_starts_with?: Maybe<String>;
  rankCode_ends_with?: Maybe<String>;
  rankCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  centerAdmin_every?: Maybe<CenterAdminWhereInput>;
  centerAdmin_some?: Maybe<CenterAdminWhereInput>;
  centerAdmin_none?: Maybe<CenterAdminWhereInput>;
  AND?: Maybe<RankWhereInput[] | RankWhereInput>;
  OR?: Maybe<RankWhereInput[] | RankWhereInput>;
  NOT?: Maybe<RankWhereInput[] | RankWhereInput>;
}

export interface ExamWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  examName?: Maybe<String>;
  examName_not?: Maybe<String>;
  examName_in?: Maybe<String[] | String>;
  examName_not_in?: Maybe<String[] | String>;
  examName_lt?: Maybe<String>;
  examName_lte?: Maybe<String>;
  examName_gt?: Maybe<String>;
  examName_gte?: Maybe<String>;
  examName_contains?: Maybe<String>;
  examName_not_contains?: Maybe<String>;
  examName_starts_with?: Maybe<String>;
  examName_not_starts_with?: Maybe<String>;
  examName_ends_with?: Maybe<String>;
  examName_not_ends_with?: Maybe<String>;
  examCode?: Maybe<String>;
  examCode_not?: Maybe<String>;
  examCode_in?: Maybe<String[] | String>;
  examCode_not_in?: Maybe<String[] | String>;
  examCode_lt?: Maybe<String>;
  examCode_lte?: Maybe<String>;
  examCode_gt?: Maybe<String>;
  examCode_gte?: Maybe<String>;
  examCode_contains?: Maybe<String>;
  examCode_not_contains?: Maybe<String>;
  examCode_starts_with?: Maybe<String>;
  examCode_not_starts_with?: Maybe<String>;
  examCode_ends_with?: Maybe<String>;
  examCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  centerAdmin_every?: Maybe<CenterAdminWhereInput>;
  centerAdmin_some?: Maybe<CenterAdminWhereInput>;
  centerAdmin_none?: Maybe<CenterAdminWhereInput>;
  annExamSeriesSubj_every?: Maybe<AnnualExamSubjectSeriesWhereInput>;
  annExamSeriesSubj_some?: Maybe<AnnualExamSubjectSeriesWhereInput>;
  annExamSeriesSubj_none?: Maybe<AnnualExamSubjectSeriesWhereInput>;
  registration_every?: Maybe<RegistrationWhereInput>;
  registration_some?: Maybe<RegistrationWhereInput>;
  registration_none?: Maybe<RegistrationWhereInput>;
  AND?: Maybe<ExamWhereInput[] | ExamWhereInput>;
  OR?: Maybe<ExamWhereInput[] | ExamWhereInput>;
  NOT?: Maybe<ExamWhereInput[] | ExamWhereInput>;
}

export interface AnnualExamSubjectSeriesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  exam?: Maybe<ExamWhereInput>;
  session?: Maybe<SessionWhereInput>;
  center?: Maybe<ExamCenterWhereInput>;
  rankCode?: Maybe<String>;
  rankCode_not?: Maybe<String>;
  rankCode_in?: Maybe<String[] | String>;
  rankCode_not_in?: Maybe<String[] | String>;
  rankCode_lt?: Maybe<String>;
  rankCode_lte?: Maybe<String>;
  rankCode_gt?: Maybe<String>;
  rankCode_gte?: Maybe<String>;
  rankCode_contains?: Maybe<String>;
  rankCode_not_contains?: Maybe<String>;
  rankCode_starts_with?: Maybe<String>;
  rankCode_not_starts_with?: Maybe<String>;
  rankCode_ends_with?: Maybe<String>;
  rankCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  score_every?: Maybe<ScoreWhereInput>;
  score_some?: Maybe<ScoreWhereInput>;
  score_none?: Maybe<ScoreWhereInput>;
  AND?: Maybe<
    AnnualExamSubjectSeriesWhereInput[] | AnnualExamSubjectSeriesWhereInput
  >;
  OR?: Maybe<
    AnnualExamSubjectSeriesWhereInput[] | AnnualExamSubjectSeriesWhereInput
  >;
  NOT?: Maybe<
    AnnualExamSubjectSeriesWhereInput[] | AnnualExamSubjectSeriesWhereInput
  >;
}

export interface SessionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  sessionName?: Maybe<String>;
  sessionName_not?: Maybe<String>;
  sessionName_in?: Maybe<String[] | String>;
  sessionName_not_in?: Maybe<String[] | String>;
  sessionName_lt?: Maybe<String>;
  sessionName_lte?: Maybe<String>;
  sessionName_gt?: Maybe<String>;
  sessionName_gte?: Maybe<String>;
  sessionName_contains?: Maybe<String>;
  sessionName_not_contains?: Maybe<String>;
  sessionName_starts_with?: Maybe<String>;
  sessionName_not_starts_with?: Maybe<String>;
  sessionName_ends_with?: Maybe<String>;
  sessionName_not_ends_with?: Maybe<String>;
  sessionCode?: Maybe<String>;
  sessionCode_not?: Maybe<String>;
  sessionCode_in?: Maybe<String[] | String>;
  sessionCode_not_in?: Maybe<String[] | String>;
  sessionCode_lt?: Maybe<String>;
  sessionCode_lte?: Maybe<String>;
  sessionCode_gt?: Maybe<String>;
  sessionCode_gte?: Maybe<String>;
  sessionCode_contains?: Maybe<String>;
  sessionCode_not_contains?: Maybe<String>;
  sessionCode_starts_with?: Maybe<String>;
  sessionCode_not_starts_with?: Maybe<String>;
  sessionCode_ends_with?: Maybe<String>;
  sessionCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  centerAdmin_every?: Maybe<CenterAdminWhereInput>;
  centerAdmin_some?: Maybe<CenterAdminWhereInput>;
  centerAdmin_none?: Maybe<CenterAdminWhereInput>;
  annExamSeriesSubj_every?: Maybe<AnnualExamSubjectSeriesWhereInput>;
  annExamSeriesSubj_some?: Maybe<AnnualExamSubjectSeriesWhereInput>;
  annExamSeriesSubj_none?: Maybe<AnnualExamSubjectSeriesWhereInput>;
  registration_every?: Maybe<RegistrationWhereInput>;
  registration_some?: Maybe<RegistrationWhereInput>;
  registration_none?: Maybe<RegistrationWhereInput>;
  AND?: Maybe<SessionWhereInput[] | SessionWhereInput>;
  OR?: Maybe<SessionWhereInput[] | SessionWhereInput>;
  NOT?: Maybe<SessionWhereInput[] | SessionWhereInput>;
}

export interface RegistrationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  candidate?: Maybe<CandidateWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  exam?: Maybe<ExamWhereInput>;
  series?: Maybe<SeriesWhereInput>;
  session?: Maybe<SessionWhereInput>;
  center?: Maybe<ExamCenterWhereInput>;
  AND?: Maybe<RegistrationWhereInput[] | RegistrationWhereInput>;
  OR?: Maybe<RegistrationWhereInput[] | RegistrationWhereInput>;
  NOT?: Maybe<RegistrationWhereInput[] | RegistrationWhereInput>;
}

export interface CandidateWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  cand1stName?: Maybe<String>;
  cand1stName_not?: Maybe<String>;
  cand1stName_in?: Maybe<String[] | String>;
  cand1stName_not_in?: Maybe<String[] | String>;
  cand1stName_lt?: Maybe<String>;
  cand1stName_lte?: Maybe<String>;
  cand1stName_gt?: Maybe<String>;
  cand1stName_gte?: Maybe<String>;
  cand1stName_contains?: Maybe<String>;
  cand1stName_not_contains?: Maybe<String>;
  cand1stName_starts_with?: Maybe<String>;
  cand1stName_not_starts_with?: Maybe<String>;
  cand1stName_ends_with?: Maybe<String>;
  cand1stName_not_ends_with?: Maybe<String>;
  cand2ndName?: Maybe<String>;
  cand2ndName_not?: Maybe<String>;
  cand2ndName_in?: Maybe<String[] | String>;
  cand2ndName_not_in?: Maybe<String[] | String>;
  cand2ndName_lt?: Maybe<String>;
  cand2ndName_lte?: Maybe<String>;
  cand2ndName_gt?: Maybe<String>;
  cand2ndName_gte?: Maybe<String>;
  cand2ndName_contains?: Maybe<String>;
  cand2ndName_not_contains?: Maybe<String>;
  cand2ndName_starts_with?: Maybe<String>;
  cand2ndName_not_starts_with?: Maybe<String>;
  cand2ndName_ends_with?: Maybe<String>;
  cand2ndName_not_ends_with?: Maybe<String>;
  cand3rdName?: Maybe<String>;
  cand3rdName_not?: Maybe<String>;
  cand3rdName_in?: Maybe<String[] | String>;
  cand3rdName_not_in?: Maybe<String[] | String>;
  cand3rdName_lt?: Maybe<String>;
  cand3rdName_lte?: Maybe<String>;
  cand3rdName_gt?: Maybe<String>;
  cand3rdName_gte?: Maybe<String>;
  cand3rdName_contains?: Maybe<String>;
  cand3rdName_not_contains?: Maybe<String>;
  cand3rdName_starts_with?: Maybe<String>;
  cand3rdName_not_starts_with?: Maybe<String>;
  cand3rdName_ends_with?: Maybe<String>;
  cand3rdName_not_ends_with?: Maybe<String>;
  placeOfBirth?: Maybe<String>;
  placeOfBirth_not?: Maybe<String>;
  placeOfBirth_in?: Maybe<String[] | String>;
  placeOfBirth_not_in?: Maybe<String[] | String>;
  placeOfBirth_lt?: Maybe<String>;
  placeOfBirth_lte?: Maybe<String>;
  placeOfBirth_gt?: Maybe<String>;
  placeOfBirth_gte?: Maybe<String>;
  placeOfBirth_contains?: Maybe<String>;
  placeOfBirth_not_contains?: Maybe<String>;
  placeOfBirth_starts_with?: Maybe<String>;
  placeOfBirth_not_starts_with?: Maybe<String>;
  placeOfBirth_ends_with?: Maybe<String>;
  placeOfBirth_not_ends_with?: Maybe<String>;
  candCode?: Maybe<String>;
  candCode_not?: Maybe<String>;
  candCode_in?: Maybe<String[] | String>;
  candCode_not_in?: Maybe<String[] | String>;
  candCode_lt?: Maybe<String>;
  candCode_lte?: Maybe<String>;
  candCode_gt?: Maybe<String>;
  candCode_gte?: Maybe<String>;
  candCode_contains?: Maybe<String>;
  candCode_not_contains?: Maybe<String>;
  candCode_starts_with?: Maybe<String>;
  candCode_not_starts_with?: Maybe<String>;
  candCode_ends_with?: Maybe<String>;
  candCode_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  birthCertNumber?: Maybe<String>;
  birthCertNumber_not?: Maybe<String>;
  birthCertNumber_in?: Maybe<String[] | String>;
  birthCertNumber_not_in?: Maybe<String[] | String>;
  birthCertNumber_lt?: Maybe<String>;
  birthCertNumber_lte?: Maybe<String>;
  birthCertNumber_gt?: Maybe<String>;
  birthCertNumber_gte?: Maybe<String>;
  birthCertNumber_contains?: Maybe<String>;
  birthCertNumber_not_contains?: Maybe<String>;
  birthCertNumber_starts_with?: Maybe<String>;
  birthCertNumber_not_starts_with?: Maybe<String>;
  birthCertNumber_ends_with?: Maybe<String>;
  birthCertNumber_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  phoneNumb?: Maybe<Int>;
  phoneNumb_not?: Maybe<Int>;
  phoneNumb_in?: Maybe<Int[] | Int>;
  phoneNumb_not_in?: Maybe<Int[] | Int>;
  phoneNumb_lt?: Maybe<Int>;
  phoneNumb_lte?: Maybe<Int>;
  phoneNumb_gt?: Maybe<Int>;
  phoneNumb_gte?: Maybe<Int>;
  dateOfBirth?: Maybe<DateTimeInput>;
  dateOfBirth_not?: Maybe<DateTimeInput>;
  dateOfBirth_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateOfBirth_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateOfBirth_lt?: Maybe<DateTimeInput>;
  dateOfBirth_lte?: Maybe<DateTimeInput>;
  dateOfBirth_gt?: Maybe<DateTimeInput>;
  dateOfBirth_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  gender?: Maybe<GenderWhereInput>;
  registration_every?: Maybe<RegistrationWhereInput>;
  registration_some?: Maybe<RegistrationWhereInput>;
  registration_none?: Maybe<RegistrationWhereInput>;
  AND?: Maybe<CandidateWhereInput[] | CandidateWhereInput>;
  OR?: Maybe<CandidateWhereInput[] | CandidateWhereInput>;
  NOT?: Maybe<CandidateWhereInput[] | CandidateWhereInput>;
}

export interface GenderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  genderName?: Maybe<String>;
  genderName_not?: Maybe<String>;
  genderName_in?: Maybe<String[] | String>;
  genderName_not_in?: Maybe<String[] | String>;
  genderName_lt?: Maybe<String>;
  genderName_lte?: Maybe<String>;
  genderName_gt?: Maybe<String>;
  genderName_gte?: Maybe<String>;
  genderName_contains?: Maybe<String>;
  genderName_not_contains?: Maybe<String>;
  genderName_starts_with?: Maybe<String>;
  genderName_not_starts_with?: Maybe<String>;
  genderName_ends_with?: Maybe<String>;
  genderName_not_ends_with?: Maybe<String>;
  genderCode?: Maybe<String>;
  genderCode_not?: Maybe<String>;
  genderCode_in?: Maybe<String[] | String>;
  genderCode_not_in?: Maybe<String[] | String>;
  genderCode_lt?: Maybe<String>;
  genderCode_lte?: Maybe<String>;
  genderCode_gt?: Maybe<String>;
  genderCode_gte?: Maybe<String>;
  genderCode_contains?: Maybe<String>;
  genderCode_not_contains?: Maybe<String>;
  genderCode_starts_with?: Maybe<String>;
  genderCode_not_starts_with?: Maybe<String>;
  genderCode_ends_with?: Maybe<String>;
  genderCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  candidate_every?: Maybe<CandidateWhereInput>;
  candidate_some?: Maybe<CandidateWhereInput>;
  candidate_none?: Maybe<CandidateWhereInput>;
  AND?: Maybe<GenderWhereInput[] | GenderWhereInput>;
  OR?: Maybe<GenderWhereInput[] | GenderWhereInput>;
  NOT?: Maybe<GenderWhereInput[] | GenderWhereInput>;
}

export interface SeriesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  seriesName?: Maybe<String>;
  seriesName_not?: Maybe<String>;
  seriesName_in?: Maybe<String[] | String>;
  seriesName_not_in?: Maybe<String[] | String>;
  seriesName_lt?: Maybe<String>;
  seriesName_lte?: Maybe<String>;
  seriesName_gt?: Maybe<String>;
  seriesName_gte?: Maybe<String>;
  seriesName_contains?: Maybe<String>;
  seriesName_not_contains?: Maybe<String>;
  seriesName_starts_with?: Maybe<String>;
  seriesName_not_starts_with?: Maybe<String>;
  seriesName_ends_with?: Maybe<String>;
  seriesName_not_ends_with?: Maybe<String>;
  seriesCode?: Maybe<String>;
  seriesCode_not?: Maybe<String>;
  seriesCode_in?: Maybe<String[] | String>;
  seriesCode_not_in?: Maybe<String[] | String>;
  seriesCode_lt?: Maybe<String>;
  seriesCode_lte?: Maybe<String>;
  seriesCode_gt?: Maybe<String>;
  seriesCode_gte?: Maybe<String>;
  seriesCode_contains?: Maybe<String>;
  seriesCode_not_contains?: Maybe<String>;
  seriesCode_starts_with?: Maybe<String>;
  seriesCode_not_starts_with?: Maybe<String>;
  seriesCode_ends_with?: Maybe<String>;
  seriesCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  educationType?: Maybe<EducationTypeWhereInput>;
  registration_every?: Maybe<RegistrationWhereInput>;
  registration_some?: Maybe<RegistrationWhereInput>;
  registration_none?: Maybe<RegistrationWhereInput>;
  AND?: Maybe<SeriesWhereInput[] | SeriesWhereInput>;
  OR?: Maybe<SeriesWhereInput[] | SeriesWhereInput>;
  NOT?: Maybe<SeriesWhereInput[] | SeriesWhereInput>;
}

export interface EducationTypeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  educationTypeName?: Maybe<String>;
  educationTypeName_not?: Maybe<String>;
  educationTypeName_in?: Maybe<String[] | String>;
  educationTypeName_not_in?: Maybe<String[] | String>;
  educationTypeName_lt?: Maybe<String>;
  educationTypeName_lte?: Maybe<String>;
  educationTypeName_gt?: Maybe<String>;
  educationTypeName_gte?: Maybe<String>;
  educationTypeName_contains?: Maybe<String>;
  educationTypeName_not_contains?: Maybe<String>;
  educationTypeName_starts_with?: Maybe<String>;
  educationTypeName_not_starts_with?: Maybe<String>;
  educationTypeName_ends_with?: Maybe<String>;
  educationTypeName_not_ends_with?: Maybe<String>;
  educationTypeCode?: Maybe<String>;
  educationTypeCode_not?: Maybe<String>;
  educationTypeCode_in?: Maybe<String[] | String>;
  educationTypeCode_not_in?: Maybe<String[] | String>;
  educationTypeCode_lt?: Maybe<String>;
  educationTypeCode_lte?: Maybe<String>;
  educationTypeCode_gt?: Maybe<String>;
  educationTypeCode_gte?: Maybe<String>;
  educationTypeCode_contains?: Maybe<String>;
  educationTypeCode_not_contains?: Maybe<String>;
  educationTypeCode_starts_with?: Maybe<String>;
  educationTypeCode_not_starts_with?: Maybe<String>;
  educationTypeCode_ends_with?: Maybe<String>;
  educationTypeCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  series_every?: Maybe<SeriesWhereInput>;
  series_some?: Maybe<SeriesWhereInput>;
  series_none?: Maybe<SeriesWhereInput>;
  AND?: Maybe<EducationTypeWhereInput[] | EducationTypeWhereInput>;
  OR?: Maybe<EducationTypeWhereInput[] | EducationTypeWhereInput>;
  NOT?: Maybe<EducationTypeWhereInput[] | EducationTypeWhereInput>;
}

export interface ExamCenterWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  centerName?: Maybe<String>;
  centerName_not?: Maybe<String>;
  centerName_in?: Maybe<String[] | String>;
  centerName_not_in?: Maybe<String[] | String>;
  centerName_lt?: Maybe<String>;
  centerName_lte?: Maybe<String>;
  centerName_gt?: Maybe<String>;
  centerName_gte?: Maybe<String>;
  centerName_contains?: Maybe<String>;
  centerName_not_contains?: Maybe<String>;
  centerName_starts_with?: Maybe<String>;
  centerName_not_starts_with?: Maybe<String>;
  centerName_ends_with?: Maybe<String>;
  centerName_not_ends_with?: Maybe<String>;
  centerCode?: Maybe<String>;
  centerCode_not?: Maybe<String>;
  centerCode_in?: Maybe<String[] | String>;
  centerCode_not_in?: Maybe<String[] | String>;
  centerCode_lt?: Maybe<String>;
  centerCode_lte?: Maybe<String>;
  centerCode_gt?: Maybe<String>;
  centerCode_gte?: Maybe<String>;
  centerCode_contains?: Maybe<String>;
  centerCode_not_contains?: Maybe<String>;
  centerCode_starts_with?: Maybe<String>;
  centerCode_not_starts_with?: Maybe<String>;
  centerCode_ends_with?: Maybe<String>;
  centerCode_not_ends_with?: Maybe<String>;
  town?: Maybe<TownWhereInput>;
  centerNumber?: Maybe<Int>;
  centerNumber_not?: Maybe<Int>;
  centerNumber_in?: Maybe<Int[] | Int>;
  centerNumber_not_in?: Maybe<Int[] | Int>;
  centerNumber_lt?: Maybe<Int>;
  centerNumber_lte?: Maybe<Int>;
  centerNumber_gt?: Maybe<Int>;
  centerNumber_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  registration_every?: Maybe<RegistrationWhereInput>;
  registration_some?: Maybe<RegistrationWhereInput>;
  registration_none?: Maybe<RegistrationWhereInput>;
  centerAdmin_every?: Maybe<CenterAdminWhereInput>;
  centerAdmin_some?: Maybe<CenterAdminWhereInput>;
  centerAdmin_none?: Maybe<CenterAdminWhereInput>;
  AND?: Maybe<ExamCenterWhereInput[] | ExamCenterWhereInput>;
  OR?: Maybe<ExamCenterWhereInput[] | ExamCenterWhereInput>;
  NOT?: Maybe<ExamCenterWhereInput[] | ExamCenterWhereInput>;
}

export interface TownWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  townName?: Maybe<String>;
  townName_not?: Maybe<String>;
  townName_in?: Maybe<String[] | String>;
  townName_not_in?: Maybe<String[] | String>;
  townName_lt?: Maybe<String>;
  townName_lte?: Maybe<String>;
  townName_gt?: Maybe<String>;
  townName_gte?: Maybe<String>;
  townName_contains?: Maybe<String>;
  townName_not_contains?: Maybe<String>;
  townName_starts_with?: Maybe<String>;
  townName_not_starts_with?: Maybe<String>;
  townName_ends_with?: Maybe<String>;
  townName_not_ends_with?: Maybe<String>;
  townCode?: Maybe<String>;
  townCode_not?: Maybe<String>;
  townCode_in?: Maybe<String[] | String>;
  townCode_not_in?: Maybe<String[] | String>;
  townCode_lt?: Maybe<String>;
  townCode_lte?: Maybe<String>;
  townCode_gt?: Maybe<String>;
  townCode_gte?: Maybe<String>;
  townCode_contains?: Maybe<String>;
  townCode_not_contains?: Maybe<String>;
  townCode_starts_with?: Maybe<String>;
  townCode_not_starts_with?: Maybe<String>;
  townCode_ends_with?: Maybe<String>;
  townCode_not_ends_with?: Maybe<String>;
  subDiv?: Maybe<SubDivisionWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  center_every?: Maybe<ExamCenterWhereInput>;
  center_some?: Maybe<ExamCenterWhereInput>;
  center_none?: Maybe<ExamCenterWhereInput>;
  AND?: Maybe<TownWhereInput[] | TownWhereInput>;
  OR?: Maybe<TownWhereInput[] | TownWhereInput>;
  NOT?: Maybe<TownWhereInput[] | TownWhereInput>;
}

export interface SubDivisionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  subDivName?: Maybe<String>;
  subDivName_not?: Maybe<String>;
  subDivName_in?: Maybe<String[] | String>;
  subDivName_not_in?: Maybe<String[] | String>;
  subDivName_lt?: Maybe<String>;
  subDivName_lte?: Maybe<String>;
  subDivName_gt?: Maybe<String>;
  subDivName_gte?: Maybe<String>;
  subDivName_contains?: Maybe<String>;
  subDivName_not_contains?: Maybe<String>;
  subDivName_starts_with?: Maybe<String>;
  subDivName_not_starts_with?: Maybe<String>;
  subDivName_ends_with?: Maybe<String>;
  subDivName_not_ends_with?: Maybe<String>;
  subDivCode?: Maybe<String>;
  subDivCode_not?: Maybe<String>;
  subDivCode_in?: Maybe<String[] | String>;
  subDivCode_not_in?: Maybe<String[] | String>;
  subDivCode_lt?: Maybe<String>;
  subDivCode_lte?: Maybe<String>;
  subDivCode_gt?: Maybe<String>;
  subDivCode_gte?: Maybe<String>;
  subDivCode_contains?: Maybe<String>;
  subDivCode_not_contains?: Maybe<String>;
  subDivCode_starts_with?: Maybe<String>;
  subDivCode_not_starts_with?: Maybe<String>;
  subDivCode_ends_with?: Maybe<String>;
  subDivCode_not_ends_with?: Maybe<String>;
  division?: Maybe<DivisionWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  town_every?: Maybe<TownWhereInput>;
  town_some?: Maybe<TownWhereInput>;
  town_none?: Maybe<TownWhereInput>;
  AND?: Maybe<SubDivisionWhereInput[] | SubDivisionWhereInput>;
  OR?: Maybe<SubDivisionWhereInput[] | SubDivisionWhereInput>;
  NOT?: Maybe<SubDivisionWhereInput[] | SubDivisionWhereInput>;
}

export interface DivisionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  divName?: Maybe<String>;
  divName_not?: Maybe<String>;
  divName_in?: Maybe<String[] | String>;
  divName_not_in?: Maybe<String[] | String>;
  divName_lt?: Maybe<String>;
  divName_lte?: Maybe<String>;
  divName_gt?: Maybe<String>;
  divName_gte?: Maybe<String>;
  divName_contains?: Maybe<String>;
  divName_not_contains?: Maybe<String>;
  divName_starts_with?: Maybe<String>;
  divName_not_starts_with?: Maybe<String>;
  divName_ends_with?: Maybe<String>;
  divName_not_ends_with?: Maybe<String>;
  divCode?: Maybe<String>;
  divCode_not?: Maybe<String>;
  divCode_in?: Maybe<String[] | String>;
  divCode_not_in?: Maybe<String[] | String>;
  divCode_lt?: Maybe<String>;
  divCode_lte?: Maybe<String>;
  divCode_gt?: Maybe<String>;
  divCode_gte?: Maybe<String>;
  divCode_contains?: Maybe<String>;
  divCode_not_contains?: Maybe<String>;
  divCode_starts_with?: Maybe<String>;
  divCode_not_starts_with?: Maybe<String>;
  divCode_ends_with?: Maybe<String>;
  divCode_not_ends_with?: Maybe<String>;
  region?: Maybe<RegionWhereInput>;
  subDivision_every?: Maybe<SubDivisionWhereInput>;
  subDivision_some?: Maybe<SubDivisionWhereInput>;
  subDivision_none?: Maybe<SubDivisionWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DivisionWhereInput[] | DivisionWhereInput>;
  OR?: Maybe<DivisionWhereInput[] | DivisionWhereInput>;
  NOT?: Maybe<DivisionWhereInput[] | DivisionWhereInput>;
}

export interface RegionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  regName?: Maybe<String>;
  regName_not?: Maybe<String>;
  regName_in?: Maybe<String[] | String>;
  regName_not_in?: Maybe<String[] | String>;
  regName_lt?: Maybe<String>;
  regName_lte?: Maybe<String>;
  regName_gt?: Maybe<String>;
  regName_gte?: Maybe<String>;
  regName_contains?: Maybe<String>;
  regName_not_contains?: Maybe<String>;
  regName_starts_with?: Maybe<String>;
  regName_not_starts_with?: Maybe<String>;
  regName_ends_with?: Maybe<String>;
  regName_not_ends_with?: Maybe<String>;
  regCode?: Maybe<String>;
  regCode_not?: Maybe<String>;
  regCode_in?: Maybe<String[] | String>;
  regCode_not_in?: Maybe<String[] | String>;
  regCode_lt?: Maybe<String>;
  regCode_lte?: Maybe<String>;
  regCode_gt?: Maybe<String>;
  regCode_gte?: Maybe<String>;
  regCode_contains?: Maybe<String>;
  regCode_not_contains?: Maybe<String>;
  regCode_starts_with?: Maybe<String>;
  regCode_not_starts_with?: Maybe<String>;
  regCode_ends_with?: Maybe<String>;
  regCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  division_every?: Maybe<DivisionWhereInput>;
  division_some?: Maybe<DivisionWhereInput>;
  division_none?: Maybe<DivisionWhereInput>;
  AND?: Maybe<RegionWhereInput[] | RegionWhereInput>;
  OR?: Maybe<RegionWhereInput[] | RegionWhereInput>;
  NOT?: Maybe<RegionWhereInput[] | RegionWhereInput>;
}

export interface ScoreWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  subjectAve?: Maybe<Float>;
  subjectAve_not?: Maybe<Float>;
  subjectAve_in?: Maybe<Float[] | Float>;
  subjectAve_not_in?: Maybe<Float[] | Float>;
  subjectAve_lt?: Maybe<Float>;
  subjectAve_lte?: Maybe<Float>;
  subjectAve_gt?: Maybe<Float>;
  subjectAve_gte?: Maybe<Float>;
  subjectTotal?: Maybe<Float>;
  subjectTotal_not?: Maybe<Float>;
  subjectTotal_in?: Maybe<Float[] | Float>;
  subjectTotal_not_in?: Maybe<Float[] | Float>;
  subjectTotal_lt?: Maybe<Float>;
  subjectTotal_lte?: Maybe<Float>;
  subjectTotal_gt?: Maybe<Float>;
  subjectTotal_gte?: Maybe<Float>;
  registration?: Maybe<RegistrationWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  presence?: Maybe<PresenceWhereInput>;
  annExamSeriesSubj?: Maybe<AnnualExamSubjectSeriesWhereInput>;
  AND?: Maybe<ScoreWhereInput[] | ScoreWhereInput>;
  OR?: Maybe<ScoreWhereInput[] | ScoreWhereInput>;
  NOT?: Maybe<ScoreWhereInput[] | ScoreWhereInput>;
}

export interface PresenceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  presenceName?: Maybe<Boolean>;
  presenceName_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  score_every?: Maybe<ScoreWhereInput>;
  score_some?: Maybe<ScoreWhereInput>;
  score_none?: Maybe<ScoreWhereInput>;
  AND?: Maybe<PresenceWhereInput[] | PresenceWhereInput>;
  OR?: Maybe<PresenceWhereInput[] | PresenceWhereInput>;
  NOT?: Maybe<PresenceWhereInput[] | PresenceWhereInput>;
}

export interface ReportWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  reportName?: Maybe<String>;
  reportName_not?: Maybe<String>;
  reportName_in?: Maybe<String[] | String>;
  reportName_not_in?: Maybe<String[] | String>;
  reportName_lt?: Maybe<String>;
  reportName_lte?: Maybe<String>;
  reportName_gt?: Maybe<String>;
  reportName_gte?: Maybe<String>;
  reportName_contains?: Maybe<String>;
  reportName_not_contains?: Maybe<String>;
  reportName_starts_with?: Maybe<String>;
  reportName_not_starts_with?: Maybe<String>;
  reportName_ends_with?: Maybe<String>;
  reportName_not_ends_with?: Maybe<String>;
  reportCode?: Maybe<String>;
  reportCode_not?: Maybe<String>;
  reportCode_in?: Maybe<String[] | String>;
  reportCode_not_in?: Maybe<String[] | String>;
  reportCode_lt?: Maybe<String>;
  reportCode_lte?: Maybe<String>;
  reportCode_gt?: Maybe<String>;
  reportCode_gte?: Maybe<String>;
  reportCode_contains?: Maybe<String>;
  reportCode_not_contains?: Maybe<String>;
  reportCode_starts_with?: Maybe<String>;
  reportCode_not_starts_with?: Maybe<String>;
  reportCode_ends_with?: Maybe<String>;
  reportCode_not_ends_with?: Maybe<String>;
  centerAdmin?: Maybe<CenterAdminWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReportWhereInput[] | ReportWhereInput>;
  OR?: Maybe<ReportWhereInput[] | ReportWhereInput>;
  NOT?: Maybe<ReportWhereInput[] | ReportWhereInput>;
}

export type AnotherTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AnotherTypeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AnotherTypeWhereInput[] | AnotherTypeWhereInput>;
  OR?: Maybe<AnotherTypeWhereInput[] | AnotherTypeWhereInput>;
  NOT?: Maybe<AnotherTypeWhereInput[] | AnotherTypeWhereInput>;
}

export type CandidateWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type CenterAdminWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type DivisionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type EducationTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ExamWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ExamCenterWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  centerNumber?: Maybe<Int>;
}>;

export type GenderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  descrption?: Maybe<String>;
  descrption_not?: Maybe<String>;
  descrption_in?: Maybe<String[] | String>;
  descrption_not_in?: Maybe<String[] | String>;
  descrption_lt?: Maybe<String>;
  descrption_lte?: Maybe<String>;
  descrption_gt?: Maybe<String>;
  descrption_gte?: Maybe<String>;
  descrption_contains?: Maybe<String>;
  descrption_not_contains?: Maybe<String>;
  descrption_starts_with?: Maybe<String>;
  descrption_not_starts_with?: Maybe<String>;
  descrption_ends_with?: Maybe<String>;
  descrption_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  largeImage?: Maybe<String>;
  largeImage_not?: Maybe<String>;
  largeImage_in?: Maybe<String[] | String>;
  largeImage_not_in?: Maybe<String[] | String>;
  largeImage_lt?: Maybe<String>;
  largeImage_lte?: Maybe<String>;
  largeImage_gt?: Maybe<String>;
  largeImage_gte?: Maybe<String>;
  largeImage_contains?: Maybe<String>;
  largeImage_not_contains?: Maybe<String>;
  largeImage_starts_with?: Maybe<String>;
  largeImage_not_starts_with?: Maybe<String>;
  largeImage_ends_with?: Maybe<String>;
  largeImage_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  OR?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  NOT?: Maybe<ItemWhereInput[] | ItemWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  item_every?: Maybe<ItemWhereInput>;
  item_some?: Maybe<ItemWhereInput>;
  item_none?: Maybe<ItemWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export type PresenceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type RankWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type RegionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type RegistrationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ReportWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ScoreWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SeriesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SessionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SubDivisionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SubjectWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SubjectWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  subjName?: Maybe<String>;
  subjName_not?: Maybe<String>;
  subjName_in?: Maybe<String[] | String>;
  subjName_not_in?: Maybe<String[] | String>;
  subjName_lt?: Maybe<String>;
  subjName_lte?: Maybe<String>;
  subjName_gt?: Maybe<String>;
  subjName_gte?: Maybe<String>;
  subjName_contains?: Maybe<String>;
  subjName_not_contains?: Maybe<String>;
  subjName_starts_with?: Maybe<String>;
  subjName_not_starts_with?: Maybe<String>;
  subjName_ends_with?: Maybe<String>;
  subjName_not_ends_with?: Maybe<String>;
  subjCode?: Maybe<String>;
  subjCode_not?: Maybe<String>;
  subjCode_in?: Maybe<String[] | String>;
  subjCode_not_in?: Maybe<String[] | String>;
  subjCode_lt?: Maybe<String>;
  subjCode_lte?: Maybe<String>;
  subjCode_gt?: Maybe<String>;
  subjCode_gte?: Maybe<String>;
  subjCode_contains?: Maybe<String>;
  subjCode_not_contains?: Maybe<String>;
  subjCode_starts_with?: Maybe<String>;
  subjCode_not_starts_with?: Maybe<String>;
  subjCode_ends_with?: Maybe<String>;
  subjCode_not_ends_with?: Maybe<String>;
  annExamSeriesSubj_every?: Maybe<AnnualExamSubjectSeriesWhereInput>;
  annExamSeriesSubj_some?: Maybe<AnnualExamSubjectSeriesWhereInput>;
  annExamSeriesSubj_none?: Maybe<AnnualExamSubjectSeriesWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SubjectWhereInput[] | SubjectWhereInput>;
  OR?: Maybe<SubjectWhereInput[] | SubjectWhereInput>;
  NOT?: Maybe<SubjectWhereInput[] | SubjectWhereInput>;
}

export type TownWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AnnualExamSubjectSeriesCreateInput {
  id?: Maybe<ID_Input>;
  exam: ExamCreateOneWithoutAnnExamSeriesSubjInput;
  session: SessionCreateOneWithoutAnnExamSeriesSubjInput;
  center: ExamCenterCreateOneInput;
  rankCode: String;
  score?: Maybe<ScoreCreateManyWithoutAnnExamSeriesSubjInput>;
}

export interface ExamCreateOneWithoutAnnExamSeriesSubjInput {
  create?: Maybe<ExamCreateWithoutAnnExamSeriesSubjInput>;
  connect?: Maybe<ExamWhereUniqueInput>;
}

export interface ExamCreateWithoutAnnExamSeriesSubjInput {
  id?: Maybe<ID_Input>;
  examName: String;
  examCode: String;
  centerAdmin?: Maybe<CenterAdminCreateManyWithoutExamInput>;
  registration?: Maybe<RegistrationCreateManyWithoutExamInput>;
}

export interface CenterAdminCreateManyWithoutExamInput {
  create?: Maybe<
    CenterAdminCreateWithoutExamInput[] | CenterAdminCreateWithoutExamInput
  >;
  connect?: Maybe<CenterAdminWhereUniqueInput[] | CenterAdminWhereUniqueInput>;
}

export interface CenterAdminCreateWithoutExamInput {
  id?: Maybe<ID_Input>;
  authName: String;
  authInstitution: String;
  authPhone: Int;
  authMatricue: String;
  rank: RankCreateOneWithoutCenterAdminInput;
  session: SessionCreateOneWithoutCenterAdminInput;
  center: ExamCenterCreateOneWithoutCenterAdminInput;
  report?: Maybe<ReportCreateManyWithoutCenterAdminInput>;
}

export interface RankCreateOneWithoutCenterAdminInput {
  create?: Maybe<RankCreateWithoutCenterAdminInput>;
  connect?: Maybe<RankWhereUniqueInput>;
}

export interface RankCreateWithoutCenterAdminInput {
  id?: Maybe<ID_Input>;
  rankName: String;
  rankCode: String;
}

export interface SessionCreateOneWithoutCenterAdminInput {
  create?: Maybe<SessionCreateWithoutCenterAdminInput>;
  connect?: Maybe<SessionWhereUniqueInput>;
}

export interface SessionCreateWithoutCenterAdminInput {
  id?: Maybe<ID_Input>;
  sessionName: String;
  sessionCode: String;
  annExamSeriesSubj?: Maybe<
    AnnualExamSubjectSeriesCreateManyWithoutSessionInput
  >;
  registration?: Maybe<RegistrationCreateManyWithoutSessionInput>;
}

export interface AnnualExamSubjectSeriesCreateManyWithoutSessionInput {
  create?: Maybe<
    | AnnualExamSubjectSeriesCreateWithoutSessionInput[]
    | AnnualExamSubjectSeriesCreateWithoutSessionInput
  >;
  connect?: Maybe<
    | AnnualExamSubjectSeriesWhereUniqueInput[]
    | AnnualExamSubjectSeriesWhereUniqueInput
  >;
}

export interface AnnualExamSubjectSeriesCreateWithoutSessionInput {
  id?: Maybe<ID_Input>;
  exam: ExamCreateOneWithoutAnnExamSeriesSubjInput;
  center: ExamCenterCreateOneInput;
  rankCode: String;
  score?: Maybe<ScoreCreateManyWithoutAnnExamSeriesSubjInput>;
}

export interface ExamCenterCreateOneInput {
  create?: Maybe<ExamCenterCreateInput>;
  connect?: Maybe<ExamCenterWhereUniqueInput>;
}

export interface ExamCenterCreateInput {
  id?: Maybe<ID_Input>;
  centerName: String;
  centerCode: String;
  town: TownCreateOneWithoutCenterInput;
  centerNumber: Int;
  registration?: Maybe<RegistrationCreateManyWithoutCenterInput>;
  centerAdmin?: Maybe<CenterAdminCreateManyWithoutCenterInput>;
}

export interface TownCreateOneWithoutCenterInput {
  create?: Maybe<TownCreateWithoutCenterInput>;
  connect?: Maybe<TownWhereUniqueInput>;
}

export interface TownCreateWithoutCenterInput {
  id?: Maybe<ID_Input>;
  townName: String;
  townCode: String;
  subDiv: SubDivisionCreateOneWithoutTownInput;
}

export interface SubDivisionCreateOneWithoutTownInput {
  create?: Maybe<SubDivisionCreateWithoutTownInput>;
  connect?: Maybe<SubDivisionWhereUniqueInput>;
}

export interface SubDivisionCreateWithoutTownInput {
  id?: Maybe<ID_Input>;
  subDivName: String;
  subDivCode: String;
  division: DivisionCreateOneWithoutSubDivisionInput;
}

export interface DivisionCreateOneWithoutSubDivisionInput {
  create?: Maybe<DivisionCreateWithoutSubDivisionInput>;
  connect?: Maybe<DivisionWhereUniqueInput>;
}

export interface DivisionCreateWithoutSubDivisionInput {
  id?: Maybe<ID_Input>;
  divName: String;
  divCode: String;
  region: RegionCreateOneWithoutDivisionInput;
}

export interface RegionCreateOneWithoutDivisionInput {
  create?: Maybe<RegionCreateWithoutDivisionInput>;
  connect?: Maybe<RegionWhereUniqueInput>;
}

export interface RegionCreateWithoutDivisionInput {
  id?: Maybe<ID_Input>;
  regName: String;
  regCode: String;
}

export interface RegistrationCreateManyWithoutCenterInput {
  create?: Maybe<
    | RegistrationCreateWithoutCenterInput[]
    | RegistrationCreateWithoutCenterInput
  >;
  connect?: Maybe<
    RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput
  >;
}

export interface RegistrationCreateWithoutCenterInput {
  id?: Maybe<ID_Input>;
  candidate: CandidateCreateOneWithoutRegistrationInput;
  exam: ExamCreateOneWithoutRegistrationInput;
  series: SeriesCreateOneWithoutRegistrationInput;
  session: SessionCreateOneWithoutRegistrationInput;
}

export interface CandidateCreateOneWithoutRegistrationInput {
  create?: Maybe<CandidateCreateWithoutRegistrationInput>;
  connect?: Maybe<CandidateWhereUniqueInput>;
}

export interface CandidateCreateWithoutRegistrationInput {
  id?: Maybe<ID_Input>;
  cand1stName?: Maybe<String>;
  cand2ndName?: Maybe<String>;
  cand3rdName?: Maybe<String>;
  placeOfBirth?: Maybe<String>;
  candCode?: Maybe<String>;
  image?: Maybe<String>;
  birthCertNumber?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumb?: Maybe<Int>;
  dateOfBirth?: Maybe<DateTimeInput>;
  gender: GenderCreateOneWithoutCandidateInput;
}

export interface GenderCreateOneWithoutCandidateInput {
  create?: Maybe<GenderCreateWithoutCandidateInput>;
  connect?: Maybe<GenderWhereUniqueInput>;
}

export interface GenderCreateWithoutCandidateInput {
  id?: Maybe<ID_Input>;
  genderName: String;
  genderCode: String;
}

export interface ExamCreateOneWithoutRegistrationInput {
  create?: Maybe<ExamCreateWithoutRegistrationInput>;
  connect?: Maybe<ExamWhereUniqueInput>;
}

export interface ExamCreateWithoutRegistrationInput {
  id?: Maybe<ID_Input>;
  examName: String;
  examCode: String;
  centerAdmin?: Maybe<CenterAdminCreateManyWithoutExamInput>;
  annExamSeriesSubj?: Maybe<AnnualExamSubjectSeriesCreateManyWithoutExamInput>;
}

export interface AnnualExamSubjectSeriesCreateManyWithoutExamInput {
  create?: Maybe<
    | AnnualExamSubjectSeriesCreateWithoutExamInput[]
    | AnnualExamSubjectSeriesCreateWithoutExamInput
  >;
  connect?: Maybe<
    | AnnualExamSubjectSeriesWhereUniqueInput[]
    | AnnualExamSubjectSeriesWhereUniqueInput
  >;
}

export interface AnnualExamSubjectSeriesCreateWithoutExamInput {
  id?: Maybe<ID_Input>;
  session: SessionCreateOneWithoutAnnExamSeriesSubjInput;
  center: ExamCenterCreateOneInput;
  rankCode: String;
  score?: Maybe<ScoreCreateManyWithoutAnnExamSeriesSubjInput>;
}

export interface SessionCreateOneWithoutAnnExamSeriesSubjInput {
  create?: Maybe<SessionCreateWithoutAnnExamSeriesSubjInput>;
  connect?: Maybe<SessionWhereUniqueInput>;
}

export interface SessionCreateWithoutAnnExamSeriesSubjInput {
  id?: Maybe<ID_Input>;
  sessionName: String;
  sessionCode: String;
  centerAdmin?: Maybe<CenterAdminCreateManyWithoutSessionInput>;
  registration?: Maybe<RegistrationCreateManyWithoutSessionInput>;
}

export interface CenterAdminCreateManyWithoutSessionInput {
  create?: Maybe<
    | CenterAdminCreateWithoutSessionInput[]
    | CenterAdminCreateWithoutSessionInput
  >;
  connect?: Maybe<CenterAdminWhereUniqueInput[] | CenterAdminWhereUniqueInput>;
}

export interface CenterAdminCreateWithoutSessionInput {
  id?: Maybe<ID_Input>;
  authName: String;
  authInstitution: String;
  authPhone: Int;
  authMatricue: String;
  rank: RankCreateOneWithoutCenterAdminInput;
  exam: ExamCreateOneWithoutCenterAdminInput;
  center: ExamCenterCreateOneWithoutCenterAdminInput;
  report?: Maybe<ReportCreateManyWithoutCenterAdminInput>;
}

export interface ExamCreateOneWithoutCenterAdminInput {
  create?: Maybe<ExamCreateWithoutCenterAdminInput>;
  connect?: Maybe<ExamWhereUniqueInput>;
}

export interface ExamCreateWithoutCenterAdminInput {
  id?: Maybe<ID_Input>;
  examName: String;
  examCode: String;
  annExamSeriesSubj?: Maybe<AnnualExamSubjectSeriesCreateManyWithoutExamInput>;
  registration?: Maybe<RegistrationCreateManyWithoutExamInput>;
}

export interface RegistrationCreateManyWithoutExamInput {
  create?: Maybe<
    RegistrationCreateWithoutExamInput[] | RegistrationCreateWithoutExamInput
  >;
  connect?: Maybe<
    RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput
  >;
}

export interface RegistrationCreateWithoutExamInput {
  id?: Maybe<ID_Input>;
  candidate: CandidateCreateOneWithoutRegistrationInput;
  series: SeriesCreateOneWithoutRegistrationInput;
  session: SessionCreateOneWithoutRegistrationInput;
  center: ExamCenterCreateOneWithoutRegistrationInput;
}

export interface SeriesCreateOneWithoutRegistrationInput {
  create?: Maybe<SeriesCreateWithoutRegistrationInput>;
  connect?: Maybe<SeriesWhereUniqueInput>;
}

export interface SeriesCreateWithoutRegistrationInput {
  id?: Maybe<ID_Input>;
  seriesName: String;
  seriesCode: String;
  educationType: EducationTypeCreateOneWithoutSeriesInput;
}

export interface EducationTypeCreateOneWithoutSeriesInput {
  create?: Maybe<EducationTypeCreateWithoutSeriesInput>;
  connect?: Maybe<EducationTypeWhereUniqueInput>;
}

export interface EducationTypeCreateWithoutSeriesInput {
  id?: Maybe<ID_Input>;
  educationTypeName?: Maybe<String>;
  educationTypeCode?: Maybe<String>;
}

export interface SessionCreateOneWithoutRegistrationInput {
  create?: Maybe<SessionCreateWithoutRegistrationInput>;
  connect?: Maybe<SessionWhereUniqueInput>;
}

export interface SessionCreateWithoutRegistrationInput {
  id?: Maybe<ID_Input>;
  sessionName: String;
  sessionCode: String;
  centerAdmin?: Maybe<CenterAdminCreateManyWithoutSessionInput>;
  annExamSeriesSubj?: Maybe<
    AnnualExamSubjectSeriesCreateManyWithoutSessionInput
  >;
}

export interface ExamCenterCreateOneWithoutRegistrationInput {
  create?: Maybe<ExamCenterCreateWithoutRegistrationInput>;
  connect?: Maybe<ExamCenterWhereUniqueInput>;
}

export interface ExamCenterCreateWithoutRegistrationInput {
  id?: Maybe<ID_Input>;
  centerName: String;
  centerCode: String;
  town: TownCreateOneWithoutCenterInput;
  centerNumber: Int;
  centerAdmin?: Maybe<CenterAdminCreateManyWithoutCenterInput>;
}

export interface CenterAdminCreateManyWithoutCenterInput {
  create?: Maybe<
    CenterAdminCreateWithoutCenterInput[] | CenterAdminCreateWithoutCenterInput
  >;
  connect?: Maybe<CenterAdminWhereUniqueInput[] | CenterAdminWhereUniqueInput>;
}

export interface CenterAdminCreateWithoutCenterInput {
  id?: Maybe<ID_Input>;
  authName: String;
  authInstitution: String;
  authPhone: Int;
  authMatricue: String;
  rank: RankCreateOneWithoutCenterAdminInput;
  exam: ExamCreateOneWithoutCenterAdminInput;
  session: SessionCreateOneWithoutCenterAdminInput;
  report?: Maybe<ReportCreateManyWithoutCenterAdminInput>;
}

export interface ReportCreateManyWithoutCenterAdminInput {
  create?: Maybe<
    ReportCreateWithoutCenterAdminInput[] | ReportCreateWithoutCenterAdminInput
  >;
  connect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
}

export interface ReportCreateWithoutCenterAdminInput {
  id?: Maybe<ID_Input>;
  reportName: String;
  reportCode: String;
}

export interface ExamCenterCreateOneWithoutCenterAdminInput {
  create?: Maybe<ExamCenterCreateWithoutCenterAdminInput>;
  connect?: Maybe<ExamCenterWhereUniqueInput>;
}

export interface ExamCenterCreateWithoutCenterAdminInput {
  id?: Maybe<ID_Input>;
  centerName: String;
  centerCode: String;
  town: TownCreateOneWithoutCenterInput;
  centerNumber: Int;
  registration?: Maybe<RegistrationCreateManyWithoutCenterInput>;
}

export interface RegistrationCreateManyWithoutSessionInput {
  create?: Maybe<
    | RegistrationCreateWithoutSessionInput[]
    | RegistrationCreateWithoutSessionInput
  >;
  connect?: Maybe<
    RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput
  >;
}

export interface RegistrationCreateWithoutSessionInput {
  id?: Maybe<ID_Input>;
  candidate: CandidateCreateOneWithoutRegistrationInput;
  exam: ExamCreateOneWithoutRegistrationInput;
  series: SeriesCreateOneWithoutRegistrationInput;
  center: ExamCenterCreateOneWithoutRegistrationInput;
}

export interface ScoreCreateManyWithoutAnnExamSeriesSubjInput {
  create?: Maybe<
    | ScoreCreateWithoutAnnExamSeriesSubjInput[]
    | ScoreCreateWithoutAnnExamSeriesSubjInput
  >;
  connect?: Maybe<ScoreWhereUniqueInput[] | ScoreWhereUniqueInput>;
}

export interface ScoreCreateWithoutAnnExamSeriesSubjInput {
  id?: Maybe<ID_Input>;
  subjectAve?: Maybe<Float>;
  subjectTotal?: Maybe<Float>;
  registration: RegistrationCreateOneInput;
  presence: PresenceCreateOneWithoutScoreInput;
}

export interface RegistrationCreateOneInput {
  create?: Maybe<RegistrationCreateInput>;
  connect?: Maybe<RegistrationWhereUniqueInput>;
}

export interface RegistrationCreateInput {
  id?: Maybe<ID_Input>;
  candidate: CandidateCreateOneWithoutRegistrationInput;
  exam: ExamCreateOneWithoutRegistrationInput;
  series: SeriesCreateOneWithoutRegistrationInput;
  session: SessionCreateOneWithoutRegistrationInput;
  center: ExamCenterCreateOneWithoutRegistrationInput;
}

export interface PresenceCreateOneWithoutScoreInput {
  create?: Maybe<PresenceCreateWithoutScoreInput>;
  connect?: Maybe<PresenceWhereUniqueInput>;
}

export interface PresenceCreateWithoutScoreInput {
  id?: Maybe<ID_Input>;
  presenceName: Boolean;
}

export interface AnnualExamSubjectSeriesUpdateInput {
  exam?: Maybe<ExamUpdateOneRequiredWithoutAnnExamSeriesSubjInput>;
  session?: Maybe<SessionUpdateOneRequiredWithoutAnnExamSeriesSubjInput>;
  center?: Maybe<ExamCenterUpdateOneRequiredInput>;
  rankCode?: Maybe<String>;
  score?: Maybe<ScoreUpdateManyWithoutAnnExamSeriesSubjInput>;
}

export interface ExamUpdateOneRequiredWithoutAnnExamSeriesSubjInput {
  create?: Maybe<ExamCreateWithoutAnnExamSeriesSubjInput>;
  update?: Maybe<ExamUpdateWithoutAnnExamSeriesSubjDataInput>;
  upsert?: Maybe<ExamUpsertWithoutAnnExamSeriesSubjInput>;
  connect?: Maybe<ExamWhereUniqueInput>;
}

export interface ExamUpdateWithoutAnnExamSeriesSubjDataInput {
  examName?: Maybe<String>;
  examCode?: Maybe<String>;
  centerAdmin?: Maybe<CenterAdminUpdateManyWithoutExamInput>;
  registration?: Maybe<RegistrationUpdateManyWithoutExamInput>;
}

export interface CenterAdminUpdateManyWithoutExamInput {
  create?: Maybe<
    CenterAdminCreateWithoutExamInput[] | CenterAdminCreateWithoutExamInput
  >;
  delete?: Maybe<CenterAdminWhereUniqueInput[] | CenterAdminWhereUniqueInput>;
  connect?: Maybe<CenterAdminWhereUniqueInput[] | CenterAdminWhereUniqueInput>;
  set?: Maybe<CenterAdminWhereUniqueInput[] | CenterAdminWhereUniqueInput>;
  disconnect?: Maybe<
    CenterAdminWhereUniqueInput[] | CenterAdminWhereUniqueInput
  >;
  update?: Maybe<
    | CenterAdminUpdateWithWhereUniqueWithoutExamInput[]
    | CenterAdminUpdateWithWhereUniqueWithoutExamInput
  >;
  upsert?: Maybe<
    | CenterAdminUpsertWithWhereUniqueWithoutExamInput[]
    | CenterAdminUpsertWithWhereUniqueWithoutExamInput
  >;
  deleteMany?: Maybe<
    CenterAdminScalarWhereInput[] | CenterAdminScalarWhereInput
  >;
  updateMany?: Maybe<
    | CenterAdminUpdateManyWithWhereNestedInput[]
    | CenterAdminUpdateManyWithWhereNestedInput
  >;
}

export interface CenterAdminUpdateWithWhereUniqueWithoutExamInput {
  where: CenterAdminWhereUniqueInput;
  data: CenterAdminUpdateWithoutExamDataInput;
}

export interface CenterAdminUpdateWithoutExamDataInput {
  authName?: Maybe<String>;
  authInstitution?: Maybe<String>;
  authPhone?: Maybe<Int>;
  authMatricue?: Maybe<String>;
  rank?: Maybe<RankUpdateOneRequiredWithoutCenterAdminInput>;
  session?: Maybe<SessionUpdateOneRequiredWithoutCenterAdminInput>;
  center?: Maybe<ExamCenterUpdateOneRequiredWithoutCenterAdminInput>;
  report?: Maybe<ReportUpdateManyWithoutCenterAdminInput>;
}

export interface RankUpdateOneRequiredWithoutCenterAdminInput {
  create?: Maybe<RankCreateWithoutCenterAdminInput>;
  update?: Maybe<RankUpdateWithoutCenterAdminDataInput>;
  upsert?: Maybe<RankUpsertWithoutCenterAdminInput>;
  connect?: Maybe<RankWhereUniqueInput>;
}

export interface RankUpdateWithoutCenterAdminDataInput {
  rankName?: Maybe<String>;
  rankCode?: Maybe<String>;
}

export interface RankUpsertWithoutCenterAdminInput {
  update: RankUpdateWithoutCenterAdminDataInput;
  create: RankCreateWithoutCenterAdminInput;
}

export interface SessionUpdateOneRequiredWithoutCenterAdminInput {
  create?: Maybe<SessionCreateWithoutCenterAdminInput>;
  update?: Maybe<SessionUpdateWithoutCenterAdminDataInput>;
  upsert?: Maybe<SessionUpsertWithoutCenterAdminInput>;
  connect?: Maybe<SessionWhereUniqueInput>;
}

export interface SessionUpdateWithoutCenterAdminDataInput {
  sessionName?: Maybe<String>;
  sessionCode?: Maybe<String>;
  annExamSeriesSubj?: Maybe<
    AnnualExamSubjectSeriesUpdateManyWithoutSessionInput
  >;
  registration?: Maybe<RegistrationUpdateManyWithoutSessionInput>;
}

export interface AnnualExamSubjectSeriesUpdateManyWithoutSessionInput {
  create?: Maybe<
    | AnnualExamSubjectSeriesCreateWithoutSessionInput[]
    | AnnualExamSubjectSeriesCreateWithoutSessionInput
  >;
  delete?: Maybe<
    | AnnualExamSubjectSeriesWhereUniqueInput[]
    | AnnualExamSubjectSeriesWhereUniqueInput
  >;
  connect?: Maybe<
    | AnnualExamSubjectSeriesWhereUniqueInput[]
    | AnnualExamSubjectSeriesWhereUniqueInput
  >;
  set?: Maybe<
    | AnnualExamSubjectSeriesWhereUniqueInput[]
    | AnnualExamSubjectSeriesWhereUniqueInput
  >;
  disconnect?: Maybe<
    | AnnualExamSubjectSeriesWhereUniqueInput[]
    | AnnualExamSubjectSeriesWhereUniqueInput
  >;
  update?: Maybe<
    | AnnualExamSubjectSeriesUpdateWithWhereUniqueWithoutSessionInput[]
    | AnnualExamSubjectSeriesUpdateWithWhereUniqueWithoutSessionInput
  >;
  upsert?: Maybe<
    | AnnualExamSubjectSeriesUpsertWithWhereUniqueWithoutSessionInput[]
    | AnnualExamSubjectSeriesUpsertWithWhereUniqueWithoutSessionInput
  >;
  deleteMany?: Maybe<
    | AnnualExamSubjectSeriesScalarWhereInput[]
    | AnnualExamSubjectSeriesScalarWhereInput
  >;
  updateMany?: Maybe<
    | AnnualExamSubjectSeriesUpdateManyWithWhereNestedInput[]
    | AnnualExamSubjectSeriesUpdateManyWithWhereNestedInput
  >;
}

export interface AnnualExamSubjectSeriesUpdateWithWhereUniqueWithoutSessionInput {
  where: AnnualExamSubjectSeriesWhereUniqueInput;
  data: AnnualExamSubjectSeriesUpdateWithoutSessionDataInput;
}

export interface AnnualExamSubjectSeriesUpdateWithoutSessionDataInput {
  exam?: Maybe<ExamUpdateOneRequiredWithoutAnnExamSeriesSubjInput>;
  center?: Maybe<ExamCenterUpdateOneRequiredInput>;
  rankCode?: Maybe<String>;
  score?: Maybe<ScoreUpdateManyWithoutAnnExamSeriesSubjInput>;
}

export interface ExamCenterUpdateOneRequiredInput {
  create?: Maybe<ExamCenterCreateInput>;
  update?: Maybe<ExamCenterUpdateDataInput>;
  upsert?: Maybe<ExamCenterUpsertNestedInput>;
  connect?: Maybe<ExamCenterWhereUniqueInput>;
}

export interface ExamCenterUpdateDataInput {
  centerName?: Maybe<String>;
  centerCode?: Maybe<String>;
  town?: Maybe<TownUpdateOneRequiredWithoutCenterInput>;
  centerNumber?: Maybe<Int>;
  registration?: Maybe<RegistrationUpdateManyWithoutCenterInput>;
  centerAdmin?: Maybe<CenterAdminUpdateManyWithoutCenterInput>;
}

export interface TownUpdateOneRequiredWithoutCenterInput {
  create?: Maybe<TownCreateWithoutCenterInput>;
  update?: Maybe<TownUpdateWithoutCenterDataInput>;
  upsert?: Maybe<TownUpsertWithoutCenterInput>;
  connect?: Maybe<TownWhereUniqueInput>;
}

export interface TownUpdateWithoutCenterDataInput {
  townName?: Maybe<String>;
  townCode?: Maybe<String>;
  subDiv?: Maybe<SubDivisionUpdateOneRequiredWithoutTownInput>;
}

export interface SubDivisionUpdateOneRequiredWithoutTownInput {
  create?: Maybe<SubDivisionCreateWithoutTownInput>;
  update?: Maybe<SubDivisionUpdateWithoutTownDataInput>;
  upsert?: Maybe<SubDivisionUpsertWithoutTownInput>;
  connect?: Maybe<SubDivisionWhereUniqueInput>;
}

export interface SubDivisionUpdateWithoutTownDataInput {
  subDivName?: Maybe<String>;
  subDivCode?: Maybe<String>;
  division?: Maybe<DivisionUpdateOneRequiredWithoutSubDivisionInput>;
}

export interface DivisionUpdateOneRequiredWithoutSubDivisionInput {
  create?: Maybe<DivisionCreateWithoutSubDivisionInput>;
  update?: Maybe<DivisionUpdateWithoutSubDivisionDataInput>;
  upsert?: Maybe<DivisionUpsertWithoutSubDivisionInput>;
  connect?: Maybe<DivisionWhereUniqueInput>;
}

export interface DivisionUpdateWithoutSubDivisionDataInput {
  divName?: Maybe<String>;
  divCode?: Maybe<String>;
  region?: Maybe<RegionUpdateOneRequiredWithoutDivisionInput>;
}

export interface RegionUpdateOneRequiredWithoutDivisionInput {
  create?: Maybe<RegionCreateWithoutDivisionInput>;
  update?: Maybe<RegionUpdateWithoutDivisionDataInput>;
  upsert?: Maybe<RegionUpsertWithoutDivisionInput>;
  connect?: Maybe<RegionWhereUniqueInput>;
}

export interface RegionUpdateWithoutDivisionDataInput {
  regName?: Maybe<String>;
  regCode?: Maybe<String>;
}

export interface RegionUpsertWithoutDivisionInput {
  update: RegionUpdateWithoutDivisionDataInput;
  create: RegionCreateWithoutDivisionInput;
}

export interface DivisionUpsertWithoutSubDivisionInput {
  update: DivisionUpdateWithoutSubDivisionDataInput;
  create: DivisionCreateWithoutSubDivisionInput;
}

export interface SubDivisionUpsertWithoutTownInput {
  update: SubDivisionUpdateWithoutTownDataInput;
  create: SubDivisionCreateWithoutTownInput;
}

export interface TownUpsertWithoutCenterInput {
  update: TownUpdateWithoutCenterDataInput;
  create: TownCreateWithoutCenterInput;
}

export interface RegistrationUpdateManyWithoutCenterInput {
  create?: Maybe<
    | RegistrationCreateWithoutCenterInput[]
    | RegistrationCreateWithoutCenterInput
  >;
  delete?: Maybe<RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput>;
  connect?: Maybe<
    RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput
  >;
  set?: Maybe<RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput>;
  disconnect?: Maybe<
    RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput
  >;
  update?: Maybe<
    | RegistrationUpdateWithWhereUniqueWithoutCenterInput[]
    | RegistrationUpdateWithWhereUniqueWithoutCenterInput
  >;
  upsert?: Maybe<
    | RegistrationUpsertWithWhereUniqueWithoutCenterInput[]
    | RegistrationUpsertWithWhereUniqueWithoutCenterInput
  >;
  deleteMany?: Maybe<
    RegistrationScalarWhereInput[] | RegistrationScalarWhereInput
  >;
}

export interface RegistrationUpdateWithWhereUniqueWithoutCenterInput {
  where: RegistrationWhereUniqueInput;
  data: RegistrationUpdateWithoutCenterDataInput;
}

export interface RegistrationUpdateWithoutCenterDataInput {
  candidate?: Maybe<CandidateUpdateOneRequiredWithoutRegistrationInput>;
  exam?: Maybe<ExamUpdateOneRequiredWithoutRegistrationInput>;
  series?: Maybe<SeriesUpdateOneRequiredWithoutRegistrationInput>;
  session?: Maybe<SessionUpdateOneRequiredWithoutRegistrationInput>;
}

export interface CandidateUpdateOneRequiredWithoutRegistrationInput {
  create?: Maybe<CandidateCreateWithoutRegistrationInput>;
  update?: Maybe<CandidateUpdateWithoutRegistrationDataInput>;
  upsert?: Maybe<CandidateUpsertWithoutRegistrationInput>;
  connect?: Maybe<CandidateWhereUniqueInput>;
}

export interface CandidateUpdateWithoutRegistrationDataInput {
  cand1stName?: Maybe<String>;
  cand2ndName?: Maybe<String>;
  cand3rdName?: Maybe<String>;
  placeOfBirth?: Maybe<String>;
  candCode?: Maybe<String>;
  image?: Maybe<String>;
  birthCertNumber?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumb?: Maybe<Int>;
  dateOfBirth?: Maybe<DateTimeInput>;
  gender?: Maybe<GenderUpdateOneRequiredWithoutCandidateInput>;
}

export interface GenderUpdateOneRequiredWithoutCandidateInput {
  create?: Maybe<GenderCreateWithoutCandidateInput>;
  update?: Maybe<GenderUpdateWithoutCandidateDataInput>;
  upsert?: Maybe<GenderUpsertWithoutCandidateInput>;
  connect?: Maybe<GenderWhereUniqueInput>;
}

export interface GenderUpdateWithoutCandidateDataInput {
  genderName?: Maybe<String>;
  genderCode?: Maybe<String>;
}

export interface GenderUpsertWithoutCandidateInput {
  update: GenderUpdateWithoutCandidateDataInput;
  create: GenderCreateWithoutCandidateInput;
}

export interface CandidateUpsertWithoutRegistrationInput {
  update: CandidateUpdateWithoutRegistrationDataInput;
  create: CandidateCreateWithoutRegistrationInput;
}

export interface ExamUpdateOneRequiredWithoutRegistrationInput {
  create?: Maybe<ExamCreateWithoutRegistrationInput>;
  update?: Maybe<ExamUpdateWithoutRegistrationDataInput>;
  upsert?: Maybe<ExamUpsertWithoutRegistrationInput>;
  connect?: Maybe<ExamWhereUniqueInput>;
}

export interface ExamUpdateWithoutRegistrationDataInput {
  examName?: Maybe<String>;
  examCode?: Maybe<String>;
  centerAdmin?: Maybe<CenterAdminUpdateManyWithoutExamInput>;
  annExamSeriesSubj?: Maybe<AnnualExamSubjectSeriesUpdateManyWithoutExamInput>;
}

export interface AnnualExamSubjectSeriesUpdateManyWithoutExamInput {
  create?: Maybe<
    | AnnualExamSubjectSeriesCreateWithoutExamInput[]
    | AnnualExamSubjectSeriesCreateWithoutExamInput
  >;
  delete?: Maybe<
    | AnnualExamSubjectSeriesWhereUniqueInput[]
    | AnnualExamSubjectSeriesWhereUniqueInput
  >;
  connect?: Maybe<
    | AnnualExamSubjectSeriesWhereUniqueInput[]
    | AnnualExamSubjectSeriesWhereUniqueInput
  >;
  set?: Maybe<
    | AnnualExamSubjectSeriesWhereUniqueInput[]
    | AnnualExamSubjectSeriesWhereUniqueInput
  >;
  disconnect?: Maybe<
    | AnnualExamSubjectSeriesWhereUniqueInput[]
    | AnnualExamSubjectSeriesWhereUniqueInput
  >;
  update?: Maybe<
    | AnnualExamSubjectSeriesUpdateWithWhereUniqueWithoutExamInput[]
    | AnnualExamSubjectSeriesUpdateWithWhereUniqueWithoutExamInput
  >;
  upsert?: Maybe<
    | AnnualExamSubjectSeriesUpsertWithWhereUniqueWithoutExamInput[]
    | AnnualExamSubjectSeriesUpsertWithWhereUniqueWithoutExamInput
  >;
  deleteMany?: Maybe<
    | AnnualExamSubjectSeriesScalarWhereInput[]
    | AnnualExamSubjectSeriesScalarWhereInput
  >;
  updateMany?: Maybe<
    | AnnualExamSubjectSeriesUpdateManyWithWhereNestedInput[]
    | AnnualExamSubjectSeriesUpdateManyWithWhereNestedInput
  >;
}

export interface AnnualExamSubjectSeriesUpdateWithWhereUniqueWithoutExamInput {
  where: AnnualExamSubjectSeriesWhereUniqueInput;
  data: AnnualExamSubjectSeriesUpdateWithoutExamDataInput;
}

export interface AnnualExamSubjectSeriesUpdateWithoutExamDataInput {
  session?: Maybe<SessionUpdateOneRequiredWithoutAnnExamSeriesSubjInput>;
  center?: Maybe<ExamCenterUpdateOneRequiredInput>;
  rankCode?: Maybe<String>;
  score?: Maybe<ScoreUpdateManyWithoutAnnExamSeriesSubjInput>;
}

export interface SessionUpdateOneRequiredWithoutAnnExamSeriesSubjInput {
  create?: Maybe<SessionCreateWithoutAnnExamSeriesSubjInput>;
  update?: Maybe<SessionUpdateWithoutAnnExamSeriesSubjDataInput>;
  upsert?: Maybe<SessionUpsertWithoutAnnExamSeriesSubjInput>;
  connect?: Maybe<SessionWhereUniqueInput>;
}

export interface SessionUpdateWithoutAnnExamSeriesSubjDataInput {
  sessionName?: Maybe<String>;
  sessionCode?: Maybe<String>;
  centerAdmin?: Maybe<CenterAdminUpdateManyWithoutSessionInput>;
  registration?: Maybe<RegistrationUpdateManyWithoutSessionInput>;
}

export interface CenterAdminUpdateManyWithoutSessionInput {
  create?: Maybe<
    | CenterAdminCreateWithoutSessionInput[]
    | CenterAdminCreateWithoutSessionInput
  >;
  delete?: Maybe<CenterAdminWhereUniqueInput[] | CenterAdminWhereUniqueInput>;
  connect?: Maybe<CenterAdminWhereUniqueInput[] | CenterAdminWhereUniqueInput>;
  set?: Maybe<CenterAdminWhereUniqueInput[] | CenterAdminWhereUniqueInput>;
  disconnect?: Maybe<
    CenterAdminWhereUniqueInput[] | CenterAdminWhereUniqueInput
  >;
  update?: Maybe<
    | CenterAdminUpdateWithWhereUniqueWithoutSessionInput[]
    | CenterAdminUpdateWithWhereUniqueWithoutSessionInput
  >;
  upsert?: Maybe<
    | CenterAdminUpsertWithWhereUniqueWithoutSessionInput[]
    | CenterAdminUpsertWithWhereUniqueWithoutSessionInput
  >;
  deleteMany?: Maybe<
    CenterAdminScalarWhereInput[] | CenterAdminScalarWhereInput
  >;
  updateMany?: Maybe<
    | CenterAdminUpdateManyWithWhereNestedInput[]
    | CenterAdminUpdateManyWithWhereNestedInput
  >;
}

export interface CenterAdminUpdateWithWhereUniqueWithoutSessionInput {
  where: CenterAdminWhereUniqueInput;
  data: CenterAdminUpdateWithoutSessionDataInput;
}

export interface CenterAdminUpdateWithoutSessionDataInput {
  authName?: Maybe<String>;
  authInstitution?: Maybe<String>;
  authPhone?: Maybe<Int>;
  authMatricue?: Maybe<String>;
  rank?: Maybe<RankUpdateOneRequiredWithoutCenterAdminInput>;
  exam?: Maybe<ExamUpdateOneRequiredWithoutCenterAdminInput>;
  center?: Maybe<ExamCenterUpdateOneRequiredWithoutCenterAdminInput>;
  report?: Maybe<ReportUpdateManyWithoutCenterAdminInput>;
}

export interface ExamUpdateOneRequiredWithoutCenterAdminInput {
  create?: Maybe<ExamCreateWithoutCenterAdminInput>;
  update?: Maybe<ExamUpdateWithoutCenterAdminDataInput>;
  upsert?: Maybe<ExamUpsertWithoutCenterAdminInput>;
  connect?: Maybe<ExamWhereUniqueInput>;
}

export interface ExamUpdateWithoutCenterAdminDataInput {
  examName?: Maybe<String>;
  examCode?: Maybe<String>;
  annExamSeriesSubj?: Maybe<AnnualExamSubjectSeriesUpdateManyWithoutExamInput>;
  registration?: Maybe<RegistrationUpdateManyWithoutExamInput>;
}

export interface RegistrationUpdateManyWithoutExamInput {
  create?: Maybe<
    RegistrationCreateWithoutExamInput[] | RegistrationCreateWithoutExamInput
  >;
  delete?: Maybe<RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput>;
  connect?: Maybe<
    RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput
  >;
  set?: Maybe<RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput>;
  disconnect?: Maybe<
    RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput
  >;
  update?: Maybe<
    | RegistrationUpdateWithWhereUniqueWithoutExamInput[]
    | RegistrationUpdateWithWhereUniqueWithoutExamInput
  >;
  upsert?: Maybe<
    | RegistrationUpsertWithWhereUniqueWithoutExamInput[]
    | RegistrationUpsertWithWhereUniqueWithoutExamInput
  >;
  deleteMany?: Maybe<
    RegistrationScalarWhereInput[] | RegistrationScalarWhereInput
  >;
}

export interface RegistrationUpdateWithWhereUniqueWithoutExamInput {
  where: RegistrationWhereUniqueInput;
  data: RegistrationUpdateWithoutExamDataInput;
}

export interface RegistrationUpdateWithoutExamDataInput {
  candidate?: Maybe<CandidateUpdateOneRequiredWithoutRegistrationInput>;
  series?: Maybe<SeriesUpdateOneRequiredWithoutRegistrationInput>;
  session?: Maybe<SessionUpdateOneRequiredWithoutRegistrationInput>;
  center?: Maybe<ExamCenterUpdateOneRequiredWithoutRegistrationInput>;
}

export interface SeriesUpdateOneRequiredWithoutRegistrationInput {
  create?: Maybe<SeriesCreateWithoutRegistrationInput>;
  update?: Maybe<SeriesUpdateWithoutRegistrationDataInput>;
  upsert?: Maybe<SeriesUpsertWithoutRegistrationInput>;
  connect?: Maybe<SeriesWhereUniqueInput>;
}

export interface SeriesUpdateWithoutRegistrationDataInput {
  seriesName?: Maybe<String>;
  seriesCode?: Maybe<String>;
  educationType?: Maybe<EducationTypeUpdateOneRequiredWithoutSeriesInput>;
}

export interface EducationTypeUpdateOneRequiredWithoutSeriesInput {
  create?: Maybe<EducationTypeCreateWithoutSeriesInput>;
  update?: Maybe<EducationTypeUpdateWithoutSeriesDataInput>;
  upsert?: Maybe<EducationTypeUpsertWithoutSeriesInput>;
  connect?: Maybe<EducationTypeWhereUniqueInput>;
}

export interface EducationTypeUpdateWithoutSeriesDataInput {
  educationTypeName?: Maybe<String>;
  educationTypeCode?: Maybe<String>;
}

export interface EducationTypeUpsertWithoutSeriesInput {
  update: EducationTypeUpdateWithoutSeriesDataInput;
  create: EducationTypeCreateWithoutSeriesInput;
}

export interface SeriesUpsertWithoutRegistrationInput {
  update: SeriesUpdateWithoutRegistrationDataInput;
  create: SeriesCreateWithoutRegistrationInput;
}

export interface SessionUpdateOneRequiredWithoutRegistrationInput {
  create?: Maybe<SessionCreateWithoutRegistrationInput>;
  update?: Maybe<SessionUpdateWithoutRegistrationDataInput>;
  upsert?: Maybe<SessionUpsertWithoutRegistrationInput>;
  connect?: Maybe<SessionWhereUniqueInput>;
}

export interface SessionUpdateWithoutRegistrationDataInput {
  sessionName?: Maybe<String>;
  sessionCode?: Maybe<String>;
  centerAdmin?: Maybe<CenterAdminUpdateManyWithoutSessionInput>;
  annExamSeriesSubj?: Maybe<
    AnnualExamSubjectSeriesUpdateManyWithoutSessionInput
  >;
}

export interface SessionUpsertWithoutRegistrationInput {
  update: SessionUpdateWithoutRegistrationDataInput;
  create: SessionCreateWithoutRegistrationInput;
}

export interface ExamCenterUpdateOneRequiredWithoutRegistrationInput {
  create?: Maybe<ExamCenterCreateWithoutRegistrationInput>;
  update?: Maybe<ExamCenterUpdateWithoutRegistrationDataInput>;
  upsert?: Maybe<ExamCenterUpsertWithoutRegistrationInput>;
  connect?: Maybe<ExamCenterWhereUniqueInput>;
}

export interface ExamCenterUpdateWithoutRegistrationDataInput {
  centerName?: Maybe<String>;
  centerCode?: Maybe<String>;
  town?: Maybe<TownUpdateOneRequiredWithoutCenterInput>;
  centerNumber?: Maybe<Int>;
  centerAdmin?: Maybe<CenterAdminUpdateManyWithoutCenterInput>;
}

export interface CenterAdminUpdateManyWithoutCenterInput {
  create?: Maybe<
    CenterAdminCreateWithoutCenterInput[] | CenterAdminCreateWithoutCenterInput
  >;
  delete?: Maybe<CenterAdminWhereUniqueInput[] | CenterAdminWhereUniqueInput>;
  connect?: Maybe<CenterAdminWhereUniqueInput[] | CenterAdminWhereUniqueInput>;
  set?: Maybe<CenterAdminWhereUniqueInput[] | CenterAdminWhereUniqueInput>;
  disconnect?: Maybe<
    CenterAdminWhereUniqueInput[] | CenterAdminWhereUniqueInput
  >;
  update?: Maybe<
    | CenterAdminUpdateWithWhereUniqueWithoutCenterInput[]
    | CenterAdminUpdateWithWhereUniqueWithoutCenterInput
  >;
  upsert?: Maybe<
    | CenterAdminUpsertWithWhereUniqueWithoutCenterInput[]
    | CenterAdminUpsertWithWhereUniqueWithoutCenterInput
  >;
  deleteMany?: Maybe<
    CenterAdminScalarWhereInput[] | CenterAdminScalarWhereInput
  >;
  updateMany?: Maybe<
    | CenterAdminUpdateManyWithWhereNestedInput[]
    | CenterAdminUpdateManyWithWhereNestedInput
  >;
}

export interface CenterAdminUpdateWithWhereUniqueWithoutCenterInput {
  where: CenterAdminWhereUniqueInput;
  data: CenterAdminUpdateWithoutCenterDataInput;
}

export interface CenterAdminUpdateWithoutCenterDataInput {
  authName?: Maybe<String>;
  authInstitution?: Maybe<String>;
  authPhone?: Maybe<Int>;
  authMatricue?: Maybe<String>;
  rank?: Maybe<RankUpdateOneRequiredWithoutCenterAdminInput>;
  exam?: Maybe<ExamUpdateOneRequiredWithoutCenterAdminInput>;
  session?: Maybe<SessionUpdateOneRequiredWithoutCenterAdminInput>;
  report?: Maybe<ReportUpdateManyWithoutCenterAdminInput>;
}

export interface ReportUpdateManyWithoutCenterAdminInput {
  create?: Maybe<
    ReportCreateWithoutCenterAdminInput[] | ReportCreateWithoutCenterAdminInput
  >;
  delete?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  connect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  set?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  disconnect?: Maybe<ReportWhereUniqueInput[] | ReportWhereUniqueInput>;
  update?: Maybe<
    | ReportUpdateWithWhereUniqueWithoutCenterAdminInput[]
    | ReportUpdateWithWhereUniqueWithoutCenterAdminInput
  >;
  upsert?: Maybe<
    | ReportUpsertWithWhereUniqueWithoutCenterAdminInput[]
    | ReportUpsertWithWhereUniqueWithoutCenterAdminInput
  >;
  deleteMany?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
  updateMany?: Maybe<
    | ReportUpdateManyWithWhereNestedInput[]
    | ReportUpdateManyWithWhereNestedInput
  >;
}

export interface ReportUpdateWithWhereUniqueWithoutCenterAdminInput {
  where: ReportWhereUniqueInput;
  data: ReportUpdateWithoutCenterAdminDataInput;
}

export interface ReportUpdateWithoutCenterAdminDataInput {
  reportName?: Maybe<String>;
  reportCode?: Maybe<String>;
}

export interface ReportUpsertWithWhereUniqueWithoutCenterAdminInput {
  where: ReportWhereUniqueInput;
  update: ReportUpdateWithoutCenterAdminDataInput;
  create: ReportCreateWithoutCenterAdminInput;
}

export interface ReportScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  reportName?: Maybe<String>;
  reportName_not?: Maybe<String>;
  reportName_in?: Maybe<String[] | String>;
  reportName_not_in?: Maybe<String[] | String>;
  reportName_lt?: Maybe<String>;
  reportName_lte?: Maybe<String>;
  reportName_gt?: Maybe<String>;
  reportName_gte?: Maybe<String>;
  reportName_contains?: Maybe<String>;
  reportName_not_contains?: Maybe<String>;
  reportName_starts_with?: Maybe<String>;
  reportName_not_starts_with?: Maybe<String>;
  reportName_ends_with?: Maybe<String>;
  reportName_not_ends_with?: Maybe<String>;
  reportCode?: Maybe<String>;
  reportCode_not?: Maybe<String>;
  reportCode_in?: Maybe<String[] | String>;
  reportCode_not_in?: Maybe<String[] | String>;
  reportCode_lt?: Maybe<String>;
  reportCode_lte?: Maybe<String>;
  reportCode_gt?: Maybe<String>;
  reportCode_gte?: Maybe<String>;
  reportCode_contains?: Maybe<String>;
  reportCode_not_contains?: Maybe<String>;
  reportCode_starts_with?: Maybe<String>;
  reportCode_not_starts_with?: Maybe<String>;
  reportCode_ends_with?: Maybe<String>;
  reportCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
  OR?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
  NOT?: Maybe<ReportScalarWhereInput[] | ReportScalarWhereInput>;
}

export interface ReportUpdateManyWithWhereNestedInput {
  where: ReportScalarWhereInput;
  data: ReportUpdateManyDataInput;
}

export interface ReportUpdateManyDataInput {
  reportName?: Maybe<String>;
  reportCode?: Maybe<String>;
}

export interface CenterAdminUpsertWithWhereUniqueWithoutCenterInput {
  where: CenterAdminWhereUniqueInput;
  update: CenterAdminUpdateWithoutCenterDataInput;
  create: CenterAdminCreateWithoutCenterInput;
}

export interface CenterAdminScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  authName?: Maybe<String>;
  authName_not?: Maybe<String>;
  authName_in?: Maybe<String[] | String>;
  authName_not_in?: Maybe<String[] | String>;
  authName_lt?: Maybe<String>;
  authName_lte?: Maybe<String>;
  authName_gt?: Maybe<String>;
  authName_gte?: Maybe<String>;
  authName_contains?: Maybe<String>;
  authName_not_contains?: Maybe<String>;
  authName_starts_with?: Maybe<String>;
  authName_not_starts_with?: Maybe<String>;
  authName_ends_with?: Maybe<String>;
  authName_not_ends_with?: Maybe<String>;
  authInstitution?: Maybe<String>;
  authInstitution_not?: Maybe<String>;
  authInstitution_in?: Maybe<String[] | String>;
  authInstitution_not_in?: Maybe<String[] | String>;
  authInstitution_lt?: Maybe<String>;
  authInstitution_lte?: Maybe<String>;
  authInstitution_gt?: Maybe<String>;
  authInstitution_gte?: Maybe<String>;
  authInstitution_contains?: Maybe<String>;
  authInstitution_not_contains?: Maybe<String>;
  authInstitution_starts_with?: Maybe<String>;
  authInstitution_not_starts_with?: Maybe<String>;
  authInstitution_ends_with?: Maybe<String>;
  authInstitution_not_ends_with?: Maybe<String>;
  authPhone?: Maybe<Int>;
  authPhone_not?: Maybe<Int>;
  authPhone_in?: Maybe<Int[] | Int>;
  authPhone_not_in?: Maybe<Int[] | Int>;
  authPhone_lt?: Maybe<Int>;
  authPhone_lte?: Maybe<Int>;
  authPhone_gt?: Maybe<Int>;
  authPhone_gte?: Maybe<Int>;
  authMatricue?: Maybe<String>;
  authMatricue_not?: Maybe<String>;
  authMatricue_in?: Maybe<String[] | String>;
  authMatricue_not_in?: Maybe<String[] | String>;
  authMatricue_lt?: Maybe<String>;
  authMatricue_lte?: Maybe<String>;
  authMatricue_gt?: Maybe<String>;
  authMatricue_gte?: Maybe<String>;
  authMatricue_contains?: Maybe<String>;
  authMatricue_not_contains?: Maybe<String>;
  authMatricue_starts_with?: Maybe<String>;
  authMatricue_not_starts_with?: Maybe<String>;
  authMatricue_ends_with?: Maybe<String>;
  authMatricue_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CenterAdminScalarWhereInput[] | CenterAdminScalarWhereInput>;
  OR?: Maybe<CenterAdminScalarWhereInput[] | CenterAdminScalarWhereInput>;
  NOT?: Maybe<CenterAdminScalarWhereInput[] | CenterAdminScalarWhereInput>;
}

export interface CenterAdminUpdateManyWithWhereNestedInput {
  where: CenterAdminScalarWhereInput;
  data: CenterAdminUpdateManyDataInput;
}

export interface CenterAdminUpdateManyDataInput {
  authName?: Maybe<String>;
  authInstitution?: Maybe<String>;
  authPhone?: Maybe<Int>;
  authMatricue?: Maybe<String>;
}

export interface ExamCenterUpsertWithoutRegistrationInput {
  update: ExamCenterUpdateWithoutRegistrationDataInput;
  create: ExamCenterCreateWithoutRegistrationInput;
}

export interface RegistrationUpsertWithWhereUniqueWithoutExamInput {
  where: RegistrationWhereUniqueInput;
  update: RegistrationUpdateWithoutExamDataInput;
  create: RegistrationCreateWithoutExamInput;
}

export interface RegistrationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<RegistrationScalarWhereInput[] | RegistrationScalarWhereInput>;
  OR?: Maybe<RegistrationScalarWhereInput[] | RegistrationScalarWhereInput>;
  NOT?: Maybe<RegistrationScalarWhereInput[] | RegistrationScalarWhereInput>;
}

export interface ExamUpsertWithoutCenterAdminInput {
  update: ExamUpdateWithoutCenterAdminDataInput;
  create: ExamCreateWithoutCenterAdminInput;
}

export interface ExamCenterUpdateOneRequiredWithoutCenterAdminInput {
  create?: Maybe<ExamCenterCreateWithoutCenterAdminInput>;
  update?: Maybe<ExamCenterUpdateWithoutCenterAdminDataInput>;
  upsert?: Maybe<ExamCenterUpsertWithoutCenterAdminInput>;
  connect?: Maybe<ExamCenterWhereUniqueInput>;
}

export interface ExamCenterUpdateWithoutCenterAdminDataInput {
  centerName?: Maybe<String>;
  centerCode?: Maybe<String>;
  town?: Maybe<TownUpdateOneRequiredWithoutCenterInput>;
  centerNumber?: Maybe<Int>;
  registration?: Maybe<RegistrationUpdateManyWithoutCenterInput>;
}

export interface ExamCenterUpsertWithoutCenterAdminInput {
  update: ExamCenterUpdateWithoutCenterAdminDataInput;
  create: ExamCenterCreateWithoutCenterAdminInput;
}

export interface CenterAdminUpsertWithWhereUniqueWithoutSessionInput {
  where: CenterAdminWhereUniqueInput;
  update: CenterAdminUpdateWithoutSessionDataInput;
  create: CenterAdminCreateWithoutSessionInput;
}

export interface RegistrationUpdateManyWithoutSessionInput {
  create?: Maybe<
    | RegistrationCreateWithoutSessionInput[]
    | RegistrationCreateWithoutSessionInput
  >;
  delete?: Maybe<RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput>;
  connect?: Maybe<
    RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput
  >;
  set?: Maybe<RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput>;
  disconnect?: Maybe<
    RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput
  >;
  update?: Maybe<
    | RegistrationUpdateWithWhereUniqueWithoutSessionInput[]
    | RegistrationUpdateWithWhereUniqueWithoutSessionInput
  >;
  upsert?: Maybe<
    | RegistrationUpsertWithWhereUniqueWithoutSessionInput[]
    | RegistrationUpsertWithWhereUniqueWithoutSessionInput
  >;
  deleteMany?: Maybe<
    RegistrationScalarWhereInput[] | RegistrationScalarWhereInput
  >;
}

export interface RegistrationUpdateWithWhereUniqueWithoutSessionInput {
  where: RegistrationWhereUniqueInput;
  data: RegistrationUpdateWithoutSessionDataInput;
}

export interface RegistrationUpdateWithoutSessionDataInput {
  candidate?: Maybe<CandidateUpdateOneRequiredWithoutRegistrationInput>;
  exam?: Maybe<ExamUpdateOneRequiredWithoutRegistrationInput>;
  series?: Maybe<SeriesUpdateOneRequiredWithoutRegistrationInput>;
  center?: Maybe<ExamCenterUpdateOneRequiredWithoutRegistrationInput>;
}

export interface RegistrationUpsertWithWhereUniqueWithoutSessionInput {
  where: RegistrationWhereUniqueInput;
  update: RegistrationUpdateWithoutSessionDataInput;
  create: RegistrationCreateWithoutSessionInput;
}

export interface SessionUpsertWithoutAnnExamSeriesSubjInput {
  update: SessionUpdateWithoutAnnExamSeriesSubjDataInput;
  create: SessionCreateWithoutAnnExamSeriesSubjInput;
}

export interface ScoreUpdateManyWithoutAnnExamSeriesSubjInput {
  create?: Maybe<
    | ScoreCreateWithoutAnnExamSeriesSubjInput[]
    | ScoreCreateWithoutAnnExamSeriesSubjInput
  >;
  delete?: Maybe<ScoreWhereUniqueInput[] | ScoreWhereUniqueInput>;
  connect?: Maybe<ScoreWhereUniqueInput[] | ScoreWhereUniqueInput>;
  set?: Maybe<ScoreWhereUniqueInput[] | ScoreWhereUniqueInput>;
  disconnect?: Maybe<ScoreWhereUniqueInput[] | ScoreWhereUniqueInput>;
  update?: Maybe<
    | ScoreUpdateWithWhereUniqueWithoutAnnExamSeriesSubjInput[]
    | ScoreUpdateWithWhereUniqueWithoutAnnExamSeriesSubjInput
  >;
  upsert?: Maybe<
    | ScoreUpsertWithWhereUniqueWithoutAnnExamSeriesSubjInput[]
    | ScoreUpsertWithWhereUniqueWithoutAnnExamSeriesSubjInput
  >;
  deleteMany?: Maybe<ScoreScalarWhereInput[] | ScoreScalarWhereInput>;
  updateMany?: Maybe<
    ScoreUpdateManyWithWhereNestedInput[] | ScoreUpdateManyWithWhereNestedInput
  >;
}

export interface ScoreUpdateWithWhereUniqueWithoutAnnExamSeriesSubjInput {
  where: ScoreWhereUniqueInput;
  data: ScoreUpdateWithoutAnnExamSeriesSubjDataInput;
}

export interface ScoreUpdateWithoutAnnExamSeriesSubjDataInput {
  subjectAve?: Maybe<Float>;
  subjectTotal?: Maybe<Float>;
  registration?: Maybe<RegistrationUpdateOneRequiredInput>;
  presence?: Maybe<PresenceUpdateOneRequiredWithoutScoreInput>;
}

export interface RegistrationUpdateOneRequiredInput {
  create?: Maybe<RegistrationCreateInput>;
  update?: Maybe<RegistrationUpdateDataInput>;
  upsert?: Maybe<RegistrationUpsertNestedInput>;
  connect?: Maybe<RegistrationWhereUniqueInput>;
}

export interface RegistrationUpdateDataInput {
  candidate?: Maybe<CandidateUpdateOneRequiredWithoutRegistrationInput>;
  exam?: Maybe<ExamUpdateOneRequiredWithoutRegistrationInput>;
  series?: Maybe<SeriesUpdateOneRequiredWithoutRegistrationInput>;
  session?: Maybe<SessionUpdateOneRequiredWithoutRegistrationInput>;
  center?: Maybe<ExamCenterUpdateOneRequiredWithoutRegistrationInput>;
}

export interface RegistrationUpsertNestedInput {
  update: RegistrationUpdateDataInput;
  create: RegistrationCreateInput;
}

export interface PresenceUpdateOneRequiredWithoutScoreInput {
  create?: Maybe<PresenceCreateWithoutScoreInput>;
  update?: Maybe<PresenceUpdateWithoutScoreDataInput>;
  upsert?: Maybe<PresenceUpsertWithoutScoreInput>;
  connect?: Maybe<PresenceWhereUniqueInput>;
}

export interface PresenceUpdateWithoutScoreDataInput {
  presenceName?: Maybe<Boolean>;
}

export interface PresenceUpsertWithoutScoreInput {
  update: PresenceUpdateWithoutScoreDataInput;
  create: PresenceCreateWithoutScoreInput;
}

export interface ScoreUpsertWithWhereUniqueWithoutAnnExamSeriesSubjInput {
  where: ScoreWhereUniqueInput;
  update: ScoreUpdateWithoutAnnExamSeriesSubjDataInput;
  create: ScoreCreateWithoutAnnExamSeriesSubjInput;
}

export interface ScoreScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  subjectAve?: Maybe<Float>;
  subjectAve_not?: Maybe<Float>;
  subjectAve_in?: Maybe<Float[] | Float>;
  subjectAve_not_in?: Maybe<Float[] | Float>;
  subjectAve_lt?: Maybe<Float>;
  subjectAve_lte?: Maybe<Float>;
  subjectAve_gt?: Maybe<Float>;
  subjectAve_gte?: Maybe<Float>;
  subjectTotal?: Maybe<Float>;
  subjectTotal_not?: Maybe<Float>;
  subjectTotal_in?: Maybe<Float[] | Float>;
  subjectTotal_not_in?: Maybe<Float[] | Float>;
  subjectTotal_lt?: Maybe<Float>;
  subjectTotal_lte?: Maybe<Float>;
  subjectTotal_gt?: Maybe<Float>;
  subjectTotal_gte?: Maybe<Float>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ScoreScalarWhereInput[] | ScoreScalarWhereInput>;
  OR?: Maybe<ScoreScalarWhereInput[] | ScoreScalarWhereInput>;
  NOT?: Maybe<ScoreScalarWhereInput[] | ScoreScalarWhereInput>;
}

export interface ScoreUpdateManyWithWhereNestedInput {
  where: ScoreScalarWhereInput;
  data: ScoreUpdateManyDataInput;
}

export interface ScoreUpdateManyDataInput {
  subjectAve?: Maybe<Float>;
  subjectTotal?: Maybe<Float>;
}

export interface AnnualExamSubjectSeriesUpsertWithWhereUniqueWithoutExamInput {
  where: AnnualExamSubjectSeriesWhereUniqueInput;
  update: AnnualExamSubjectSeriesUpdateWithoutExamDataInput;
  create: AnnualExamSubjectSeriesCreateWithoutExamInput;
}

export interface AnnualExamSubjectSeriesScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  rankCode?: Maybe<String>;
  rankCode_not?: Maybe<String>;
  rankCode_in?: Maybe<String[] | String>;
  rankCode_not_in?: Maybe<String[] | String>;
  rankCode_lt?: Maybe<String>;
  rankCode_lte?: Maybe<String>;
  rankCode_gt?: Maybe<String>;
  rankCode_gte?: Maybe<String>;
  rankCode_contains?: Maybe<String>;
  rankCode_not_contains?: Maybe<String>;
  rankCode_starts_with?: Maybe<String>;
  rankCode_not_starts_with?: Maybe<String>;
  rankCode_ends_with?: Maybe<String>;
  rankCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    | AnnualExamSubjectSeriesScalarWhereInput[]
    | AnnualExamSubjectSeriesScalarWhereInput
  >;
  OR?: Maybe<
    | AnnualExamSubjectSeriesScalarWhereInput[]
    | AnnualExamSubjectSeriesScalarWhereInput
  >;
  NOT?: Maybe<
    | AnnualExamSubjectSeriesScalarWhereInput[]
    | AnnualExamSubjectSeriesScalarWhereInput
  >;
}

export interface AnnualExamSubjectSeriesUpdateManyWithWhereNestedInput {
  where: AnnualExamSubjectSeriesScalarWhereInput;
  data: AnnualExamSubjectSeriesUpdateManyDataInput;
}

export interface AnnualExamSubjectSeriesUpdateManyDataInput {
  rankCode?: Maybe<String>;
}

export interface ExamUpsertWithoutRegistrationInput {
  update: ExamUpdateWithoutRegistrationDataInput;
  create: ExamCreateWithoutRegistrationInput;
}

export interface RegistrationUpsertWithWhereUniqueWithoutCenterInput {
  where: RegistrationWhereUniqueInput;
  update: RegistrationUpdateWithoutCenterDataInput;
  create: RegistrationCreateWithoutCenterInput;
}

export interface ExamCenterUpsertNestedInput {
  update: ExamCenterUpdateDataInput;
  create: ExamCenterCreateInput;
}

export interface AnnualExamSubjectSeriesUpsertWithWhereUniqueWithoutSessionInput {
  where: AnnualExamSubjectSeriesWhereUniqueInput;
  update: AnnualExamSubjectSeriesUpdateWithoutSessionDataInput;
  create: AnnualExamSubjectSeriesCreateWithoutSessionInput;
}

export interface SessionUpsertWithoutCenterAdminInput {
  update: SessionUpdateWithoutCenterAdminDataInput;
  create: SessionCreateWithoutCenterAdminInput;
}

export interface CenterAdminUpsertWithWhereUniqueWithoutExamInput {
  where: CenterAdminWhereUniqueInput;
  update: CenterAdminUpdateWithoutExamDataInput;
  create: CenterAdminCreateWithoutExamInput;
}

export interface ExamUpsertWithoutAnnExamSeriesSubjInput {
  update: ExamUpdateWithoutAnnExamSeriesSubjDataInput;
  create: ExamCreateWithoutAnnExamSeriesSubjInput;
}

export interface AnnualExamSubjectSeriesUpdateManyMutationInput {
  rankCode?: Maybe<String>;
}

export interface AnotherTypeCreateInput {
  id?: Maybe<ID_Input>;
}

export interface CandidateCreateInput {
  id?: Maybe<ID_Input>;
  cand1stName?: Maybe<String>;
  cand2ndName?: Maybe<String>;
  cand3rdName?: Maybe<String>;
  placeOfBirth?: Maybe<String>;
  candCode?: Maybe<String>;
  image?: Maybe<String>;
  birthCertNumber?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumb?: Maybe<Int>;
  dateOfBirth?: Maybe<DateTimeInput>;
  gender: GenderCreateOneWithoutCandidateInput;
  registration?: Maybe<RegistrationCreateManyWithoutCandidateInput>;
}

export interface RegistrationCreateManyWithoutCandidateInput {
  create?: Maybe<
    | RegistrationCreateWithoutCandidateInput[]
    | RegistrationCreateWithoutCandidateInput
  >;
  connect?: Maybe<
    RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput
  >;
}

export interface RegistrationCreateWithoutCandidateInput {
  id?: Maybe<ID_Input>;
  exam: ExamCreateOneWithoutRegistrationInput;
  series: SeriesCreateOneWithoutRegistrationInput;
  session: SessionCreateOneWithoutRegistrationInput;
  center: ExamCenterCreateOneWithoutRegistrationInput;
}

export interface CandidateUpdateInput {
  cand1stName?: Maybe<String>;
  cand2ndName?: Maybe<String>;
  cand3rdName?: Maybe<String>;
  placeOfBirth?: Maybe<String>;
  candCode?: Maybe<String>;
  image?: Maybe<String>;
  birthCertNumber?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumb?: Maybe<Int>;
  dateOfBirth?: Maybe<DateTimeInput>;
  gender?: Maybe<GenderUpdateOneRequiredWithoutCandidateInput>;
  registration?: Maybe<RegistrationUpdateManyWithoutCandidateInput>;
}

export interface RegistrationUpdateManyWithoutCandidateInput {
  create?: Maybe<
    | RegistrationCreateWithoutCandidateInput[]
    | RegistrationCreateWithoutCandidateInput
  >;
  delete?: Maybe<RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput>;
  connect?: Maybe<
    RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput
  >;
  set?: Maybe<RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput>;
  disconnect?: Maybe<
    RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput
  >;
  update?: Maybe<
    | RegistrationUpdateWithWhereUniqueWithoutCandidateInput[]
    | RegistrationUpdateWithWhereUniqueWithoutCandidateInput
  >;
  upsert?: Maybe<
    | RegistrationUpsertWithWhereUniqueWithoutCandidateInput[]
    | RegistrationUpsertWithWhereUniqueWithoutCandidateInput
  >;
  deleteMany?: Maybe<
    RegistrationScalarWhereInput[] | RegistrationScalarWhereInput
  >;
}

export interface RegistrationUpdateWithWhereUniqueWithoutCandidateInput {
  where: RegistrationWhereUniqueInput;
  data: RegistrationUpdateWithoutCandidateDataInput;
}

export interface RegistrationUpdateWithoutCandidateDataInput {
  exam?: Maybe<ExamUpdateOneRequiredWithoutRegistrationInput>;
  series?: Maybe<SeriesUpdateOneRequiredWithoutRegistrationInput>;
  session?: Maybe<SessionUpdateOneRequiredWithoutRegistrationInput>;
  center?: Maybe<ExamCenterUpdateOneRequiredWithoutRegistrationInput>;
}

export interface RegistrationUpsertWithWhereUniqueWithoutCandidateInput {
  where: RegistrationWhereUniqueInput;
  update: RegistrationUpdateWithoutCandidateDataInput;
  create: RegistrationCreateWithoutCandidateInput;
}

export interface CandidateUpdateManyMutationInput {
  cand1stName?: Maybe<String>;
  cand2ndName?: Maybe<String>;
  cand3rdName?: Maybe<String>;
  placeOfBirth?: Maybe<String>;
  candCode?: Maybe<String>;
  image?: Maybe<String>;
  birthCertNumber?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumb?: Maybe<Int>;
  dateOfBirth?: Maybe<DateTimeInput>;
}

export interface CenterAdminCreateInput {
  id?: Maybe<ID_Input>;
  authName: String;
  authInstitution: String;
  authPhone: Int;
  authMatricue: String;
  rank: RankCreateOneWithoutCenterAdminInput;
  exam: ExamCreateOneWithoutCenterAdminInput;
  session: SessionCreateOneWithoutCenterAdminInput;
  center: ExamCenterCreateOneWithoutCenterAdminInput;
  report?: Maybe<ReportCreateManyWithoutCenterAdminInput>;
}

export interface CenterAdminUpdateInput {
  authName?: Maybe<String>;
  authInstitution?: Maybe<String>;
  authPhone?: Maybe<Int>;
  authMatricue?: Maybe<String>;
  rank?: Maybe<RankUpdateOneRequiredWithoutCenterAdminInput>;
  exam?: Maybe<ExamUpdateOneRequiredWithoutCenterAdminInput>;
  session?: Maybe<SessionUpdateOneRequiredWithoutCenterAdminInput>;
  center?: Maybe<ExamCenterUpdateOneRequiredWithoutCenterAdminInput>;
  report?: Maybe<ReportUpdateManyWithoutCenterAdminInput>;
}

export interface CenterAdminUpdateManyMutationInput {
  authName?: Maybe<String>;
  authInstitution?: Maybe<String>;
  authPhone?: Maybe<Int>;
  authMatricue?: Maybe<String>;
}

export interface DivisionCreateInput {
  id?: Maybe<ID_Input>;
  divName: String;
  divCode: String;
  region: RegionCreateOneWithoutDivisionInput;
  subDivision?: Maybe<SubDivisionCreateManyWithoutDivisionInput>;
}

export interface SubDivisionCreateManyWithoutDivisionInput {
  create?: Maybe<
    | SubDivisionCreateWithoutDivisionInput[]
    | SubDivisionCreateWithoutDivisionInput
  >;
  connect?: Maybe<SubDivisionWhereUniqueInput[] | SubDivisionWhereUniqueInput>;
}

export interface SubDivisionCreateWithoutDivisionInput {
  id?: Maybe<ID_Input>;
  subDivName: String;
  subDivCode: String;
  town?: Maybe<TownCreateManyWithoutSubDivInput>;
}

export interface TownCreateManyWithoutSubDivInput {
  create?: Maybe<TownCreateWithoutSubDivInput[] | TownCreateWithoutSubDivInput>;
  connect?: Maybe<TownWhereUniqueInput[] | TownWhereUniqueInput>;
}

export interface TownCreateWithoutSubDivInput {
  id?: Maybe<ID_Input>;
  townName: String;
  townCode: String;
  center?: Maybe<ExamCenterCreateManyWithoutTownInput>;
}

export interface ExamCenterCreateManyWithoutTownInput {
  create?: Maybe<
    ExamCenterCreateWithoutTownInput[] | ExamCenterCreateWithoutTownInput
  >;
  connect?: Maybe<ExamCenterWhereUniqueInput[] | ExamCenterWhereUniqueInput>;
}

export interface ExamCenterCreateWithoutTownInput {
  id?: Maybe<ID_Input>;
  centerName: String;
  centerCode: String;
  centerNumber: Int;
  registration?: Maybe<RegistrationCreateManyWithoutCenterInput>;
  centerAdmin?: Maybe<CenterAdminCreateManyWithoutCenterInput>;
}

export interface DivisionUpdateInput {
  divName?: Maybe<String>;
  divCode?: Maybe<String>;
  region?: Maybe<RegionUpdateOneRequiredWithoutDivisionInput>;
  subDivision?: Maybe<SubDivisionUpdateManyWithoutDivisionInput>;
}

export interface SubDivisionUpdateManyWithoutDivisionInput {
  create?: Maybe<
    | SubDivisionCreateWithoutDivisionInput[]
    | SubDivisionCreateWithoutDivisionInput
  >;
  delete?: Maybe<SubDivisionWhereUniqueInput[] | SubDivisionWhereUniqueInput>;
  connect?: Maybe<SubDivisionWhereUniqueInput[] | SubDivisionWhereUniqueInput>;
  set?: Maybe<SubDivisionWhereUniqueInput[] | SubDivisionWhereUniqueInput>;
  disconnect?: Maybe<
    SubDivisionWhereUniqueInput[] | SubDivisionWhereUniqueInput
  >;
  update?: Maybe<
    | SubDivisionUpdateWithWhereUniqueWithoutDivisionInput[]
    | SubDivisionUpdateWithWhereUniqueWithoutDivisionInput
  >;
  upsert?: Maybe<
    | SubDivisionUpsertWithWhereUniqueWithoutDivisionInput[]
    | SubDivisionUpsertWithWhereUniqueWithoutDivisionInput
  >;
  deleteMany?: Maybe<
    SubDivisionScalarWhereInput[] | SubDivisionScalarWhereInput
  >;
  updateMany?: Maybe<
    | SubDivisionUpdateManyWithWhereNestedInput[]
    | SubDivisionUpdateManyWithWhereNestedInput
  >;
}

export interface SubDivisionUpdateWithWhereUniqueWithoutDivisionInput {
  where: SubDivisionWhereUniqueInput;
  data: SubDivisionUpdateWithoutDivisionDataInput;
}

export interface SubDivisionUpdateWithoutDivisionDataInput {
  subDivName?: Maybe<String>;
  subDivCode?: Maybe<String>;
  town?: Maybe<TownUpdateManyWithoutSubDivInput>;
}

export interface TownUpdateManyWithoutSubDivInput {
  create?: Maybe<TownCreateWithoutSubDivInput[] | TownCreateWithoutSubDivInput>;
  delete?: Maybe<TownWhereUniqueInput[] | TownWhereUniqueInput>;
  connect?: Maybe<TownWhereUniqueInput[] | TownWhereUniqueInput>;
  set?: Maybe<TownWhereUniqueInput[] | TownWhereUniqueInput>;
  disconnect?: Maybe<TownWhereUniqueInput[] | TownWhereUniqueInput>;
  update?: Maybe<
    | TownUpdateWithWhereUniqueWithoutSubDivInput[]
    | TownUpdateWithWhereUniqueWithoutSubDivInput
  >;
  upsert?: Maybe<
    | TownUpsertWithWhereUniqueWithoutSubDivInput[]
    | TownUpsertWithWhereUniqueWithoutSubDivInput
  >;
  deleteMany?: Maybe<TownScalarWhereInput[] | TownScalarWhereInput>;
  updateMany?: Maybe<
    TownUpdateManyWithWhereNestedInput[] | TownUpdateManyWithWhereNestedInput
  >;
}

export interface TownUpdateWithWhereUniqueWithoutSubDivInput {
  where: TownWhereUniqueInput;
  data: TownUpdateWithoutSubDivDataInput;
}

export interface TownUpdateWithoutSubDivDataInput {
  townName?: Maybe<String>;
  townCode?: Maybe<String>;
  center?: Maybe<ExamCenterUpdateManyWithoutTownInput>;
}

export interface ExamCenterUpdateManyWithoutTownInput {
  create?: Maybe<
    ExamCenterCreateWithoutTownInput[] | ExamCenterCreateWithoutTownInput
  >;
  delete?: Maybe<ExamCenterWhereUniqueInput[] | ExamCenterWhereUniqueInput>;
  connect?: Maybe<ExamCenterWhereUniqueInput[] | ExamCenterWhereUniqueInput>;
  set?: Maybe<ExamCenterWhereUniqueInput[] | ExamCenterWhereUniqueInput>;
  disconnect?: Maybe<ExamCenterWhereUniqueInput[] | ExamCenterWhereUniqueInput>;
  update?: Maybe<
    | ExamCenterUpdateWithWhereUniqueWithoutTownInput[]
    | ExamCenterUpdateWithWhereUniqueWithoutTownInput
  >;
  upsert?: Maybe<
    | ExamCenterUpsertWithWhereUniqueWithoutTownInput[]
    | ExamCenterUpsertWithWhereUniqueWithoutTownInput
  >;
  deleteMany?: Maybe<ExamCenterScalarWhereInput[] | ExamCenterScalarWhereInput>;
  updateMany?: Maybe<
    | ExamCenterUpdateManyWithWhereNestedInput[]
    | ExamCenterUpdateManyWithWhereNestedInput
  >;
}

export interface ExamCenterUpdateWithWhereUniqueWithoutTownInput {
  where: ExamCenterWhereUniqueInput;
  data: ExamCenterUpdateWithoutTownDataInput;
}

export interface ExamCenterUpdateWithoutTownDataInput {
  centerName?: Maybe<String>;
  centerCode?: Maybe<String>;
  centerNumber?: Maybe<Int>;
  registration?: Maybe<RegistrationUpdateManyWithoutCenterInput>;
  centerAdmin?: Maybe<CenterAdminUpdateManyWithoutCenterInput>;
}

export interface ExamCenterUpsertWithWhereUniqueWithoutTownInput {
  where: ExamCenterWhereUniqueInput;
  update: ExamCenterUpdateWithoutTownDataInput;
  create: ExamCenterCreateWithoutTownInput;
}

export interface ExamCenterScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  centerName?: Maybe<String>;
  centerName_not?: Maybe<String>;
  centerName_in?: Maybe<String[] | String>;
  centerName_not_in?: Maybe<String[] | String>;
  centerName_lt?: Maybe<String>;
  centerName_lte?: Maybe<String>;
  centerName_gt?: Maybe<String>;
  centerName_gte?: Maybe<String>;
  centerName_contains?: Maybe<String>;
  centerName_not_contains?: Maybe<String>;
  centerName_starts_with?: Maybe<String>;
  centerName_not_starts_with?: Maybe<String>;
  centerName_ends_with?: Maybe<String>;
  centerName_not_ends_with?: Maybe<String>;
  centerCode?: Maybe<String>;
  centerCode_not?: Maybe<String>;
  centerCode_in?: Maybe<String[] | String>;
  centerCode_not_in?: Maybe<String[] | String>;
  centerCode_lt?: Maybe<String>;
  centerCode_lte?: Maybe<String>;
  centerCode_gt?: Maybe<String>;
  centerCode_gte?: Maybe<String>;
  centerCode_contains?: Maybe<String>;
  centerCode_not_contains?: Maybe<String>;
  centerCode_starts_with?: Maybe<String>;
  centerCode_not_starts_with?: Maybe<String>;
  centerCode_ends_with?: Maybe<String>;
  centerCode_not_ends_with?: Maybe<String>;
  centerNumber?: Maybe<Int>;
  centerNumber_not?: Maybe<Int>;
  centerNumber_in?: Maybe<Int[] | Int>;
  centerNumber_not_in?: Maybe<Int[] | Int>;
  centerNumber_lt?: Maybe<Int>;
  centerNumber_lte?: Maybe<Int>;
  centerNumber_gt?: Maybe<Int>;
  centerNumber_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ExamCenterScalarWhereInput[] | ExamCenterScalarWhereInput>;
  OR?: Maybe<ExamCenterScalarWhereInput[] | ExamCenterScalarWhereInput>;
  NOT?: Maybe<ExamCenterScalarWhereInput[] | ExamCenterScalarWhereInput>;
}

export interface ExamCenterUpdateManyWithWhereNestedInput {
  where: ExamCenterScalarWhereInput;
  data: ExamCenterUpdateManyDataInput;
}

export interface ExamCenterUpdateManyDataInput {
  centerName?: Maybe<String>;
  centerCode?: Maybe<String>;
  centerNumber?: Maybe<Int>;
}

export interface TownUpsertWithWhereUniqueWithoutSubDivInput {
  where: TownWhereUniqueInput;
  update: TownUpdateWithoutSubDivDataInput;
  create: TownCreateWithoutSubDivInput;
}

export interface TownScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  townName?: Maybe<String>;
  townName_not?: Maybe<String>;
  townName_in?: Maybe<String[] | String>;
  townName_not_in?: Maybe<String[] | String>;
  townName_lt?: Maybe<String>;
  townName_lte?: Maybe<String>;
  townName_gt?: Maybe<String>;
  townName_gte?: Maybe<String>;
  townName_contains?: Maybe<String>;
  townName_not_contains?: Maybe<String>;
  townName_starts_with?: Maybe<String>;
  townName_not_starts_with?: Maybe<String>;
  townName_ends_with?: Maybe<String>;
  townName_not_ends_with?: Maybe<String>;
  townCode?: Maybe<String>;
  townCode_not?: Maybe<String>;
  townCode_in?: Maybe<String[] | String>;
  townCode_not_in?: Maybe<String[] | String>;
  townCode_lt?: Maybe<String>;
  townCode_lte?: Maybe<String>;
  townCode_gt?: Maybe<String>;
  townCode_gte?: Maybe<String>;
  townCode_contains?: Maybe<String>;
  townCode_not_contains?: Maybe<String>;
  townCode_starts_with?: Maybe<String>;
  townCode_not_starts_with?: Maybe<String>;
  townCode_ends_with?: Maybe<String>;
  townCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TownScalarWhereInput[] | TownScalarWhereInput>;
  OR?: Maybe<TownScalarWhereInput[] | TownScalarWhereInput>;
  NOT?: Maybe<TownScalarWhereInput[] | TownScalarWhereInput>;
}

export interface TownUpdateManyWithWhereNestedInput {
  where: TownScalarWhereInput;
  data: TownUpdateManyDataInput;
}

export interface TownUpdateManyDataInput {
  townName?: Maybe<String>;
  townCode?: Maybe<String>;
}

export interface SubDivisionUpsertWithWhereUniqueWithoutDivisionInput {
  where: SubDivisionWhereUniqueInput;
  update: SubDivisionUpdateWithoutDivisionDataInput;
  create: SubDivisionCreateWithoutDivisionInput;
}

export interface SubDivisionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  subDivName?: Maybe<String>;
  subDivName_not?: Maybe<String>;
  subDivName_in?: Maybe<String[] | String>;
  subDivName_not_in?: Maybe<String[] | String>;
  subDivName_lt?: Maybe<String>;
  subDivName_lte?: Maybe<String>;
  subDivName_gt?: Maybe<String>;
  subDivName_gte?: Maybe<String>;
  subDivName_contains?: Maybe<String>;
  subDivName_not_contains?: Maybe<String>;
  subDivName_starts_with?: Maybe<String>;
  subDivName_not_starts_with?: Maybe<String>;
  subDivName_ends_with?: Maybe<String>;
  subDivName_not_ends_with?: Maybe<String>;
  subDivCode?: Maybe<String>;
  subDivCode_not?: Maybe<String>;
  subDivCode_in?: Maybe<String[] | String>;
  subDivCode_not_in?: Maybe<String[] | String>;
  subDivCode_lt?: Maybe<String>;
  subDivCode_lte?: Maybe<String>;
  subDivCode_gt?: Maybe<String>;
  subDivCode_gte?: Maybe<String>;
  subDivCode_contains?: Maybe<String>;
  subDivCode_not_contains?: Maybe<String>;
  subDivCode_starts_with?: Maybe<String>;
  subDivCode_not_starts_with?: Maybe<String>;
  subDivCode_ends_with?: Maybe<String>;
  subDivCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SubDivisionScalarWhereInput[] | SubDivisionScalarWhereInput>;
  OR?: Maybe<SubDivisionScalarWhereInput[] | SubDivisionScalarWhereInput>;
  NOT?: Maybe<SubDivisionScalarWhereInput[] | SubDivisionScalarWhereInput>;
}

export interface SubDivisionUpdateManyWithWhereNestedInput {
  where: SubDivisionScalarWhereInput;
  data: SubDivisionUpdateManyDataInput;
}

export interface SubDivisionUpdateManyDataInput {
  subDivName?: Maybe<String>;
  subDivCode?: Maybe<String>;
}

export interface DivisionUpdateManyMutationInput {
  divName?: Maybe<String>;
  divCode?: Maybe<String>;
}

export interface EducationTypeCreateInput {
  id?: Maybe<ID_Input>;
  educationTypeName?: Maybe<String>;
  educationTypeCode?: Maybe<String>;
  series?: Maybe<SeriesCreateManyWithoutEducationTypeInput>;
}

export interface SeriesCreateManyWithoutEducationTypeInput {
  create?: Maybe<
    | SeriesCreateWithoutEducationTypeInput[]
    | SeriesCreateWithoutEducationTypeInput
  >;
  connect?: Maybe<SeriesWhereUniqueInput[] | SeriesWhereUniqueInput>;
}

export interface SeriesCreateWithoutEducationTypeInput {
  id?: Maybe<ID_Input>;
  seriesName: String;
  seriesCode: String;
  registration?: Maybe<RegistrationCreateManyWithoutSeriesInput>;
}

export interface RegistrationCreateManyWithoutSeriesInput {
  create?: Maybe<
    | RegistrationCreateWithoutSeriesInput[]
    | RegistrationCreateWithoutSeriesInput
  >;
  connect?: Maybe<
    RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput
  >;
}

export interface RegistrationCreateWithoutSeriesInput {
  id?: Maybe<ID_Input>;
  candidate: CandidateCreateOneWithoutRegistrationInput;
  exam: ExamCreateOneWithoutRegistrationInput;
  session: SessionCreateOneWithoutRegistrationInput;
  center: ExamCenterCreateOneWithoutRegistrationInput;
}

export interface EducationTypeUpdateInput {
  educationTypeName?: Maybe<String>;
  educationTypeCode?: Maybe<String>;
  series?: Maybe<SeriesUpdateManyWithoutEducationTypeInput>;
}

export interface SeriesUpdateManyWithoutEducationTypeInput {
  create?: Maybe<
    | SeriesCreateWithoutEducationTypeInput[]
    | SeriesCreateWithoutEducationTypeInput
  >;
  delete?: Maybe<SeriesWhereUniqueInput[] | SeriesWhereUniqueInput>;
  connect?: Maybe<SeriesWhereUniqueInput[] | SeriesWhereUniqueInput>;
  set?: Maybe<SeriesWhereUniqueInput[] | SeriesWhereUniqueInput>;
  disconnect?: Maybe<SeriesWhereUniqueInput[] | SeriesWhereUniqueInput>;
  update?: Maybe<
    | SeriesUpdateWithWhereUniqueWithoutEducationTypeInput[]
    | SeriesUpdateWithWhereUniqueWithoutEducationTypeInput
  >;
  upsert?: Maybe<
    | SeriesUpsertWithWhereUniqueWithoutEducationTypeInput[]
    | SeriesUpsertWithWhereUniqueWithoutEducationTypeInput
  >;
  deleteMany?: Maybe<SeriesScalarWhereInput[] | SeriesScalarWhereInput>;
  updateMany?: Maybe<
    | SeriesUpdateManyWithWhereNestedInput[]
    | SeriesUpdateManyWithWhereNestedInput
  >;
}

export interface SeriesUpdateWithWhereUniqueWithoutEducationTypeInput {
  where: SeriesWhereUniqueInput;
  data: SeriesUpdateWithoutEducationTypeDataInput;
}

export interface SeriesUpdateWithoutEducationTypeDataInput {
  seriesName?: Maybe<String>;
  seriesCode?: Maybe<String>;
  registration?: Maybe<RegistrationUpdateManyWithoutSeriesInput>;
}

export interface RegistrationUpdateManyWithoutSeriesInput {
  create?: Maybe<
    | RegistrationCreateWithoutSeriesInput[]
    | RegistrationCreateWithoutSeriesInput
  >;
  delete?: Maybe<RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput>;
  connect?: Maybe<
    RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput
  >;
  set?: Maybe<RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput>;
  disconnect?: Maybe<
    RegistrationWhereUniqueInput[] | RegistrationWhereUniqueInput
  >;
  update?: Maybe<
    | RegistrationUpdateWithWhereUniqueWithoutSeriesInput[]
    | RegistrationUpdateWithWhereUniqueWithoutSeriesInput
  >;
  upsert?: Maybe<
    | RegistrationUpsertWithWhereUniqueWithoutSeriesInput[]
    | RegistrationUpsertWithWhereUniqueWithoutSeriesInput
  >;
  deleteMany?: Maybe<
    RegistrationScalarWhereInput[] | RegistrationScalarWhereInput
  >;
}

export interface RegistrationUpdateWithWhereUniqueWithoutSeriesInput {
  where: RegistrationWhereUniqueInput;
  data: RegistrationUpdateWithoutSeriesDataInput;
}

export interface RegistrationUpdateWithoutSeriesDataInput {
  candidate?: Maybe<CandidateUpdateOneRequiredWithoutRegistrationInput>;
  exam?: Maybe<ExamUpdateOneRequiredWithoutRegistrationInput>;
  session?: Maybe<SessionUpdateOneRequiredWithoutRegistrationInput>;
  center?: Maybe<ExamCenterUpdateOneRequiredWithoutRegistrationInput>;
}

export interface RegistrationUpsertWithWhereUniqueWithoutSeriesInput {
  where: RegistrationWhereUniqueInput;
  update: RegistrationUpdateWithoutSeriesDataInput;
  create: RegistrationCreateWithoutSeriesInput;
}

export interface SeriesUpsertWithWhereUniqueWithoutEducationTypeInput {
  where: SeriesWhereUniqueInput;
  update: SeriesUpdateWithoutEducationTypeDataInput;
  create: SeriesCreateWithoutEducationTypeInput;
}

export interface SeriesScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  seriesName?: Maybe<String>;
  seriesName_not?: Maybe<String>;
  seriesName_in?: Maybe<String[] | String>;
  seriesName_not_in?: Maybe<String[] | String>;
  seriesName_lt?: Maybe<String>;
  seriesName_lte?: Maybe<String>;
  seriesName_gt?: Maybe<String>;
  seriesName_gte?: Maybe<String>;
  seriesName_contains?: Maybe<String>;
  seriesName_not_contains?: Maybe<String>;
  seriesName_starts_with?: Maybe<String>;
  seriesName_not_starts_with?: Maybe<String>;
  seriesName_ends_with?: Maybe<String>;
  seriesName_not_ends_with?: Maybe<String>;
  seriesCode?: Maybe<String>;
  seriesCode_not?: Maybe<String>;
  seriesCode_in?: Maybe<String[] | String>;
  seriesCode_not_in?: Maybe<String[] | String>;
  seriesCode_lt?: Maybe<String>;
  seriesCode_lte?: Maybe<String>;
  seriesCode_gt?: Maybe<String>;
  seriesCode_gte?: Maybe<String>;
  seriesCode_contains?: Maybe<String>;
  seriesCode_not_contains?: Maybe<String>;
  seriesCode_starts_with?: Maybe<String>;
  seriesCode_not_starts_with?: Maybe<String>;
  seriesCode_ends_with?: Maybe<String>;
  seriesCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SeriesScalarWhereInput[] | SeriesScalarWhereInput>;
  OR?: Maybe<SeriesScalarWhereInput[] | SeriesScalarWhereInput>;
  NOT?: Maybe<SeriesScalarWhereInput[] | SeriesScalarWhereInput>;
}

export interface SeriesUpdateManyWithWhereNestedInput {
  where: SeriesScalarWhereInput;
  data: SeriesUpdateManyDataInput;
}

export interface SeriesUpdateManyDataInput {
  seriesName?: Maybe<String>;
  seriesCode?: Maybe<String>;
}

export interface EducationTypeUpdateManyMutationInput {
  educationTypeName?: Maybe<String>;
  educationTypeCode?: Maybe<String>;
}

export interface ExamCreateInput {
  id?: Maybe<ID_Input>;
  examName: String;
  examCode: String;
  centerAdmin?: Maybe<CenterAdminCreateManyWithoutExamInput>;
  annExamSeriesSubj?: Maybe<AnnualExamSubjectSeriesCreateManyWithoutExamInput>;
  registration?: Maybe<RegistrationCreateManyWithoutExamInput>;
}

export interface ExamUpdateInput {
  examName?: Maybe<String>;
  examCode?: Maybe<String>;
  centerAdmin?: Maybe<CenterAdminUpdateManyWithoutExamInput>;
  annExamSeriesSubj?: Maybe<AnnualExamSubjectSeriesUpdateManyWithoutExamInput>;
  registration?: Maybe<RegistrationUpdateManyWithoutExamInput>;
}

export interface ExamUpdateManyMutationInput {
  examName?: Maybe<String>;
  examCode?: Maybe<String>;
}

export interface ExamCenterUpdateInput {
  centerName?: Maybe<String>;
  centerCode?: Maybe<String>;
  town?: Maybe<TownUpdateOneRequiredWithoutCenterInput>;
  centerNumber?: Maybe<Int>;
  registration?: Maybe<RegistrationUpdateManyWithoutCenterInput>;
  centerAdmin?: Maybe<CenterAdminUpdateManyWithoutCenterInput>;
}

export interface ExamCenterUpdateManyMutationInput {
  centerName?: Maybe<String>;
  centerCode?: Maybe<String>;
  centerNumber?: Maybe<Int>;
}

export interface GenderCreateInput {
  id?: Maybe<ID_Input>;
  genderName: String;
  genderCode: String;
  candidate?: Maybe<CandidateCreateManyWithoutGenderInput>;
}

export interface CandidateCreateManyWithoutGenderInput {
  create?: Maybe<
    CandidateCreateWithoutGenderInput[] | CandidateCreateWithoutGenderInput
  >;
  connect?: Maybe<CandidateWhereUniqueInput[] | CandidateWhereUniqueInput>;
}

export interface CandidateCreateWithoutGenderInput {
  id?: Maybe<ID_Input>;
  cand1stName?: Maybe<String>;
  cand2ndName?: Maybe<String>;
  cand3rdName?: Maybe<String>;
  placeOfBirth?: Maybe<String>;
  candCode?: Maybe<String>;
  image?: Maybe<String>;
  birthCertNumber?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumb?: Maybe<Int>;
  dateOfBirth?: Maybe<DateTimeInput>;
  registration?: Maybe<RegistrationCreateManyWithoutCandidateInput>;
}

export interface GenderUpdateInput {
  genderName?: Maybe<String>;
  genderCode?: Maybe<String>;
  candidate?: Maybe<CandidateUpdateManyWithoutGenderInput>;
}

export interface CandidateUpdateManyWithoutGenderInput {
  create?: Maybe<
    CandidateCreateWithoutGenderInput[] | CandidateCreateWithoutGenderInput
  >;
  delete?: Maybe<CandidateWhereUniqueInput[] | CandidateWhereUniqueInput>;
  connect?: Maybe<CandidateWhereUniqueInput[] | CandidateWhereUniqueInput>;
  set?: Maybe<CandidateWhereUniqueInput[] | CandidateWhereUniqueInput>;
  disconnect?: Maybe<CandidateWhereUniqueInput[] | CandidateWhereUniqueInput>;
  update?: Maybe<
    | CandidateUpdateWithWhereUniqueWithoutGenderInput[]
    | CandidateUpdateWithWhereUniqueWithoutGenderInput
  >;
  upsert?: Maybe<
    | CandidateUpsertWithWhereUniqueWithoutGenderInput[]
    | CandidateUpsertWithWhereUniqueWithoutGenderInput
  >;
  deleteMany?: Maybe<CandidateScalarWhereInput[] | CandidateScalarWhereInput>;
  updateMany?: Maybe<
    | CandidateUpdateManyWithWhereNestedInput[]
    | CandidateUpdateManyWithWhereNestedInput
  >;
}

export interface CandidateUpdateWithWhereUniqueWithoutGenderInput {
  where: CandidateWhereUniqueInput;
  data: CandidateUpdateWithoutGenderDataInput;
}

export interface CandidateUpdateWithoutGenderDataInput {
  cand1stName?: Maybe<String>;
  cand2ndName?: Maybe<String>;
  cand3rdName?: Maybe<String>;
  placeOfBirth?: Maybe<String>;
  candCode?: Maybe<String>;
  image?: Maybe<String>;
  birthCertNumber?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumb?: Maybe<Int>;
  dateOfBirth?: Maybe<DateTimeInput>;
  registration?: Maybe<RegistrationUpdateManyWithoutCandidateInput>;
}

export interface CandidateUpsertWithWhereUniqueWithoutGenderInput {
  where: CandidateWhereUniqueInput;
  update: CandidateUpdateWithoutGenderDataInput;
  create: CandidateCreateWithoutGenderInput;
}

export interface CandidateScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  cand1stName?: Maybe<String>;
  cand1stName_not?: Maybe<String>;
  cand1stName_in?: Maybe<String[] | String>;
  cand1stName_not_in?: Maybe<String[] | String>;
  cand1stName_lt?: Maybe<String>;
  cand1stName_lte?: Maybe<String>;
  cand1stName_gt?: Maybe<String>;
  cand1stName_gte?: Maybe<String>;
  cand1stName_contains?: Maybe<String>;
  cand1stName_not_contains?: Maybe<String>;
  cand1stName_starts_with?: Maybe<String>;
  cand1stName_not_starts_with?: Maybe<String>;
  cand1stName_ends_with?: Maybe<String>;
  cand1stName_not_ends_with?: Maybe<String>;
  cand2ndName?: Maybe<String>;
  cand2ndName_not?: Maybe<String>;
  cand2ndName_in?: Maybe<String[] | String>;
  cand2ndName_not_in?: Maybe<String[] | String>;
  cand2ndName_lt?: Maybe<String>;
  cand2ndName_lte?: Maybe<String>;
  cand2ndName_gt?: Maybe<String>;
  cand2ndName_gte?: Maybe<String>;
  cand2ndName_contains?: Maybe<String>;
  cand2ndName_not_contains?: Maybe<String>;
  cand2ndName_starts_with?: Maybe<String>;
  cand2ndName_not_starts_with?: Maybe<String>;
  cand2ndName_ends_with?: Maybe<String>;
  cand2ndName_not_ends_with?: Maybe<String>;
  cand3rdName?: Maybe<String>;
  cand3rdName_not?: Maybe<String>;
  cand3rdName_in?: Maybe<String[] | String>;
  cand3rdName_not_in?: Maybe<String[] | String>;
  cand3rdName_lt?: Maybe<String>;
  cand3rdName_lte?: Maybe<String>;
  cand3rdName_gt?: Maybe<String>;
  cand3rdName_gte?: Maybe<String>;
  cand3rdName_contains?: Maybe<String>;
  cand3rdName_not_contains?: Maybe<String>;
  cand3rdName_starts_with?: Maybe<String>;
  cand3rdName_not_starts_with?: Maybe<String>;
  cand3rdName_ends_with?: Maybe<String>;
  cand3rdName_not_ends_with?: Maybe<String>;
  placeOfBirth?: Maybe<String>;
  placeOfBirth_not?: Maybe<String>;
  placeOfBirth_in?: Maybe<String[] | String>;
  placeOfBirth_not_in?: Maybe<String[] | String>;
  placeOfBirth_lt?: Maybe<String>;
  placeOfBirth_lte?: Maybe<String>;
  placeOfBirth_gt?: Maybe<String>;
  placeOfBirth_gte?: Maybe<String>;
  placeOfBirth_contains?: Maybe<String>;
  placeOfBirth_not_contains?: Maybe<String>;
  placeOfBirth_starts_with?: Maybe<String>;
  placeOfBirth_not_starts_with?: Maybe<String>;
  placeOfBirth_ends_with?: Maybe<String>;
  placeOfBirth_not_ends_with?: Maybe<String>;
  candCode?: Maybe<String>;
  candCode_not?: Maybe<String>;
  candCode_in?: Maybe<String[] | String>;
  candCode_not_in?: Maybe<String[] | String>;
  candCode_lt?: Maybe<String>;
  candCode_lte?: Maybe<String>;
  candCode_gt?: Maybe<String>;
  candCode_gte?: Maybe<String>;
  candCode_contains?: Maybe<String>;
  candCode_not_contains?: Maybe<String>;
  candCode_starts_with?: Maybe<String>;
  candCode_not_starts_with?: Maybe<String>;
  candCode_ends_with?: Maybe<String>;
  candCode_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  birthCertNumber?: Maybe<String>;
  birthCertNumber_not?: Maybe<String>;
  birthCertNumber_in?: Maybe<String[] | String>;
  birthCertNumber_not_in?: Maybe<String[] | String>;
  birthCertNumber_lt?: Maybe<String>;
  birthCertNumber_lte?: Maybe<String>;
  birthCertNumber_gt?: Maybe<String>;
  birthCertNumber_gte?: Maybe<String>;
  birthCertNumber_contains?: Maybe<String>;
  birthCertNumber_not_contains?: Maybe<String>;
  birthCertNumber_starts_with?: Maybe<String>;
  birthCertNumber_not_starts_with?: Maybe<String>;
  birthCertNumber_ends_with?: Maybe<String>;
  birthCertNumber_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  phoneNumb?: Maybe<Int>;
  phoneNumb_not?: Maybe<Int>;
  phoneNumb_in?: Maybe<Int[] | Int>;
  phoneNumb_not_in?: Maybe<Int[] | Int>;
  phoneNumb_lt?: Maybe<Int>;
  phoneNumb_lte?: Maybe<Int>;
  phoneNumb_gt?: Maybe<Int>;
  phoneNumb_gte?: Maybe<Int>;
  dateOfBirth?: Maybe<DateTimeInput>;
  dateOfBirth_not?: Maybe<DateTimeInput>;
  dateOfBirth_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateOfBirth_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateOfBirth_lt?: Maybe<DateTimeInput>;
  dateOfBirth_lte?: Maybe<DateTimeInput>;
  dateOfBirth_gt?: Maybe<DateTimeInput>;
  dateOfBirth_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CandidateScalarWhereInput[] | CandidateScalarWhereInput>;
  OR?: Maybe<CandidateScalarWhereInput[] | CandidateScalarWhereInput>;
  NOT?: Maybe<CandidateScalarWhereInput[] | CandidateScalarWhereInput>;
}

export interface CandidateUpdateManyWithWhereNestedInput {
  where: CandidateScalarWhereInput;
  data: CandidateUpdateManyDataInput;
}

export interface CandidateUpdateManyDataInput {
  cand1stName?: Maybe<String>;
  cand2ndName?: Maybe<String>;
  cand3rdName?: Maybe<String>;
  placeOfBirth?: Maybe<String>;
  candCode?: Maybe<String>;
  image?: Maybe<String>;
  birthCertNumber?: Maybe<String>;
  email?: Maybe<String>;
  phoneNumb?: Maybe<Int>;
  dateOfBirth?: Maybe<DateTimeInput>;
}

export interface GenderUpdateManyMutationInput {
  genderName?: Maybe<String>;
  genderCode?: Maybe<String>;
}

export interface ItemCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  descrption: String;
  image?: Maybe<String>;
  largeImage?: Maybe<String>;
  user: UserCreateOneWithoutItemInput;
}

export interface UserCreateOneWithoutItemInput {
  create?: Maybe<UserCreateWithoutItemInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutItemInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
}

export interface ItemUpdateInput {
  title?: Maybe<String>;
  descrption?: Maybe<String>;
  image?: Maybe<String>;
  largeImage?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutItemInput>;
}

export interface UserUpdateOneRequiredWithoutItemInput {
  create?: Maybe<UserCreateWithoutItemInput>;
  update?: Maybe<UserUpdateWithoutItemDataInput>;
  upsert?: Maybe<UserUpsertWithoutItemInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutItemDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
}

export interface UserUpsertWithoutItemInput {
  update: UserUpdateWithoutItemDataInput;
  create: UserCreateWithoutItemInput;
}

export interface ItemUpdateManyMutationInput {
  title?: Maybe<String>;
  descrption?: Maybe<String>;
  image?: Maybe<String>;
  largeImage?: Maybe<String>;
}

export interface PresenceCreateInput {
  id?: Maybe<ID_Input>;
  presenceName: Boolean;
  score?: Maybe<ScoreCreateManyWithoutPresenceInput>;
}

export interface ScoreCreateManyWithoutPresenceInput {
  create?: Maybe<
    ScoreCreateWithoutPresenceInput[] | ScoreCreateWithoutPresenceInput
  >;
  connect?: Maybe<ScoreWhereUniqueInput[] | ScoreWhereUniqueInput>;
}

export interface ScoreCreateWithoutPresenceInput {
  id?: Maybe<ID_Input>;
  subjectAve?: Maybe<Float>;
  subjectTotal?: Maybe<Float>;
  registration: RegistrationCreateOneInput;
  annExamSeriesSubj: AnnualExamSubjectSeriesCreateOneWithoutScoreInput;
}

export interface AnnualExamSubjectSeriesCreateOneWithoutScoreInput {
  create?: Maybe<AnnualExamSubjectSeriesCreateWithoutScoreInput>;
  connect?: Maybe<AnnualExamSubjectSeriesWhereUniqueInput>;
}

export interface AnnualExamSubjectSeriesCreateWithoutScoreInput {
  id?: Maybe<ID_Input>;
  exam: ExamCreateOneWithoutAnnExamSeriesSubjInput;
  session: SessionCreateOneWithoutAnnExamSeriesSubjInput;
  center: ExamCenterCreateOneInput;
  rankCode: String;
}

export interface PresenceUpdateInput {
  presenceName?: Maybe<Boolean>;
  score?: Maybe<ScoreUpdateManyWithoutPresenceInput>;
}

export interface ScoreUpdateManyWithoutPresenceInput {
  create?: Maybe<
    ScoreCreateWithoutPresenceInput[] | ScoreCreateWithoutPresenceInput
  >;
  delete?: Maybe<ScoreWhereUniqueInput[] | ScoreWhereUniqueInput>;
  connect?: Maybe<ScoreWhereUniqueInput[] | ScoreWhereUniqueInput>;
  set?: Maybe<ScoreWhereUniqueInput[] | ScoreWhereUniqueInput>;
  disconnect?: Maybe<ScoreWhereUniqueInput[] | ScoreWhereUniqueInput>;
  update?: Maybe<
    | ScoreUpdateWithWhereUniqueWithoutPresenceInput[]
    | ScoreUpdateWithWhereUniqueWithoutPresenceInput
  >;
  upsert?: Maybe<
    | ScoreUpsertWithWhereUniqueWithoutPresenceInput[]
    | ScoreUpsertWithWhereUniqueWithoutPresenceInput
  >;
  deleteMany?: Maybe<ScoreScalarWhereInput[] | ScoreScalarWhereInput>;
  updateMany?: Maybe<
    ScoreUpdateManyWithWhereNestedInput[] | ScoreUpdateManyWithWhereNestedInput
  >;
}

export interface ScoreUpdateWithWhereUniqueWithoutPresenceInput {
  where: ScoreWhereUniqueInput;
  data: ScoreUpdateWithoutPresenceDataInput;
}

export interface ScoreUpdateWithoutPresenceDataInput {
  subjectAve?: Maybe<Float>;
  subjectTotal?: Maybe<Float>;
  registration?: Maybe<RegistrationUpdateOneRequiredInput>;
  annExamSeriesSubj?: Maybe<
    AnnualExamSubjectSeriesUpdateOneRequiredWithoutScoreInput
  >;
}

export interface AnnualExamSubjectSeriesUpdateOneRequiredWithoutScoreInput {
  create?: Maybe<AnnualExamSubjectSeriesCreateWithoutScoreInput>;
  update?: Maybe<AnnualExamSubjectSeriesUpdateWithoutScoreDataInput>;
  upsert?: Maybe<AnnualExamSubjectSeriesUpsertWithoutScoreInput>;
  connect?: Maybe<AnnualExamSubjectSeriesWhereUniqueInput>;
}

export interface AnnualExamSubjectSeriesUpdateWithoutScoreDataInput {
  exam?: Maybe<ExamUpdateOneRequiredWithoutAnnExamSeriesSubjInput>;
  session?: Maybe<SessionUpdateOneRequiredWithoutAnnExamSeriesSubjInput>;
  center?: Maybe<ExamCenterUpdateOneRequiredInput>;
  rankCode?: Maybe<String>;
}

export interface AnnualExamSubjectSeriesUpsertWithoutScoreInput {
  update: AnnualExamSubjectSeriesUpdateWithoutScoreDataInput;
  create: AnnualExamSubjectSeriesCreateWithoutScoreInput;
}

export interface ScoreUpsertWithWhereUniqueWithoutPresenceInput {
  where: ScoreWhereUniqueInput;
  update: ScoreUpdateWithoutPresenceDataInput;
  create: ScoreCreateWithoutPresenceInput;
}

export interface PresenceUpdateManyMutationInput {
  presenceName?: Maybe<Boolean>;
}

export interface RankCreateInput {
  id?: Maybe<ID_Input>;
  rankName: String;
  rankCode: String;
  centerAdmin?: Maybe<CenterAdminCreateManyWithoutRankInput>;
}

export interface CenterAdminCreateManyWithoutRankInput {
  create?: Maybe<
    CenterAdminCreateWithoutRankInput[] | CenterAdminCreateWithoutRankInput
  >;
  connect?: Maybe<CenterAdminWhereUniqueInput[] | CenterAdminWhereUniqueInput>;
}

export interface CenterAdminCreateWithoutRankInput {
  id?: Maybe<ID_Input>;
  authName: String;
  authInstitution: String;
  authPhone: Int;
  authMatricue: String;
  exam: ExamCreateOneWithoutCenterAdminInput;
  session: SessionCreateOneWithoutCenterAdminInput;
  center: ExamCenterCreateOneWithoutCenterAdminInput;
  report?: Maybe<ReportCreateManyWithoutCenterAdminInput>;
}

export interface RankUpdateInput {
  rankName?: Maybe<String>;
  rankCode?: Maybe<String>;
  centerAdmin?: Maybe<CenterAdminUpdateManyWithoutRankInput>;
}

export interface CenterAdminUpdateManyWithoutRankInput {
  create?: Maybe<
    CenterAdminCreateWithoutRankInput[] | CenterAdminCreateWithoutRankInput
  >;
  delete?: Maybe<CenterAdminWhereUniqueInput[] | CenterAdminWhereUniqueInput>;
  connect?: Maybe<CenterAdminWhereUniqueInput[] | CenterAdminWhereUniqueInput>;
  set?: Maybe<CenterAdminWhereUniqueInput[] | CenterAdminWhereUniqueInput>;
  disconnect?: Maybe<
    CenterAdminWhereUniqueInput[] | CenterAdminWhereUniqueInput
  >;
  update?: Maybe<
    | CenterAdminUpdateWithWhereUniqueWithoutRankInput[]
    | CenterAdminUpdateWithWhereUniqueWithoutRankInput
  >;
  upsert?: Maybe<
    | CenterAdminUpsertWithWhereUniqueWithoutRankInput[]
    | CenterAdminUpsertWithWhereUniqueWithoutRankInput
  >;
  deleteMany?: Maybe<
    CenterAdminScalarWhereInput[] | CenterAdminScalarWhereInput
  >;
  updateMany?: Maybe<
    | CenterAdminUpdateManyWithWhereNestedInput[]
    | CenterAdminUpdateManyWithWhereNestedInput
  >;
}

export interface CenterAdminUpdateWithWhereUniqueWithoutRankInput {
  where: CenterAdminWhereUniqueInput;
  data: CenterAdminUpdateWithoutRankDataInput;
}

export interface CenterAdminUpdateWithoutRankDataInput {
  authName?: Maybe<String>;
  authInstitution?: Maybe<String>;
  authPhone?: Maybe<Int>;
  authMatricue?: Maybe<String>;
  exam?: Maybe<ExamUpdateOneRequiredWithoutCenterAdminInput>;
  session?: Maybe<SessionUpdateOneRequiredWithoutCenterAdminInput>;
  center?: Maybe<ExamCenterUpdateOneRequiredWithoutCenterAdminInput>;
  report?: Maybe<ReportUpdateManyWithoutCenterAdminInput>;
}

export interface CenterAdminUpsertWithWhereUniqueWithoutRankInput {
  where: CenterAdminWhereUniqueInput;
  update: CenterAdminUpdateWithoutRankDataInput;
  create: CenterAdminCreateWithoutRankInput;
}

export interface RankUpdateManyMutationInput {
  rankName?: Maybe<String>;
  rankCode?: Maybe<String>;
}

export interface RegionCreateInput {
  id?: Maybe<ID_Input>;
  regName: String;
  regCode: String;
  division?: Maybe<DivisionCreateManyWithoutRegionInput>;
}

export interface DivisionCreateManyWithoutRegionInput {
  create?: Maybe<
    DivisionCreateWithoutRegionInput[] | DivisionCreateWithoutRegionInput
  >;
  connect?: Maybe<DivisionWhereUniqueInput[] | DivisionWhereUniqueInput>;
}

export interface DivisionCreateWithoutRegionInput {
  id?: Maybe<ID_Input>;
  divName: String;
  divCode: String;
  subDivision?: Maybe<SubDivisionCreateManyWithoutDivisionInput>;
}

export interface RegionUpdateInput {
  regName?: Maybe<String>;
  regCode?: Maybe<String>;
  division?: Maybe<DivisionUpdateManyWithoutRegionInput>;
}

export interface DivisionUpdateManyWithoutRegionInput {
  create?: Maybe<
    DivisionCreateWithoutRegionInput[] | DivisionCreateWithoutRegionInput
  >;
  delete?: Maybe<DivisionWhereUniqueInput[] | DivisionWhereUniqueInput>;
  connect?: Maybe<DivisionWhereUniqueInput[] | DivisionWhereUniqueInput>;
  set?: Maybe<DivisionWhereUniqueInput[] | DivisionWhereUniqueInput>;
  disconnect?: Maybe<DivisionWhereUniqueInput[] | DivisionWhereUniqueInput>;
  update?: Maybe<
    | DivisionUpdateWithWhereUniqueWithoutRegionInput[]
    | DivisionUpdateWithWhereUniqueWithoutRegionInput
  >;
  upsert?: Maybe<
    | DivisionUpsertWithWhereUniqueWithoutRegionInput[]
    | DivisionUpsertWithWhereUniqueWithoutRegionInput
  >;
  deleteMany?: Maybe<DivisionScalarWhereInput[] | DivisionScalarWhereInput>;
  updateMany?: Maybe<
    | DivisionUpdateManyWithWhereNestedInput[]
    | DivisionUpdateManyWithWhereNestedInput
  >;
}

export interface DivisionUpdateWithWhereUniqueWithoutRegionInput {
  where: DivisionWhereUniqueInput;
  data: DivisionUpdateWithoutRegionDataInput;
}

export interface DivisionUpdateWithoutRegionDataInput {
  divName?: Maybe<String>;
  divCode?: Maybe<String>;
  subDivision?: Maybe<SubDivisionUpdateManyWithoutDivisionInput>;
}

export interface DivisionUpsertWithWhereUniqueWithoutRegionInput {
  where: DivisionWhereUniqueInput;
  update: DivisionUpdateWithoutRegionDataInput;
  create: DivisionCreateWithoutRegionInput;
}

export interface DivisionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  divName?: Maybe<String>;
  divName_not?: Maybe<String>;
  divName_in?: Maybe<String[] | String>;
  divName_not_in?: Maybe<String[] | String>;
  divName_lt?: Maybe<String>;
  divName_lte?: Maybe<String>;
  divName_gt?: Maybe<String>;
  divName_gte?: Maybe<String>;
  divName_contains?: Maybe<String>;
  divName_not_contains?: Maybe<String>;
  divName_starts_with?: Maybe<String>;
  divName_not_starts_with?: Maybe<String>;
  divName_ends_with?: Maybe<String>;
  divName_not_ends_with?: Maybe<String>;
  divCode?: Maybe<String>;
  divCode_not?: Maybe<String>;
  divCode_in?: Maybe<String[] | String>;
  divCode_not_in?: Maybe<String[] | String>;
  divCode_lt?: Maybe<String>;
  divCode_lte?: Maybe<String>;
  divCode_gt?: Maybe<String>;
  divCode_gte?: Maybe<String>;
  divCode_contains?: Maybe<String>;
  divCode_not_contains?: Maybe<String>;
  divCode_starts_with?: Maybe<String>;
  divCode_not_starts_with?: Maybe<String>;
  divCode_ends_with?: Maybe<String>;
  divCode_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DivisionScalarWhereInput[] | DivisionScalarWhereInput>;
  OR?: Maybe<DivisionScalarWhereInput[] | DivisionScalarWhereInput>;
  NOT?: Maybe<DivisionScalarWhereInput[] | DivisionScalarWhereInput>;
}

export interface DivisionUpdateManyWithWhereNestedInput {
  where: DivisionScalarWhereInput;
  data: DivisionUpdateManyDataInput;
}

export interface DivisionUpdateManyDataInput {
  divName?: Maybe<String>;
  divCode?: Maybe<String>;
}

export interface RegionUpdateManyMutationInput {
  regName?: Maybe<String>;
  regCode?: Maybe<String>;
}

export interface RegistrationUpdateInput {
  candidate?: Maybe<CandidateUpdateOneRequiredWithoutRegistrationInput>;
  exam?: Maybe<ExamUpdateOneRequiredWithoutRegistrationInput>;
  series?: Maybe<SeriesUpdateOneRequiredWithoutRegistrationInput>;
  session?: Maybe<SessionUpdateOneRequiredWithoutRegistrationInput>;
  center?: Maybe<ExamCenterUpdateOneRequiredWithoutRegistrationInput>;
}

export interface ReportCreateInput {
  id?: Maybe<ID_Input>;
  reportName: String;
  reportCode: String;
  centerAdmin: CenterAdminCreateOneWithoutReportInput;
}

export interface CenterAdminCreateOneWithoutReportInput {
  create?: Maybe<CenterAdminCreateWithoutReportInput>;
  connect?: Maybe<CenterAdminWhereUniqueInput>;
}

export interface CenterAdminCreateWithoutReportInput {
  id?: Maybe<ID_Input>;
  authName: String;
  authInstitution: String;
  authPhone: Int;
  authMatricue: String;
  rank: RankCreateOneWithoutCenterAdminInput;
  exam: ExamCreateOneWithoutCenterAdminInput;
  session: SessionCreateOneWithoutCenterAdminInput;
  center: ExamCenterCreateOneWithoutCenterAdminInput;
}

export interface ReportUpdateInput {
  reportName?: Maybe<String>;
  reportCode?: Maybe<String>;
  centerAdmin?: Maybe<CenterAdminUpdateOneRequiredWithoutReportInput>;
}

export interface CenterAdminUpdateOneRequiredWithoutReportInput {
  create?: Maybe<CenterAdminCreateWithoutReportInput>;
  update?: Maybe<CenterAdminUpdateWithoutReportDataInput>;
  upsert?: Maybe<CenterAdminUpsertWithoutReportInput>;
  connect?: Maybe<CenterAdminWhereUniqueInput>;
}

export interface CenterAdminUpdateWithoutReportDataInput {
  authName?: Maybe<String>;
  authInstitution?: Maybe<String>;
  authPhone?: Maybe<Int>;
  authMatricue?: Maybe<String>;
  rank?: Maybe<RankUpdateOneRequiredWithoutCenterAdminInput>;
  exam?: Maybe<ExamUpdateOneRequiredWithoutCenterAdminInput>;
  session?: Maybe<SessionUpdateOneRequiredWithoutCenterAdminInput>;
  center?: Maybe<ExamCenterUpdateOneRequiredWithoutCenterAdminInput>;
}

export interface CenterAdminUpsertWithoutReportInput {
  update: CenterAdminUpdateWithoutReportDataInput;
  create: CenterAdminCreateWithoutReportInput;
}

export interface ReportUpdateManyMutationInput {
  reportName?: Maybe<String>;
  reportCode?: Maybe<String>;
}

export interface ScoreCreateInput {
  id?: Maybe<ID_Input>;
  subjectAve?: Maybe<Float>;
  subjectTotal?: Maybe<Float>;
  registration: RegistrationCreateOneInput;
  presence: PresenceCreateOneWithoutScoreInput;
  annExamSeriesSubj: AnnualExamSubjectSeriesCreateOneWithoutScoreInput;
}

export interface ScoreUpdateInput {
  subjectAve?: Maybe<Float>;
  subjectTotal?: Maybe<Float>;
  registration?: Maybe<RegistrationUpdateOneRequiredInput>;
  presence?: Maybe<PresenceUpdateOneRequiredWithoutScoreInput>;
  annExamSeriesSubj?: Maybe<
    AnnualExamSubjectSeriesUpdateOneRequiredWithoutScoreInput
  >;
}

export interface ScoreUpdateManyMutationInput {
  subjectAve?: Maybe<Float>;
  subjectTotal?: Maybe<Float>;
}

export interface SeriesCreateInput {
  id?: Maybe<ID_Input>;
  seriesName: String;
  seriesCode: String;
  educationType: EducationTypeCreateOneWithoutSeriesInput;
  registration?: Maybe<RegistrationCreateManyWithoutSeriesInput>;
}

export interface SeriesUpdateInput {
  seriesName?: Maybe<String>;
  seriesCode?: Maybe<String>;
  educationType?: Maybe<EducationTypeUpdateOneRequiredWithoutSeriesInput>;
  registration?: Maybe<RegistrationUpdateManyWithoutSeriesInput>;
}

export interface SeriesUpdateManyMutationInput {
  seriesName?: Maybe<String>;
  seriesCode?: Maybe<String>;
}

export interface SessionCreateInput {
  id?: Maybe<ID_Input>;
  sessionName: String;
  sessionCode: String;
  centerAdmin?: Maybe<CenterAdminCreateManyWithoutSessionInput>;
  annExamSeriesSubj?: Maybe<
    AnnualExamSubjectSeriesCreateManyWithoutSessionInput
  >;
  registration?: Maybe<RegistrationCreateManyWithoutSessionInput>;
}

export interface SessionUpdateInput {
  sessionName?: Maybe<String>;
  sessionCode?: Maybe<String>;
  centerAdmin?: Maybe<CenterAdminUpdateManyWithoutSessionInput>;
  annExamSeriesSubj?: Maybe<
    AnnualExamSubjectSeriesUpdateManyWithoutSessionInput
  >;
  registration?: Maybe<RegistrationUpdateManyWithoutSessionInput>;
}

export interface SessionUpdateManyMutationInput {
  sessionName?: Maybe<String>;
  sessionCode?: Maybe<String>;
}

export interface SubDivisionCreateInput {
  id?: Maybe<ID_Input>;
  subDivName: String;
  subDivCode: String;
  division: DivisionCreateOneWithoutSubDivisionInput;
  town?: Maybe<TownCreateManyWithoutSubDivInput>;
}

export interface SubDivisionUpdateInput {
  subDivName?: Maybe<String>;
  subDivCode?: Maybe<String>;
  division?: Maybe<DivisionUpdateOneRequiredWithoutSubDivisionInput>;
  town?: Maybe<TownUpdateManyWithoutSubDivInput>;
}

export interface SubDivisionUpdateManyMutationInput {
  subDivName?: Maybe<String>;
  subDivCode?: Maybe<String>;
}

export interface SubjectCreateInput {
  id?: Maybe<ID_Input>;
  subjName: String;
  subjCode: String;
  annExamSeriesSubj?: Maybe<AnnualExamSubjectSeriesCreateManyInput>;
}

export interface AnnualExamSubjectSeriesCreateManyInput {
  create?: Maybe<
    AnnualExamSubjectSeriesCreateInput[] | AnnualExamSubjectSeriesCreateInput
  >;
  connect?: Maybe<
    | AnnualExamSubjectSeriesWhereUniqueInput[]
    | AnnualExamSubjectSeriesWhereUniqueInput
  >;
}

export interface SubjectUpdateInput {
  subjName?: Maybe<String>;
  subjCode?: Maybe<String>;
  annExamSeriesSubj?: Maybe<AnnualExamSubjectSeriesUpdateManyInput>;
}

export interface AnnualExamSubjectSeriesUpdateManyInput {
  create?: Maybe<
    AnnualExamSubjectSeriesCreateInput[] | AnnualExamSubjectSeriesCreateInput
  >;
  update?: Maybe<
    | AnnualExamSubjectSeriesUpdateWithWhereUniqueNestedInput[]
    | AnnualExamSubjectSeriesUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | AnnualExamSubjectSeriesUpsertWithWhereUniqueNestedInput[]
    | AnnualExamSubjectSeriesUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    | AnnualExamSubjectSeriesWhereUniqueInput[]
    | AnnualExamSubjectSeriesWhereUniqueInput
  >;
  connect?: Maybe<
    | AnnualExamSubjectSeriesWhereUniqueInput[]
    | AnnualExamSubjectSeriesWhereUniqueInput
  >;
  set?: Maybe<
    | AnnualExamSubjectSeriesWhereUniqueInput[]
    | AnnualExamSubjectSeriesWhereUniqueInput
  >;
  disconnect?: Maybe<
    | AnnualExamSubjectSeriesWhereUniqueInput[]
    | AnnualExamSubjectSeriesWhereUniqueInput
  >;
  deleteMany?: Maybe<
    | AnnualExamSubjectSeriesScalarWhereInput[]
    | AnnualExamSubjectSeriesScalarWhereInput
  >;
  updateMany?: Maybe<
    | AnnualExamSubjectSeriesUpdateManyWithWhereNestedInput[]
    | AnnualExamSubjectSeriesUpdateManyWithWhereNestedInput
  >;
}

export interface AnnualExamSubjectSeriesUpdateWithWhereUniqueNestedInput {
  where: AnnualExamSubjectSeriesWhereUniqueInput;
  data: AnnualExamSubjectSeriesUpdateDataInput;
}

export interface AnnualExamSubjectSeriesUpdateDataInput {
  exam?: Maybe<ExamUpdateOneRequiredWithoutAnnExamSeriesSubjInput>;
  session?: Maybe<SessionUpdateOneRequiredWithoutAnnExamSeriesSubjInput>;
  center?: Maybe<ExamCenterUpdateOneRequiredInput>;
  rankCode?: Maybe<String>;
  score?: Maybe<ScoreUpdateManyWithoutAnnExamSeriesSubjInput>;
}

export interface AnnualExamSubjectSeriesUpsertWithWhereUniqueNestedInput {
  where: AnnualExamSubjectSeriesWhereUniqueInput;
  update: AnnualExamSubjectSeriesUpdateDataInput;
  create: AnnualExamSubjectSeriesCreateInput;
}

export interface SubjectUpdateManyMutationInput {
  subjName?: Maybe<String>;
  subjCode?: Maybe<String>;
}

export interface TownCreateInput {
  id?: Maybe<ID_Input>;
  townName: String;
  townCode: String;
  subDiv: SubDivisionCreateOneWithoutTownInput;
  center?: Maybe<ExamCenterCreateManyWithoutTownInput>;
}

export interface TownUpdateInput {
  townName?: Maybe<String>;
  townCode?: Maybe<String>;
  subDiv?: Maybe<SubDivisionUpdateOneRequiredWithoutTownInput>;
  center?: Maybe<ExamCenterUpdateManyWithoutTownInput>;
}

export interface TownUpdateManyMutationInput {
  townName?: Maybe<String>;
  townCode?: Maybe<String>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  item?: Maybe<ItemCreateManyWithoutUserInput>;
}

export interface ItemCreateManyWithoutUserInput {
  create?: Maybe<ItemCreateWithoutUserInput[] | ItemCreateWithoutUserInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
}

export interface ItemCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  title: String;
  descrption: String;
  image?: Maybe<String>;
  largeImage?: Maybe<String>;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  item?: Maybe<ItemUpdateManyWithoutUserInput>;
}

export interface ItemUpdateManyWithoutUserInput {
  create?: Maybe<ItemCreateWithoutUserInput[] | ItemCreateWithoutUserInput>;
  delete?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  set?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  disconnect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  update?: Maybe<
    | ItemUpdateWithWhereUniqueWithoutUserInput[]
    | ItemUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | ItemUpsertWithWhereUniqueWithoutUserInput[]
    | ItemUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  updateMany?: Maybe<
    ItemUpdateManyWithWhereNestedInput[] | ItemUpdateManyWithWhereNestedInput
  >;
}

export interface ItemUpdateWithWhereUniqueWithoutUserInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateWithoutUserDataInput;
}

export interface ItemUpdateWithoutUserDataInput {
  title?: Maybe<String>;
  descrption?: Maybe<String>;
  image?: Maybe<String>;
  largeImage?: Maybe<String>;
}

export interface ItemUpsertWithWhereUniqueWithoutUserInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateWithoutUserDataInput;
  create: ItemCreateWithoutUserInput;
}

export interface ItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  descrption?: Maybe<String>;
  descrption_not?: Maybe<String>;
  descrption_in?: Maybe<String[] | String>;
  descrption_not_in?: Maybe<String[] | String>;
  descrption_lt?: Maybe<String>;
  descrption_lte?: Maybe<String>;
  descrption_gt?: Maybe<String>;
  descrption_gte?: Maybe<String>;
  descrption_contains?: Maybe<String>;
  descrption_not_contains?: Maybe<String>;
  descrption_starts_with?: Maybe<String>;
  descrption_not_starts_with?: Maybe<String>;
  descrption_ends_with?: Maybe<String>;
  descrption_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  largeImage?: Maybe<String>;
  largeImage_not?: Maybe<String>;
  largeImage_in?: Maybe<String[] | String>;
  largeImage_not_in?: Maybe<String[] | String>;
  largeImage_lt?: Maybe<String>;
  largeImage_lte?: Maybe<String>;
  largeImage_gt?: Maybe<String>;
  largeImage_gte?: Maybe<String>;
  largeImage_contains?: Maybe<String>;
  largeImage_not_contains?: Maybe<String>;
  largeImage_starts_with?: Maybe<String>;
  largeImage_not_starts_with?: Maybe<String>;
  largeImage_ends_with?: Maybe<String>;
  largeImage_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  OR?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  NOT?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
}

export interface ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput;
  data: ItemUpdateManyDataInput;
}

export interface ItemUpdateManyDataInput {
  title?: Maybe<String>;
  descrption?: Maybe<String>;
  image?: Maybe<String>;
  largeImage?: Maybe<String>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
}

export interface AnnualExamSubjectSeriesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AnnualExamSubjectSeriesWhereInput>;
  AND?: Maybe<
    | AnnualExamSubjectSeriesSubscriptionWhereInput[]
    | AnnualExamSubjectSeriesSubscriptionWhereInput
  >;
  OR?: Maybe<
    | AnnualExamSubjectSeriesSubscriptionWhereInput[]
    | AnnualExamSubjectSeriesSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | AnnualExamSubjectSeriesSubscriptionWhereInput[]
    | AnnualExamSubjectSeriesSubscriptionWhereInput
  >;
}

export interface AnotherTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AnotherTypeWhereInput>;
  AND?: Maybe<
    AnotherTypeSubscriptionWhereInput[] | AnotherTypeSubscriptionWhereInput
  >;
  OR?: Maybe<
    AnotherTypeSubscriptionWhereInput[] | AnotherTypeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    AnotherTypeSubscriptionWhereInput[] | AnotherTypeSubscriptionWhereInput
  >;
}

export interface CandidateSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CandidateWhereInput>;
  AND?: Maybe<
    CandidateSubscriptionWhereInput[] | CandidateSubscriptionWhereInput
  >;
  OR?: Maybe<
    CandidateSubscriptionWhereInput[] | CandidateSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CandidateSubscriptionWhereInput[] | CandidateSubscriptionWhereInput
  >;
}

export interface CenterAdminSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CenterAdminWhereInput>;
  AND?: Maybe<
    CenterAdminSubscriptionWhereInput[] | CenterAdminSubscriptionWhereInput
  >;
  OR?: Maybe<
    CenterAdminSubscriptionWhereInput[] | CenterAdminSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CenterAdminSubscriptionWhereInput[] | CenterAdminSubscriptionWhereInput
  >;
}

export interface DivisionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DivisionWhereInput>;
  AND?: Maybe<
    DivisionSubscriptionWhereInput[] | DivisionSubscriptionWhereInput
  >;
  OR?: Maybe<DivisionSubscriptionWhereInput[] | DivisionSubscriptionWhereInput>;
  NOT?: Maybe<
    DivisionSubscriptionWhereInput[] | DivisionSubscriptionWhereInput
  >;
}

export interface EducationTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EducationTypeWhereInput>;
  AND?: Maybe<
    EducationTypeSubscriptionWhereInput[] | EducationTypeSubscriptionWhereInput
  >;
  OR?: Maybe<
    EducationTypeSubscriptionWhereInput[] | EducationTypeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    EducationTypeSubscriptionWhereInput[] | EducationTypeSubscriptionWhereInput
  >;
}

export interface ExamSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExamWhereInput>;
  AND?: Maybe<ExamSubscriptionWhereInput[] | ExamSubscriptionWhereInput>;
  OR?: Maybe<ExamSubscriptionWhereInput[] | ExamSubscriptionWhereInput>;
  NOT?: Maybe<ExamSubscriptionWhereInput[] | ExamSubscriptionWhereInput>;
}

export interface ExamCenterSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExamCenterWhereInput>;
  AND?: Maybe<
    ExamCenterSubscriptionWhereInput[] | ExamCenterSubscriptionWhereInput
  >;
  OR?: Maybe<
    ExamCenterSubscriptionWhereInput[] | ExamCenterSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ExamCenterSubscriptionWhereInput[] | ExamCenterSubscriptionWhereInput
  >;
}

export interface GenderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GenderWhereInput>;
  AND?: Maybe<GenderSubscriptionWhereInput[] | GenderSubscriptionWhereInput>;
  OR?: Maybe<GenderSubscriptionWhereInput[] | GenderSubscriptionWhereInput>;
  NOT?: Maybe<GenderSubscriptionWhereInput[] | GenderSubscriptionWhereInput>;
}

export interface ItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ItemWhereInput>;
  AND?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  OR?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  NOT?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
}

export interface PresenceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PresenceWhereInput>;
  AND?: Maybe<
    PresenceSubscriptionWhereInput[] | PresenceSubscriptionWhereInput
  >;
  OR?: Maybe<PresenceSubscriptionWhereInput[] | PresenceSubscriptionWhereInput>;
  NOT?: Maybe<
    PresenceSubscriptionWhereInput[] | PresenceSubscriptionWhereInput
  >;
}

export interface RankSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RankWhereInput>;
  AND?: Maybe<RankSubscriptionWhereInput[] | RankSubscriptionWhereInput>;
  OR?: Maybe<RankSubscriptionWhereInput[] | RankSubscriptionWhereInput>;
  NOT?: Maybe<RankSubscriptionWhereInput[] | RankSubscriptionWhereInput>;
}

export interface RegionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RegionWhereInput>;
  AND?: Maybe<RegionSubscriptionWhereInput[] | RegionSubscriptionWhereInput>;
  OR?: Maybe<RegionSubscriptionWhereInput[] | RegionSubscriptionWhereInput>;
  NOT?: Maybe<RegionSubscriptionWhereInput[] | RegionSubscriptionWhereInput>;
}

export interface RegistrationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RegistrationWhereInput>;
  AND?: Maybe<
    RegistrationSubscriptionWhereInput[] | RegistrationSubscriptionWhereInput
  >;
  OR?: Maybe<
    RegistrationSubscriptionWhereInput[] | RegistrationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    RegistrationSubscriptionWhereInput[] | RegistrationSubscriptionWhereInput
  >;
}

export interface ReportSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReportWhereInput>;
  AND?: Maybe<ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput>;
  OR?: Maybe<ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput>;
  NOT?: Maybe<ReportSubscriptionWhereInput[] | ReportSubscriptionWhereInput>;
}

export interface ScoreSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ScoreWhereInput>;
  AND?: Maybe<ScoreSubscriptionWhereInput[] | ScoreSubscriptionWhereInput>;
  OR?: Maybe<ScoreSubscriptionWhereInput[] | ScoreSubscriptionWhereInput>;
  NOT?: Maybe<ScoreSubscriptionWhereInput[] | ScoreSubscriptionWhereInput>;
}

export interface SeriesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SeriesWhereInput>;
  AND?: Maybe<SeriesSubscriptionWhereInput[] | SeriesSubscriptionWhereInput>;
  OR?: Maybe<SeriesSubscriptionWhereInput[] | SeriesSubscriptionWhereInput>;
  NOT?: Maybe<SeriesSubscriptionWhereInput[] | SeriesSubscriptionWhereInput>;
}

export interface SessionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SessionWhereInput>;
  AND?: Maybe<SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput>;
  OR?: Maybe<SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput>;
  NOT?: Maybe<SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput>;
}

export interface SubDivisionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SubDivisionWhereInput>;
  AND?: Maybe<
    SubDivisionSubscriptionWhereInput[] | SubDivisionSubscriptionWhereInput
  >;
  OR?: Maybe<
    SubDivisionSubscriptionWhereInput[] | SubDivisionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SubDivisionSubscriptionWhereInput[] | SubDivisionSubscriptionWhereInput
  >;
}

export interface SubjectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SubjectWhereInput>;
  AND?: Maybe<SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput>;
  OR?: Maybe<SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput>;
  NOT?: Maybe<SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput>;
}

export interface TownSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TownWhereInput>;
  AND?: Maybe<TownSubscriptionWhereInput[] | TownSubscriptionWhereInput>;
  OR?: Maybe<TownSubscriptionWhereInput[] | TownSubscriptionWhereInput>;
  NOT?: Maybe<TownSubscriptionWhereInput[] | TownSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface AnnualExamSubjectSeries {
  id: ID_Output;
  rankCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AnnualExamSubjectSeriesPromise
  extends Promise<AnnualExamSubjectSeries>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  exam: <T = ExamPromise>() => T;
  session: <T = SessionPromise>() => T;
  center: <T = ExamCenterPromise>() => T;
  rankCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  score: <T = FragmentableArray<Score>>(args?: {
    where?: ScoreWhereInput;
    orderBy?: ScoreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AnnualExamSubjectSeriesSubscription
  extends Promise<AsyncIterator<AnnualExamSubjectSeries>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  exam: <T = ExamSubscription>() => T;
  session: <T = SessionSubscription>() => T;
  center: <T = ExamCenterSubscription>() => T;
  rankCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  score: <T = Promise<AsyncIterator<ScoreSubscription>>>(args?: {
    where?: ScoreWhereInput;
    orderBy?: ScoreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AnnualExamSubjectSeriesNullablePromise
  extends Promise<AnnualExamSubjectSeries | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  exam: <T = ExamPromise>() => T;
  session: <T = SessionPromise>() => T;
  center: <T = ExamCenterPromise>() => T;
  rankCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  score: <T = FragmentableArray<Score>>(args?: {
    where?: ScoreWhereInput;
    orderBy?: ScoreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Exam {
  id: ID_Output;
  examName: String;
  examCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ExamPromise extends Promise<Exam>, Fragmentable {
  id: () => Promise<ID_Output>;
  examName: () => Promise<String>;
  examCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  centerAdmin: <T = FragmentableArray<CenterAdmin>>(args?: {
    where?: CenterAdminWhereInput;
    orderBy?: CenterAdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  annExamSeriesSubj: <T = FragmentableArray<AnnualExamSubjectSeries>>(args?: {
    where?: AnnualExamSubjectSeriesWhereInput;
    orderBy?: AnnualExamSubjectSeriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  registration: <T = FragmentableArray<Registration>>(args?: {
    where?: RegistrationWhereInput;
    orderBy?: RegistrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ExamSubscription
  extends Promise<AsyncIterator<Exam>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  examName: () => Promise<AsyncIterator<String>>;
  examCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  centerAdmin: <T = Promise<AsyncIterator<CenterAdminSubscription>>>(args?: {
    where?: CenterAdminWhereInput;
    orderBy?: CenterAdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  annExamSeriesSubj: <
    T = Promise<AsyncIterator<AnnualExamSubjectSeriesSubscription>>
  >(args?: {
    where?: AnnualExamSubjectSeriesWhereInput;
    orderBy?: AnnualExamSubjectSeriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  registration: <T = Promise<AsyncIterator<RegistrationSubscription>>>(args?: {
    where?: RegistrationWhereInput;
    orderBy?: RegistrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ExamNullablePromise
  extends Promise<Exam | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  examName: () => Promise<String>;
  examCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  centerAdmin: <T = FragmentableArray<CenterAdmin>>(args?: {
    where?: CenterAdminWhereInput;
    orderBy?: CenterAdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  annExamSeriesSubj: <T = FragmentableArray<AnnualExamSubjectSeries>>(args?: {
    where?: AnnualExamSubjectSeriesWhereInput;
    orderBy?: AnnualExamSubjectSeriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  registration: <T = FragmentableArray<Registration>>(args?: {
    where?: RegistrationWhereInput;
    orderBy?: RegistrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CenterAdmin {
  id: ID_Output;
  authName: String;
  authInstitution: String;
  authPhone: Int;
  authMatricue: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CenterAdminPromise extends Promise<CenterAdmin>, Fragmentable {
  id: () => Promise<ID_Output>;
  authName: () => Promise<String>;
  authInstitution: () => Promise<String>;
  authPhone: () => Promise<Int>;
  authMatricue: () => Promise<String>;
  rank: <T = RankPromise>() => T;
  exam: <T = ExamPromise>() => T;
  session: <T = SessionPromise>() => T;
  center: <T = ExamCenterPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  report: <T = FragmentableArray<Report>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CenterAdminSubscription
  extends Promise<AsyncIterator<CenterAdmin>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  authName: () => Promise<AsyncIterator<String>>;
  authInstitution: () => Promise<AsyncIterator<String>>;
  authPhone: () => Promise<AsyncIterator<Int>>;
  authMatricue: () => Promise<AsyncIterator<String>>;
  rank: <T = RankSubscription>() => T;
  exam: <T = ExamSubscription>() => T;
  session: <T = SessionSubscription>() => T;
  center: <T = ExamCenterSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  report: <T = Promise<AsyncIterator<ReportSubscription>>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CenterAdminNullablePromise
  extends Promise<CenterAdmin | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  authName: () => Promise<String>;
  authInstitution: () => Promise<String>;
  authPhone: () => Promise<Int>;
  authMatricue: () => Promise<String>;
  rank: <T = RankPromise>() => T;
  exam: <T = ExamPromise>() => T;
  session: <T = SessionPromise>() => T;
  center: <T = ExamCenterPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  report: <T = FragmentableArray<Report>>(args?: {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Rank {
  id: ID_Output;
  rankName: String;
  rankCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RankPromise extends Promise<Rank>, Fragmentable {
  id: () => Promise<ID_Output>;
  rankName: () => Promise<String>;
  rankCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  centerAdmin: <T = FragmentableArray<CenterAdmin>>(args?: {
    where?: CenterAdminWhereInput;
    orderBy?: CenterAdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RankSubscription
  extends Promise<AsyncIterator<Rank>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  rankName: () => Promise<AsyncIterator<String>>;
  rankCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  centerAdmin: <T = Promise<AsyncIterator<CenterAdminSubscription>>>(args?: {
    where?: CenterAdminWhereInput;
    orderBy?: CenterAdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RankNullablePromise
  extends Promise<Rank | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  rankName: () => Promise<String>;
  rankCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  centerAdmin: <T = FragmentableArray<CenterAdmin>>(args?: {
    where?: CenterAdminWhereInput;
    orderBy?: CenterAdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Session {
  id: ID_Output;
  sessionName: String;
  sessionCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SessionPromise extends Promise<Session>, Fragmentable {
  id: () => Promise<ID_Output>;
  sessionName: () => Promise<String>;
  sessionCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  centerAdmin: <T = FragmentableArray<CenterAdmin>>(args?: {
    where?: CenterAdminWhereInput;
    orderBy?: CenterAdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  annExamSeriesSubj: <T = FragmentableArray<AnnualExamSubjectSeries>>(args?: {
    where?: AnnualExamSubjectSeriesWhereInput;
    orderBy?: AnnualExamSubjectSeriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  registration: <T = FragmentableArray<Registration>>(args?: {
    where?: RegistrationWhereInput;
    orderBy?: RegistrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SessionSubscription
  extends Promise<AsyncIterator<Session>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sessionName: () => Promise<AsyncIterator<String>>;
  sessionCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  centerAdmin: <T = Promise<AsyncIterator<CenterAdminSubscription>>>(args?: {
    where?: CenterAdminWhereInput;
    orderBy?: CenterAdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  annExamSeriesSubj: <
    T = Promise<AsyncIterator<AnnualExamSubjectSeriesSubscription>>
  >(args?: {
    where?: AnnualExamSubjectSeriesWhereInput;
    orderBy?: AnnualExamSubjectSeriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  registration: <T = Promise<AsyncIterator<RegistrationSubscription>>>(args?: {
    where?: RegistrationWhereInput;
    orderBy?: RegistrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SessionNullablePromise
  extends Promise<Session | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sessionName: () => Promise<String>;
  sessionCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  centerAdmin: <T = FragmentableArray<CenterAdmin>>(args?: {
    where?: CenterAdminWhereInput;
    orderBy?: CenterAdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  annExamSeriesSubj: <T = FragmentableArray<AnnualExamSubjectSeries>>(args?: {
    where?: AnnualExamSubjectSeriesWhereInput;
    orderBy?: AnnualExamSubjectSeriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  registration: <T = FragmentableArray<Registration>>(args?: {
    where?: RegistrationWhereInput;
    orderBy?: RegistrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Registration {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RegistrationPromise
  extends Promise<Registration>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  candidate: <T = CandidatePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  exam: <T = ExamPromise>() => T;
  series: <T = SeriesPromise>() => T;
  session: <T = SessionPromise>() => T;
  center: <T = ExamCenterPromise>() => T;
}

export interface RegistrationSubscription
  extends Promise<AsyncIterator<Registration>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  candidate: <T = CandidateSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  exam: <T = ExamSubscription>() => T;
  series: <T = SeriesSubscription>() => T;
  session: <T = SessionSubscription>() => T;
  center: <T = ExamCenterSubscription>() => T;
}

export interface RegistrationNullablePromise
  extends Promise<Registration | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  candidate: <T = CandidatePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  exam: <T = ExamPromise>() => T;
  series: <T = SeriesPromise>() => T;
  session: <T = SessionPromise>() => T;
  center: <T = ExamCenterPromise>() => T;
}

export interface Candidate {
  id: ID_Output;
  cand1stName?: String;
  cand2ndName?: String;
  cand3rdName?: String;
  placeOfBirth?: String;
  candCode?: String;
  image?: String;
  birthCertNumber?: String;
  email?: String;
  phoneNumb?: Int;
  dateOfBirth?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CandidatePromise extends Promise<Candidate>, Fragmentable {
  id: () => Promise<ID_Output>;
  cand1stName: () => Promise<String>;
  cand2ndName: () => Promise<String>;
  cand3rdName: () => Promise<String>;
  placeOfBirth: () => Promise<String>;
  candCode: () => Promise<String>;
  image: () => Promise<String>;
  birthCertNumber: () => Promise<String>;
  email: () => Promise<String>;
  phoneNumb: () => Promise<Int>;
  dateOfBirth: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  gender: <T = GenderPromise>() => T;
  registration: <T = FragmentableArray<Registration>>(args?: {
    where?: RegistrationWhereInput;
    orderBy?: RegistrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CandidateSubscription
  extends Promise<AsyncIterator<Candidate>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  cand1stName: () => Promise<AsyncIterator<String>>;
  cand2ndName: () => Promise<AsyncIterator<String>>;
  cand3rdName: () => Promise<AsyncIterator<String>>;
  placeOfBirth: () => Promise<AsyncIterator<String>>;
  candCode: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  birthCertNumber: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phoneNumb: () => Promise<AsyncIterator<Int>>;
  dateOfBirth: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  gender: <T = GenderSubscription>() => T;
  registration: <T = Promise<AsyncIterator<RegistrationSubscription>>>(args?: {
    where?: RegistrationWhereInput;
    orderBy?: RegistrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CandidateNullablePromise
  extends Promise<Candidate | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  cand1stName: () => Promise<String>;
  cand2ndName: () => Promise<String>;
  cand3rdName: () => Promise<String>;
  placeOfBirth: () => Promise<String>;
  candCode: () => Promise<String>;
  image: () => Promise<String>;
  birthCertNumber: () => Promise<String>;
  email: () => Promise<String>;
  phoneNumb: () => Promise<Int>;
  dateOfBirth: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  gender: <T = GenderPromise>() => T;
  registration: <T = FragmentableArray<Registration>>(args?: {
    where?: RegistrationWhereInput;
    orderBy?: RegistrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Gender {
  id: ID_Output;
  genderName: String;
  genderCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GenderPromise extends Promise<Gender>, Fragmentable {
  id: () => Promise<ID_Output>;
  genderName: () => Promise<String>;
  genderCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  candidate: <T = FragmentableArray<Candidate>>(args?: {
    where?: CandidateWhereInput;
    orderBy?: CandidateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GenderSubscription
  extends Promise<AsyncIterator<Gender>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  genderName: () => Promise<AsyncIterator<String>>;
  genderCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  candidate: <T = Promise<AsyncIterator<CandidateSubscription>>>(args?: {
    where?: CandidateWhereInput;
    orderBy?: CandidateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GenderNullablePromise
  extends Promise<Gender | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  genderName: () => Promise<String>;
  genderCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  candidate: <T = FragmentableArray<Candidate>>(args?: {
    where?: CandidateWhereInput;
    orderBy?: CandidateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Series {
  id: ID_Output;
  seriesName: String;
  seriesCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SeriesPromise extends Promise<Series>, Fragmentable {
  id: () => Promise<ID_Output>;
  seriesName: () => Promise<String>;
  seriesCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  educationType: <T = EducationTypePromise>() => T;
  registration: <T = FragmentableArray<Registration>>(args?: {
    where?: RegistrationWhereInput;
    orderBy?: RegistrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SeriesSubscription
  extends Promise<AsyncIterator<Series>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  seriesName: () => Promise<AsyncIterator<String>>;
  seriesCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  educationType: <T = EducationTypeSubscription>() => T;
  registration: <T = Promise<AsyncIterator<RegistrationSubscription>>>(args?: {
    where?: RegistrationWhereInput;
    orderBy?: RegistrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SeriesNullablePromise
  extends Promise<Series | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  seriesName: () => Promise<String>;
  seriesCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  educationType: <T = EducationTypePromise>() => T;
  registration: <T = FragmentableArray<Registration>>(args?: {
    where?: RegistrationWhereInput;
    orderBy?: RegistrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EducationType {
  id: ID_Output;
  educationTypeName?: String;
  educationTypeCode?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EducationTypePromise
  extends Promise<EducationType>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  educationTypeName: () => Promise<String>;
  educationTypeCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  series: <T = FragmentableArray<Series>>(args?: {
    where?: SeriesWhereInput;
    orderBy?: SeriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EducationTypeSubscription
  extends Promise<AsyncIterator<EducationType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  educationTypeName: () => Promise<AsyncIterator<String>>;
  educationTypeCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  series: <T = Promise<AsyncIterator<SeriesSubscription>>>(args?: {
    where?: SeriesWhereInput;
    orderBy?: SeriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EducationTypeNullablePromise
  extends Promise<EducationType | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  educationTypeName: () => Promise<String>;
  educationTypeCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  series: <T = FragmentableArray<Series>>(args?: {
    where?: SeriesWhereInput;
    orderBy?: SeriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ExamCenter {
  id: ID_Output;
  centerName: String;
  centerCode: String;
  centerNumber: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ExamCenterPromise extends Promise<ExamCenter>, Fragmentable {
  id: () => Promise<ID_Output>;
  centerName: () => Promise<String>;
  centerCode: () => Promise<String>;
  town: <T = TownPromise>() => T;
  centerNumber: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  registration: <T = FragmentableArray<Registration>>(args?: {
    where?: RegistrationWhereInput;
    orderBy?: RegistrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  centerAdmin: <T = FragmentableArray<CenterAdmin>>(args?: {
    where?: CenterAdminWhereInput;
    orderBy?: CenterAdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ExamCenterSubscription
  extends Promise<AsyncIterator<ExamCenter>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  centerName: () => Promise<AsyncIterator<String>>;
  centerCode: () => Promise<AsyncIterator<String>>;
  town: <T = TownSubscription>() => T;
  centerNumber: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  registration: <T = Promise<AsyncIterator<RegistrationSubscription>>>(args?: {
    where?: RegistrationWhereInput;
    orderBy?: RegistrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  centerAdmin: <T = Promise<AsyncIterator<CenterAdminSubscription>>>(args?: {
    where?: CenterAdminWhereInput;
    orderBy?: CenterAdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ExamCenterNullablePromise
  extends Promise<ExamCenter | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  centerName: () => Promise<String>;
  centerCode: () => Promise<String>;
  town: <T = TownPromise>() => T;
  centerNumber: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  registration: <T = FragmentableArray<Registration>>(args?: {
    where?: RegistrationWhereInput;
    orderBy?: RegistrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  centerAdmin: <T = FragmentableArray<CenterAdmin>>(args?: {
    where?: CenterAdminWhereInput;
    orderBy?: CenterAdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Town {
  id: ID_Output;
  townName: String;
  townCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TownPromise extends Promise<Town>, Fragmentable {
  id: () => Promise<ID_Output>;
  townName: () => Promise<String>;
  townCode: () => Promise<String>;
  subDiv: <T = SubDivisionPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  center: <T = FragmentableArray<ExamCenter>>(args?: {
    where?: ExamCenterWhereInput;
    orderBy?: ExamCenterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TownSubscription
  extends Promise<AsyncIterator<Town>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  townName: () => Promise<AsyncIterator<String>>;
  townCode: () => Promise<AsyncIterator<String>>;
  subDiv: <T = SubDivisionSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  center: <T = Promise<AsyncIterator<ExamCenterSubscription>>>(args?: {
    where?: ExamCenterWhereInput;
    orderBy?: ExamCenterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TownNullablePromise
  extends Promise<Town | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  townName: () => Promise<String>;
  townCode: () => Promise<String>;
  subDiv: <T = SubDivisionPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  center: <T = FragmentableArray<ExamCenter>>(args?: {
    where?: ExamCenterWhereInput;
    orderBy?: ExamCenterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SubDivision {
  id: ID_Output;
  subDivName: String;
  subDivCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SubDivisionPromise extends Promise<SubDivision>, Fragmentable {
  id: () => Promise<ID_Output>;
  subDivName: () => Promise<String>;
  subDivCode: () => Promise<String>;
  division: <T = DivisionPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  town: <T = FragmentableArray<Town>>(args?: {
    where?: TownWhereInput;
    orderBy?: TownOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SubDivisionSubscription
  extends Promise<AsyncIterator<SubDivision>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subDivName: () => Promise<AsyncIterator<String>>;
  subDivCode: () => Promise<AsyncIterator<String>>;
  division: <T = DivisionSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  town: <T = Promise<AsyncIterator<TownSubscription>>>(args?: {
    where?: TownWhereInput;
    orderBy?: TownOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SubDivisionNullablePromise
  extends Promise<SubDivision | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subDivName: () => Promise<String>;
  subDivCode: () => Promise<String>;
  division: <T = DivisionPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  town: <T = FragmentableArray<Town>>(args?: {
    where?: TownWhereInput;
    orderBy?: TownOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Division {
  id: ID_Output;
  divName: String;
  divCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DivisionPromise extends Promise<Division>, Fragmentable {
  id: () => Promise<ID_Output>;
  divName: () => Promise<String>;
  divCode: () => Promise<String>;
  region: <T = RegionPromise>() => T;
  subDivision: <T = FragmentableArray<SubDivision>>(args?: {
    where?: SubDivisionWhereInput;
    orderBy?: SubDivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DivisionSubscription
  extends Promise<AsyncIterator<Division>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  divName: () => Promise<AsyncIterator<String>>;
  divCode: () => Promise<AsyncIterator<String>>;
  region: <T = RegionSubscription>() => T;
  subDivision: <T = Promise<AsyncIterator<SubDivisionSubscription>>>(args?: {
    where?: SubDivisionWhereInput;
    orderBy?: SubDivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DivisionNullablePromise
  extends Promise<Division | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  divName: () => Promise<String>;
  divCode: () => Promise<String>;
  region: <T = RegionPromise>() => T;
  subDivision: <T = FragmentableArray<SubDivision>>(args?: {
    where?: SubDivisionWhereInput;
    orderBy?: SubDivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Region {
  id: ID_Output;
  regName: String;
  regCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RegionPromise extends Promise<Region>, Fragmentable {
  id: () => Promise<ID_Output>;
  regName: () => Promise<String>;
  regCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  division: <T = FragmentableArray<Division>>(args?: {
    where?: DivisionWhereInput;
    orderBy?: DivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RegionSubscription
  extends Promise<AsyncIterator<Region>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  regName: () => Promise<AsyncIterator<String>>;
  regCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  division: <T = Promise<AsyncIterator<DivisionSubscription>>>(args?: {
    where?: DivisionWhereInput;
    orderBy?: DivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RegionNullablePromise
  extends Promise<Region | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  regName: () => Promise<String>;
  regCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  division: <T = FragmentableArray<Division>>(args?: {
    where?: DivisionWhereInput;
    orderBy?: DivisionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Report {
  id: ID_Output;
  reportName: String;
  reportCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ReportPromise extends Promise<Report>, Fragmentable {
  id: () => Promise<ID_Output>;
  reportName: () => Promise<String>;
  reportCode: () => Promise<String>;
  centerAdmin: <T = CenterAdminPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReportSubscription
  extends Promise<AsyncIterator<Report>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  reportName: () => Promise<AsyncIterator<String>>;
  reportCode: () => Promise<AsyncIterator<String>>;
  centerAdmin: <T = CenterAdminSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReportNullablePromise
  extends Promise<Report | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  reportName: () => Promise<String>;
  reportCode: () => Promise<String>;
  centerAdmin: <T = CenterAdminPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Score {
  id: ID_Output;
  subjectAve?: Float;
  subjectTotal?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ScorePromise extends Promise<Score>, Fragmentable {
  id: () => Promise<ID_Output>;
  subjectAve: () => Promise<Float>;
  subjectTotal: () => Promise<Float>;
  registration: <T = RegistrationPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  presence: <T = PresencePromise>() => T;
  annExamSeriesSubj: <T = AnnualExamSubjectSeriesPromise>() => T;
}

export interface ScoreSubscription
  extends Promise<AsyncIterator<Score>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subjectAve: () => Promise<AsyncIterator<Float>>;
  subjectTotal: () => Promise<AsyncIterator<Float>>;
  registration: <T = RegistrationSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  presence: <T = PresenceSubscription>() => T;
  annExamSeriesSubj: <T = AnnualExamSubjectSeriesSubscription>() => T;
}

export interface ScoreNullablePromise
  extends Promise<Score | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subjectAve: () => Promise<Float>;
  subjectTotal: () => Promise<Float>;
  registration: <T = RegistrationPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  presence: <T = PresencePromise>() => T;
  annExamSeriesSubj: <T = AnnualExamSubjectSeriesPromise>() => T;
}

export interface Presence {
  id: ID_Output;
  presenceName: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PresencePromise extends Promise<Presence>, Fragmentable {
  id: () => Promise<ID_Output>;
  presenceName: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  score: <T = FragmentableArray<Score>>(args?: {
    where?: ScoreWhereInput;
    orderBy?: ScoreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PresenceSubscription
  extends Promise<AsyncIterator<Presence>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  presenceName: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  score: <T = Promise<AsyncIterator<ScoreSubscription>>>(args?: {
    where?: ScoreWhereInput;
    orderBy?: ScoreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PresenceNullablePromise
  extends Promise<Presence | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  presenceName: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  score: <T = FragmentableArray<Score>>(args?: {
    where?: ScoreWhereInput;
    orderBy?: ScoreOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AnnualExamSubjectSeriesConnection {
  pageInfo: PageInfo;
  edges: AnnualExamSubjectSeriesEdge[];
}

export interface AnnualExamSubjectSeriesConnectionPromise
  extends Promise<AnnualExamSubjectSeriesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AnnualExamSubjectSeriesEdge>>() => T;
  aggregate: <T = AggregateAnnualExamSubjectSeriesPromise>() => T;
}

export interface AnnualExamSubjectSeriesConnectionSubscription
  extends Promise<AsyncIterator<AnnualExamSubjectSeriesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<AnnualExamSubjectSeriesEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateAnnualExamSubjectSeriesSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AnnualExamSubjectSeriesEdge {
  node: AnnualExamSubjectSeries;
  cursor: String;
}

export interface AnnualExamSubjectSeriesEdgePromise
  extends Promise<AnnualExamSubjectSeriesEdge>,
    Fragmentable {
  node: <T = AnnualExamSubjectSeriesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AnnualExamSubjectSeriesEdgeSubscription
  extends Promise<AsyncIterator<AnnualExamSubjectSeriesEdge>>,
    Fragmentable {
  node: <T = AnnualExamSubjectSeriesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAnnualExamSubjectSeries {
  count: Int;
}

export interface AggregateAnnualExamSubjectSeriesPromise
  extends Promise<AggregateAnnualExamSubjectSeries>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAnnualExamSubjectSeriesSubscription
  extends Promise<AsyncIterator<AggregateAnnualExamSubjectSeries>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AnotherType {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AnotherTypePromise extends Promise<AnotherType>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AnotherTypeSubscription
  extends Promise<AsyncIterator<AnotherType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AnotherTypeNullablePromise
  extends Promise<AnotherType | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AnotherTypeConnection {
  pageInfo: PageInfo;
  edges: AnotherTypeEdge[];
}

export interface AnotherTypeConnectionPromise
  extends Promise<AnotherTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AnotherTypeEdge>>() => T;
  aggregate: <T = AggregateAnotherTypePromise>() => T;
}

export interface AnotherTypeConnectionSubscription
  extends Promise<AsyncIterator<AnotherTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AnotherTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAnotherTypeSubscription>() => T;
}

export interface AnotherTypeEdge {
  node: AnotherType;
  cursor: String;
}

export interface AnotherTypeEdgePromise
  extends Promise<AnotherTypeEdge>,
    Fragmentable {
  node: <T = AnotherTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AnotherTypeEdgeSubscription
  extends Promise<AsyncIterator<AnotherTypeEdge>>,
    Fragmentable {
  node: <T = AnotherTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAnotherType {
  count: Int;
}

export interface AggregateAnotherTypePromise
  extends Promise<AggregateAnotherType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAnotherTypeSubscription
  extends Promise<AsyncIterator<AggregateAnotherType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CandidateConnection {
  pageInfo: PageInfo;
  edges: CandidateEdge[];
}

export interface CandidateConnectionPromise
  extends Promise<CandidateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CandidateEdge>>() => T;
  aggregate: <T = AggregateCandidatePromise>() => T;
}

export interface CandidateConnectionSubscription
  extends Promise<AsyncIterator<CandidateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CandidateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCandidateSubscription>() => T;
}

export interface CandidateEdge {
  node: Candidate;
  cursor: String;
}

export interface CandidateEdgePromise
  extends Promise<CandidateEdge>,
    Fragmentable {
  node: <T = CandidatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CandidateEdgeSubscription
  extends Promise<AsyncIterator<CandidateEdge>>,
    Fragmentable {
  node: <T = CandidateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCandidate {
  count: Int;
}

export interface AggregateCandidatePromise
  extends Promise<AggregateCandidate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCandidateSubscription
  extends Promise<AsyncIterator<AggregateCandidate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CenterAdminConnection {
  pageInfo: PageInfo;
  edges: CenterAdminEdge[];
}

export interface CenterAdminConnectionPromise
  extends Promise<CenterAdminConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CenterAdminEdge>>() => T;
  aggregate: <T = AggregateCenterAdminPromise>() => T;
}

export interface CenterAdminConnectionSubscription
  extends Promise<AsyncIterator<CenterAdminConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CenterAdminEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCenterAdminSubscription>() => T;
}

export interface CenterAdminEdge {
  node: CenterAdmin;
  cursor: String;
}

export interface CenterAdminEdgePromise
  extends Promise<CenterAdminEdge>,
    Fragmentable {
  node: <T = CenterAdminPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CenterAdminEdgeSubscription
  extends Promise<AsyncIterator<CenterAdminEdge>>,
    Fragmentable {
  node: <T = CenterAdminSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCenterAdmin {
  count: Int;
}

export interface AggregateCenterAdminPromise
  extends Promise<AggregateCenterAdmin>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCenterAdminSubscription
  extends Promise<AsyncIterator<AggregateCenterAdmin>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DivisionConnection {
  pageInfo: PageInfo;
  edges: DivisionEdge[];
}

export interface DivisionConnectionPromise
  extends Promise<DivisionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DivisionEdge>>() => T;
  aggregate: <T = AggregateDivisionPromise>() => T;
}

export interface DivisionConnectionSubscription
  extends Promise<AsyncIterator<DivisionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DivisionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDivisionSubscription>() => T;
}

export interface DivisionEdge {
  node: Division;
  cursor: String;
}

export interface DivisionEdgePromise
  extends Promise<DivisionEdge>,
    Fragmentable {
  node: <T = DivisionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DivisionEdgeSubscription
  extends Promise<AsyncIterator<DivisionEdge>>,
    Fragmentable {
  node: <T = DivisionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDivision {
  count: Int;
}

export interface AggregateDivisionPromise
  extends Promise<AggregateDivision>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDivisionSubscription
  extends Promise<AsyncIterator<AggregateDivision>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EducationTypeConnection {
  pageInfo: PageInfo;
  edges: EducationTypeEdge[];
}

export interface EducationTypeConnectionPromise
  extends Promise<EducationTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EducationTypeEdge>>() => T;
  aggregate: <T = AggregateEducationTypePromise>() => T;
}

export interface EducationTypeConnectionSubscription
  extends Promise<AsyncIterator<EducationTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EducationTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEducationTypeSubscription>() => T;
}

export interface EducationTypeEdge {
  node: EducationType;
  cursor: String;
}

export interface EducationTypeEdgePromise
  extends Promise<EducationTypeEdge>,
    Fragmentable {
  node: <T = EducationTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface EducationTypeEdgeSubscription
  extends Promise<AsyncIterator<EducationTypeEdge>>,
    Fragmentable {
  node: <T = EducationTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEducationType {
  count: Int;
}

export interface AggregateEducationTypePromise
  extends Promise<AggregateEducationType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEducationTypeSubscription
  extends Promise<AsyncIterator<AggregateEducationType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExamConnection {
  pageInfo: PageInfo;
  edges: ExamEdge[];
}

export interface ExamConnectionPromise
  extends Promise<ExamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExamEdge>>() => T;
  aggregate: <T = AggregateExamPromise>() => T;
}

export interface ExamConnectionSubscription
  extends Promise<AsyncIterator<ExamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExamEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExamSubscription>() => T;
}

export interface ExamEdge {
  node: Exam;
  cursor: String;
}

export interface ExamEdgePromise extends Promise<ExamEdge>, Fragmentable {
  node: <T = ExamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExamEdgeSubscription
  extends Promise<AsyncIterator<ExamEdge>>,
    Fragmentable {
  node: <T = ExamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExam {
  count: Int;
}

export interface AggregateExamPromise
  extends Promise<AggregateExam>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExamSubscription
  extends Promise<AsyncIterator<AggregateExam>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExamCenterConnection {
  pageInfo: PageInfo;
  edges: ExamCenterEdge[];
}

export interface ExamCenterConnectionPromise
  extends Promise<ExamCenterConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExamCenterEdge>>() => T;
  aggregate: <T = AggregateExamCenterPromise>() => T;
}

export interface ExamCenterConnectionSubscription
  extends Promise<AsyncIterator<ExamCenterConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExamCenterEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExamCenterSubscription>() => T;
}

export interface ExamCenterEdge {
  node: ExamCenter;
  cursor: String;
}

export interface ExamCenterEdgePromise
  extends Promise<ExamCenterEdge>,
    Fragmentable {
  node: <T = ExamCenterPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExamCenterEdgeSubscription
  extends Promise<AsyncIterator<ExamCenterEdge>>,
    Fragmentable {
  node: <T = ExamCenterSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExamCenter {
  count: Int;
}

export interface AggregateExamCenterPromise
  extends Promise<AggregateExamCenter>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExamCenterSubscription
  extends Promise<AsyncIterator<AggregateExamCenter>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GenderConnection {
  pageInfo: PageInfo;
  edges: GenderEdge[];
}

export interface GenderConnectionPromise
  extends Promise<GenderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GenderEdge>>() => T;
  aggregate: <T = AggregateGenderPromise>() => T;
}

export interface GenderConnectionSubscription
  extends Promise<AsyncIterator<GenderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GenderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGenderSubscription>() => T;
}

export interface GenderEdge {
  node: Gender;
  cursor: String;
}

export interface GenderEdgePromise extends Promise<GenderEdge>, Fragmentable {
  node: <T = GenderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GenderEdgeSubscription
  extends Promise<AsyncIterator<GenderEdge>>,
    Fragmentable {
  node: <T = GenderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGender {
  count: Int;
}

export interface AggregateGenderPromise
  extends Promise<AggregateGender>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGenderSubscription
  extends Promise<AsyncIterator<AggregateGender>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Item {
  id: ID_Output;
  title: String;
  descrption: String;
  image?: String;
  largeImage?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ItemPromise extends Promise<Item>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  descrption: () => Promise<String>;
  image: () => Promise<String>;
  largeImage: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
}

export interface ItemSubscription
  extends Promise<AsyncIterator<Item>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  descrption: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  largeImage: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
}

export interface ItemNullablePromise
  extends Promise<Item | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  descrption: () => Promise<String>;
  image: () => Promise<String>;
  largeImage: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  item: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  item: <T = Promise<AsyncIterator<ItemSubscription>>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  item: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ItemConnection {
  pageInfo: PageInfo;
  edges: ItemEdge[];
}

export interface ItemConnectionPromise
  extends Promise<ItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ItemEdge>>() => T;
  aggregate: <T = AggregateItemPromise>() => T;
}

export interface ItemConnectionSubscription
  extends Promise<AsyncIterator<ItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemSubscription>() => T;
}

export interface ItemEdge {
  node: Item;
  cursor: String;
}

export interface ItemEdgePromise extends Promise<ItemEdge>, Fragmentable {
  node: <T = ItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ItemEdgeSubscription
  extends Promise<AsyncIterator<ItemEdge>>,
    Fragmentable {
  node: <T = ItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateItem {
  count: Int;
}

export interface AggregateItemPromise
  extends Promise<AggregateItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemSubscription
  extends Promise<AsyncIterator<AggregateItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PresenceConnection {
  pageInfo: PageInfo;
  edges: PresenceEdge[];
}

export interface PresenceConnectionPromise
  extends Promise<PresenceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PresenceEdge>>() => T;
  aggregate: <T = AggregatePresencePromise>() => T;
}

export interface PresenceConnectionSubscription
  extends Promise<AsyncIterator<PresenceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PresenceEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePresenceSubscription>() => T;
}

export interface PresenceEdge {
  node: Presence;
  cursor: String;
}

export interface PresenceEdgePromise
  extends Promise<PresenceEdge>,
    Fragmentable {
  node: <T = PresencePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PresenceEdgeSubscription
  extends Promise<AsyncIterator<PresenceEdge>>,
    Fragmentable {
  node: <T = PresenceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePresence {
  count: Int;
}

export interface AggregatePresencePromise
  extends Promise<AggregatePresence>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePresenceSubscription
  extends Promise<AsyncIterator<AggregatePresence>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RankConnection {
  pageInfo: PageInfo;
  edges: RankEdge[];
}

export interface RankConnectionPromise
  extends Promise<RankConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RankEdge>>() => T;
  aggregate: <T = AggregateRankPromise>() => T;
}

export interface RankConnectionSubscription
  extends Promise<AsyncIterator<RankConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RankEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRankSubscription>() => T;
}

export interface RankEdge {
  node: Rank;
  cursor: String;
}

export interface RankEdgePromise extends Promise<RankEdge>, Fragmentable {
  node: <T = RankPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RankEdgeSubscription
  extends Promise<AsyncIterator<RankEdge>>,
    Fragmentable {
  node: <T = RankSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRank {
  count: Int;
}

export interface AggregateRankPromise
  extends Promise<AggregateRank>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRankSubscription
  extends Promise<AsyncIterator<AggregateRank>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RegionConnection {
  pageInfo: PageInfo;
  edges: RegionEdge[];
}

export interface RegionConnectionPromise
  extends Promise<RegionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RegionEdge>>() => T;
  aggregate: <T = AggregateRegionPromise>() => T;
}

export interface RegionConnectionSubscription
  extends Promise<AsyncIterator<RegionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RegionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRegionSubscription>() => T;
}

export interface RegionEdge {
  node: Region;
  cursor: String;
}

export interface RegionEdgePromise extends Promise<RegionEdge>, Fragmentable {
  node: <T = RegionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RegionEdgeSubscription
  extends Promise<AsyncIterator<RegionEdge>>,
    Fragmentable {
  node: <T = RegionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRegion {
  count: Int;
}

export interface AggregateRegionPromise
  extends Promise<AggregateRegion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRegionSubscription
  extends Promise<AsyncIterator<AggregateRegion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RegistrationConnection {
  pageInfo: PageInfo;
  edges: RegistrationEdge[];
}

export interface RegistrationConnectionPromise
  extends Promise<RegistrationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RegistrationEdge>>() => T;
  aggregate: <T = AggregateRegistrationPromise>() => T;
}

export interface RegistrationConnectionSubscription
  extends Promise<AsyncIterator<RegistrationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RegistrationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRegistrationSubscription>() => T;
}

export interface RegistrationEdge {
  node: Registration;
  cursor: String;
}

export interface RegistrationEdgePromise
  extends Promise<RegistrationEdge>,
    Fragmentable {
  node: <T = RegistrationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RegistrationEdgeSubscription
  extends Promise<AsyncIterator<RegistrationEdge>>,
    Fragmentable {
  node: <T = RegistrationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRegistration {
  count: Int;
}

export interface AggregateRegistrationPromise
  extends Promise<AggregateRegistration>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRegistrationSubscription
  extends Promise<AsyncIterator<AggregateRegistration>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReportConnection {
  pageInfo: PageInfo;
  edges: ReportEdge[];
}

export interface ReportConnectionPromise
  extends Promise<ReportConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReportEdge>>() => T;
  aggregate: <T = AggregateReportPromise>() => T;
}

export interface ReportConnectionSubscription
  extends Promise<AsyncIterator<ReportConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReportEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReportSubscription>() => T;
}

export interface ReportEdge {
  node: Report;
  cursor: String;
}

export interface ReportEdgePromise extends Promise<ReportEdge>, Fragmentable {
  node: <T = ReportPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReportEdgeSubscription
  extends Promise<AsyncIterator<ReportEdge>>,
    Fragmentable {
  node: <T = ReportSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateReport {
  count: Int;
}

export interface AggregateReportPromise
  extends Promise<AggregateReport>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReportSubscription
  extends Promise<AsyncIterator<AggregateReport>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScoreConnection {
  pageInfo: PageInfo;
  edges: ScoreEdge[];
}

export interface ScoreConnectionPromise
  extends Promise<ScoreConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ScoreEdge>>() => T;
  aggregate: <T = AggregateScorePromise>() => T;
}

export interface ScoreConnectionSubscription
  extends Promise<AsyncIterator<ScoreConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ScoreEdgeSubscription>>>() => T;
  aggregate: <T = AggregateScoreSubscription>() => T;
}

export interface ScoreEdge {
  node: Score;
  cursor: String;
}

export interface ScoreEdgePromise extends Promise<ScoreEdge>, Fragmentable {
  node: <T = ScorePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ScoreEdgeSubscription
  extends Promise<AsyncIterator<ScoreEdge>>,
    Fragmentable {
  node: <T = ScoreSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateScore {
  count: Int;
}

export interface AggregateScorePromise
  extends Promise<AggregateScore>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScoreSubscription
  extends Promise<AsyncIterator<AggregateScore>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SeriesConnection {
  pageInfo: PageInfo;
  edges: SeriesEdge[];
}

export interface SeriesConnectionPromise
  extends Promise<SeriesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SeriesEdge>>() => T;
  aggregate: <T = AggregateSeriesPromise>() => T;
}

export interface SeriesConnectionSubscription
  extends Promise<AsyncIterator<SeriesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SeriesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSeriesSubscription>() => T;
}

export interface SeriesEdge {
  node: Series;
  cursor: String;
}

export interface SeriesEdgePromise extends Promise<SeriesEdge>, Fragmentable {
  node: <T = SeriesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SeriesEdgeSubscription
  extends Promise<AsyncIterator<SeriesEdge>>,
    Fragmentable {
  node: <T = SeriesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSeries {
  count: Int;
}

export interface AggregateSeriesPromise
  extends Promise<AggregateSeries>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSeriesSubscription
  extends Promise<AsyncIterator<AggregateSeries>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SessionConnection {
  pageInfo: PageInfo;
  edges: SessionEdge[];
}

export interface SessionConnectionPromise
  extends Promise<SessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SessionEdge>>() => T;
  aggregate: <T = AggregateSessionPromise>() => T;
}

export interface SessionConnectionSubscription
  extends Promise<AsyncIterator<SessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSessionSubscription>() => T;
}

export interface SessionEdge {
  node: Session;
  cursor: String;
}

export interface SessionEdgePromise extends Promise<SessionEdge>, Fragmentable {
  node: <T = SessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SessionEdgeSubscription
  extends Promise<AsyncIterator<SessionEdge>>,
    Fragmentable {
  node: <T = SessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSession {
  count: Int;
}

export interface AggregateSessionPromise
  extends Promise<AggregateSession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSessionSubscription
  extends Promise<AsyncIterator<AggregateSession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubDivisionConnection {
  pageInfo: PageInfo;
  edges: SubDivisionEdge[];
}

export interface SubDivisionConnectionPromise
  extends Promise<SubDivisionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubDivisionEdge>>() => T;
  aggregate: <T = AggregateSubDivisionPromise>() => T;
}

export interface SubDivisionConnectionSubscription
  extends Promise<AsyncIterator<SubDivisionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubDivisionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubDivisionSubscription>() => T;
}

export interface SubDivisionEdge {
  node: SubDivision;
  cursor: String;
}

export interface SubDivisionEdgePromise
  extends Promise<SubDivisionEdge>,
    Fragmentable {
  node: <T = SubDivisionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubDivisionEdgeSubscription
  extends Promise<AsyncIterator<SubDivisionEdge>>,
    Fragmentable {
  node: <T = SubDivisionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSubDivision {
  count: Int;
}

export interface AggregateSubDivisionPromise
  extends Promise<AggregateSubDivision>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubDivisionSubscription
  extends Promise<AsyncIterator<AggregateSubDivision>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Subject {
  id: ID_Output;
  subjName: String;
  subjCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SubjectPromise extends Promise<Subject>, Fragmentable {
  id: () => Promise<ID_Output>;
  subjName: () => Promise<String>;
  subjCode: () => Promise<String>;
  annExamSeriesSubj: <T = FragmentableArray<AnnualExamSubjectSeries>>(args?: {
    where?: AnnualExamSubjectSeriesWhereInput;
    orderBy?: AnnualExamSubjectSeriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubjectSubscription
  extends Promise<AsyncIterator<Subject>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subjName: () => Promise<AsyncIterator<String>>;
  subjCode: () => Promise<AsyncIterator<String>>;
  annExamSeriesSubj: <
    T = Promise<AsyncIterator<AnnualExamSubjectSeriesSubscription>>
  >(args?: {
    where?: AnnualExamSubjectSeriesWhereInput;
    orderBy?: AnnualExamSubjectSeriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubjectNullablePromise
  extends Promise<Subject | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subjName: () => Promise<String>;
  subjCode: () => Promise<String>;
  annExamSeriesSubj: <T = FragmentableArray<AnnualExamSubjectSeries>>(args?: {
    where?: AnnualExamSubjectSeriesWhereInput;
    orderBy?: AnnualExamSubjectSeriesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubjectConnection {
  pageInfo: PageInfo;
  edges: SubjectEdge[];
}

export interface SubjectConnectionPromise
  extends Promise<SubjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubjectEdge>>() => T;
  aggregate: <T = AggregateSubjectPromise>() => T;
}

export interface SubjectConnectionSubscription
  extends Promise<AsyncIterator<SubjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubjectSubscription>() => T;
}

export interface SubjectEdge {
  node: Subject;
  cursor: String;
}

export interface SubjectEdgePromise extends Promise<SubjectEdge>, Fragmentable {
  node: <T = SubjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubjectEdgeSubscription
  extends Promise<AsyncIterator<SubjectEdge>>,
    Fragmentable {
  node: <T = SubjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSubject {
  count: Int;
}

export interface AggregateSubjectPromise
  extends Promise<AggregateSubject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubjectSubscription
  extends Promise<AsyncIterator<AggregateSubject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TownConnection {
  pageInfo: PageInfo;
  edges: TownEdge[];
}

export interface TownConnectionPromise
  extends Promise<TownConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TownEdge>>() => T;
  aggregate: <T = AggregateTownPromise>() => T;
}

export interface TownConnectionSubscription
  extends Promise<AsyncIterator<TownConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TownEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTownSubscription>() => T;
}

export interface TownEdge {
  node: Town;
  cursor: String;
}

export interface TownEdgePromise extends Promise<TownEdge>, Fragmentable {
  node: <T = TownPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TownEdgeSubscription
  extends Promise<AsyncIterator<TownEdge>>,
    Fragmentable {
  node: <T = TownSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTown {
  count: Int;
}

export interface AggregateTownPromise
  extends Promise<AggregateTown>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTownSubscription
  extends Promise<AsyncIterator<AggregateTown>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AnnualExamSubjectSeriesSubscriptionPayload {
  mutation: MutationType;
  node: AnnualExamSubjectSeries;
  updatedFields: String[];
  previousValues: AnnualExamSubjectSeriesPreviousValues;
}

export interface AnnualExamSubjectSeriesSubscriptionPayloadPromise
  extends Promise<AnnualExamSubjectSeriesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AnnualExamSubjectSeriesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AnnualExamSubjectSeriesPreviousValuesPromise>() => T;
}

export interface AnnualExamSubjectSeriesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AnnualExamSubjectSeriesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AnnualExamSubjectSeriesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = AnnualExamSubjectSeriesPreviousValuesSubscription
  >() => T;
}

export interface AnnualExamSubjectSeriesPreviousValues {
  id: ID_Output;
  rankCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AnnualExamSubjectSeriesPreviousValuesPromise
  extends Promise<AnnualExamSubjectSeriesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  rankCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AnnualExamSubjectSeriesPreviousValuesSubscription
  extends Promise<AsyncIterator<AnnualExamSubjectSeriesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  rankCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AnotherTypeSubscriptionPayload {
  mutation: MutationType;
  node: AnotherType;
  updatedFields: String[];
  previousValues: AnotherTypePreviousValues;
}

export interface AnotherTypeSubscriptionPayloadPromise
  extends Promise<AnotherTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AnotherTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AnotherTypePreviousValuesPromise>() => T;
}

export interface AnotherTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AnotherTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AnotherTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AnotherTypePreviousValuesSubscription>() => T;
}

export interface AnotherTypePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AnotherTypePreviousValuesPromise
  extends Promise<AnotherTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AnotherTypePreviousValuesSubscription
  extends Promise<AsyncIterator<AnotherTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CandidateSubscriptionPayload {
  mutation: MutationType;
  node: Candidate;
  updatedFields: String[];
  previousValues: CandidatePreviousValues;
}

export interface CandidateSubscriptionPayloadPromise
  extends Promise<CandidateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CandidatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CandidatePreviousValuesPromise>() => T;
}

export interface CandidateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CandidateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CandidateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CandidatePreviousValuesSubscription>() => T;
}

export interface CandidatePreviousValues {
  id: ID_Output;
  cand1stName?: String;
  cand2ndName?: String;
  cand3rdName?: String;
  placeOfBirth?: String;
  candCode?: String;
  image?: String;
  birthCertNumber?: String;
  email?: String;
  phoneNumb?: Int;
  dateOfBirth?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CandidatePreviousValuesPromise
  extends Promise<CandidatePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  cand1stName: () => Promise<String>;
  cand2ndName: () => Promise<String>;
  cand3rdName: () => Promise<String>;
  placeOfBirth: () => Promise<String>;
  candCode: () => Promise<String>;
  image: () => Promise<String>;
  birthCertNumber: () => Promise<String>;
  email: () => Promise<String>;
  phoneNumb: () => Promise<Int>;
  dateOfBirth: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CandidatePreviousValuesSubscription
  extends Promise<AsyncIterator<CandidatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  cand1stName: () => Promise<AsyncIterator<String>>;
  cand2ndName: () => Promise<AsyncIterator<String>>;
  cand3rdName: () => Promise<AsyncIterator<String>>;
  placeOfBirth: () => Promise<AsyncIterator<String>>;
  candCode: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  birthCertNumber: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phoneNumb: () => Promise<AsyncIterator<Int>>;
  dateOfBirth: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CenterAdminSubscriptionPayload {
  mutation: MutationType;
  node: CenterAdmin;
  updatedFields: String[];
  previousValues: CenterAdminPreviousValues;
}

export interface CenterAdminSubscriptionPayloadPromise
  extends Promise<CenterAdminSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CenterAdminPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CenterAdminPreviousValuesPromise>() => T;
}

export interface CenterAdminSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CenterAdminSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CenterAdminSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CenterAdminPreviousValuesSubscription>() => T;
}

export interface CenterAdminPreviousValues {
  id: ID_Output;
  authName: String;
  authInstitution: String;
  authPhone: Int;
  authMatricue: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CenterAdminPreviousValuesPromise
  extends Promise<CenterAdminPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  authName: () => Promise<String>;
  authInstitution: () => Promise<String>;
  authPhone: () => Promise<Int>;
  authMatricue: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CenterAdminPreviousValuesSubscription
  extends Promise<AsyncIterator<CenterAdminPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  authName: () => Promise<AsyncIterator<String>>;
  authInstitution: () => Promise<AsyncIterator<String>>;
  authPhone: () => Promise<AsyncIterator<Int>>;
  authMatricue: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DivisionSubscriptionPayload {
  mutation: MutationType;
  node: Division;
  updatedFields: String[];
  previousValues: DivisionPreviousValues;
}

export interface DivisionSubscriptionPayloadPromise
  extends Promise<DivisionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DivisionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DivisionPreviousValuesPromise>() => T;
}

export interface DivisionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DivisionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DivisionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DivisionPreviousValuesSubscription>() => T;
}

export interface DivisionPreviousValues {
  id: ID_Output;
  divName: String;
  divCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DivisionPreviousValuesPromise
  extends Promise<DivisionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  divName: () => Promise<String>;
  divCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DivisionPreviousValuesSubscription
  extends Promise<AsyncIterator<DivisionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  divName: () => Promise<AsyncIterator<String>>;
  divCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EducationTypeSubscriptionPayload {
  mutation: MutationType;
  node: EducationType;
  updatedFields: String[];
  previousValues: EducationTypePreviousValues;
}

export interface EducationTypeSubscriptionPayloadPromise
  extends Promise<EducationTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EducationTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EducationTypePreviousValuesPromise>() => T;
}

export interface EducationTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EducationTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EducationTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EducationTypePreviousValuesSubscription>() => T;
}

export interface EducationTypePreviousValues {
  id: ID_Output;
  educationTypeName?: String;
  educationTypeCode?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface EducationTypePreviousValuesPromise
  extends Promise<EducationTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  educationTypeName: () => Promise<String>;
  educationTypeCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface EducationTypePreviousValuesSubscription
  extends Promise<AsyncIterator<EducationTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  educationTypeName: () => Promise<AsyncIterator<String>>;
  educationTypeCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExamSubscriptionPayload {
  mutation: MutationType;
  node: Exam;
  updatedFields: String[];
  previousValues: ExamPreviousValues;
}

export interface ExamSubscriptionPayloadPromise
  extends Promise<ExamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExamPreviousValuesPromise>() => T;
}

export interface ExamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExamPreviousValuesSubscription>() => T;
}

export interface ExamPreviousValues {
  id: ID_Output;
  examName: String;
  examCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ExamPreviousValuesPromise
  extends Promise<ExamPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  examName: () => Promise<String>;
  examCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ExamPreviousValuesSubscription
  extends Promise<AsyncIterator<ExamPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  examName: () => Promise<AsyncIterator<String>>;
  examCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExamCenterSubscriptionPayload {
  mutation: MutationType;
  node: ExamCenter;
  updatedFields: String[];
  previousValues: ExamCenterPreviousValues;
}

export interface ExamCenterSubscriptionPayloadPromise
  extends Promise<ExamCenterSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExamCenterPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExamCenterPreviousValuesPromise>() => T;
}

export interface ExamCenterSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExamCenterSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExamCenterSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExamCenterPreviousValuesSubscription>() => T;
}

export interface ExamCenterPreviousValues {
  id: ID_Output;
  centerName: String;
  centerCode: String;
  centerNumber: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ExamCenterPreviousValuesPromise
  extends Promise<ExamCenterPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  centerName: () => Promise<String>;
  centerCode: () => Promise<String>;
  centerNumber: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ExamCenterPreviousValuesSubscription
  extends Promise<AsyncIterator<ExamCenterPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  centerName: () => Promise<AsyncIterator<String>>;
  centerCode: () => Promise<AsyncIterator<String>>;
  centerNumber: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GenderSubscriptionPayload {
  mutation: MutationType;
  node: Gender;
  updatedFields: String[];
  previousValues: GenderPreviousValues;
}

export interface GenderSubscriptionPayloadPromise
  extends Promise<GenderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GenderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GenderPreviousValuesPromise>() => T;
}

export interface GenderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GenderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GenderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GenderPreviousValuesSubscription>() => T;
}

export interface GenderPreviousValues {
  id: ID_Output;
  genderName: String;
  genderCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GenderPreviousValuesPromise
  extends Promise<GenderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  genderName: () => Promise<String>;
  genderCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GenderPreviousValuesSubscription
  extends Promise<AsyncIterator<GenderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  genderName: () => Promise<AsyncIterator<String>>;
  genderCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ItemSubscriptionPayload {
  mutation: MutationType;
  node: Item;
  updatedFields: String[];
  previousValues: ItemPreviousValues;
}

export interface ItemSubscriptionPayloadPromise
  extends Promise<ItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemPreviousValuesPromise>() => T;
}

export interface ItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemPreviousValuesSubscription>() => T;
}

export interface ItemPreviousValues {
  id: ID_Output;
  title: String;
  descrption: String;
  image?: String;
  largeImage?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ItemPreviousValuesPromise
  extends Promise<ItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  descrption: () => Promise<String>;
  image: () => Promise<String>;
  largeImage: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  descrption: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  largeImage: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PresenceSubscriptionPayload {
  mutation: MutationType;
  node: Presence;
  updatedFields: String[];
  previousValues: PresencePreviousValues;
}

export interface PresenceSubscriptionPayloadPromise
  extends Promise<PresenceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PresencePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PresencePreviousValuesPromise>() => T;
}

export interface PresenceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PresenceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PresenceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PresencePreviousValuesSubscription>() => T;
}

export interface PresencePreviousValues {
  id: ID_Output;
  presenceName: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PresencePreviousValuesPromise
  extends Promise<PresencePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  presenceName: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PresencePreviousValuesSubscription
  extends Promise<AsyncIterator<PresencePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  presenceName: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RankSubscriptionPayload {
  mutation: MutationType;
  node: Rank;
  updatedFields: String[];
  previousValues: RankPreviousValues;
}

export interface RankSubscriptionPayloadPromise
  extends Promise<RankSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RankPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RankPreviousValuesPromise>() => T;
}

export interface RankSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RankSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RankSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RankPreviousValuesSubscription>() => T;
}

export interface RankPreviousValues {
  id: ID_Output;
  rankName: String;
  rankCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RankPreviousValuesPromise
  extends Promise<RankPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  rankName: () => Promise<String>;
  rankCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RankPreviousValuesSubscription
  extends Promise<AsyncIterator<RankPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  rankName: () => Promise<AsyncIterator<String>>;
  rankCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RegionSubscriptionPayload {
  mutation: MutationType;
  node: Region;
  updatedFields: String[];
  previousValues: RegionPreviousValues;
}

export interface RegionSubscriptionPayloadPromise
  extends Promise<RegionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RegionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RegionPreviousValuesPromise>() => T;
}

export interface RegionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RegionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RegionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RegionPreviousValuesSubscription>() => T;
}

export interface RegionPreviousValues {
  id: ID_Output;
  regName: String;
  regCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RegionPreviousValuesPromise
  extends Promise<RegionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  regName: () => Promise<String>;
  regCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RegionPreviousValuesSubscription
  extends Promise<AsyncIterator<RegionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  regName: () => Promise<AsyncIterator<String>>;
  regCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RegistrationSubscriptionPayload {
  mutation: MutationType;
  node: Registration;
  updatedFields: String[];
  previousValues: RegistrationPreviousValues;
}

export interface RegistrationSubscriptionPayloadPromise
  extends Promise<RegistrationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RegistrationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RegistrationPreviousValuesPromise>() => T;
}

export interface RegistrationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RegistrationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RegistrationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RegistrationPreviousValuesSubscription>() => T;
}

export interface RegistrationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RegistrationPreviousValuesPromise
  extends Promise<RegistrationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RegistrationPreviousValuesSubscription
  extends Promise<AsyncIterator<RegistrationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReportSubscriptionPayload {
  mutation: MutationType;
  node: Report;
  updatedFields: String[];
  previousValues: ReportPreviousValues;
}

export interface ReportSubscriptionPayloadPromise
  extends Promise<ReportSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReportPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReportPreviousValuesPromise>() => T;
}

export interface ReportSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReportSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReportSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReportPreviousValuesSubscription>() => T;
}

export interface ReportPreviousValues {
  id: ID_Output;
  reportName: String;
  reportCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ReportPreviousValuesPromise
  extends Promise<ReportPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  reportName: () => Promise<String>;
  reportCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ReportPreviousValuesSubscription
  extends Promise<AsyncIterator<ReportPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  reportName: () => Promise<AsyncIterator<String>>;
  reportCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ScoreSubscriptionPayload {
  mutation: MutationType;
  node: Score;
  updatedFields: String[];
  previousValues: ScorePreviousValues;
}

export interface ScoreSubscriptionPayloadPromise
  extends Promise<ScoreSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScorePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScorePreviousValuesPromise>() => T;
}

export interface ScoreSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScoreSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScoreSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ScorePreviousValuesSubscription>() => T;
}

export interface ScorePreviousValues {
  id: ID_Output;
  subjectAve?: Float;
  subjectTotal?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ScorePreviousValuesPromise
  extends Promise<ScorePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subjectAve: () => Promise<Float>;
  subjectTotal: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ScorePreviousValuesSubscription
  extends Promise<AsyncIterator<ScorePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subjectAve: () => Promise<AsyncIterator<Float>>;
  subjectTotal: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SeriesSubscriptionPayload {
  mutation: MutationType;
  node: Series;
  updatedFields: String[];
  previousValues: SeriesPreviousValues;
}

export interface SeriesSubscriptionPayloadPromise
  extends Promise<SeriesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SeriesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SeriesPreviousValuesPromise>() => T;
}

export interface SeriesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SeriesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SeriesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SeriesPreviousValuesSubscription>() => T;
}

export interface SeriesPreviousValues {
  id: ID_Output;
  seriesName: String;
  seriesCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SeriesPreviousValuesPromise
  extends Promise<SeriesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  seriesName: () => Promise<String>;
  seriesCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SeriesPreviousValuesSubscription
  extends Promise<AsyncIterator<SeriesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  seriesName: () => Promise<AsyncIterator<String>>;
  seriesCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SessionSubscriptionPayload {
  mutation: MutationType;
  node: Session;
  updatedFields: String[];
  previousValues: SessionPreviousValues;
}

export interface SessionSubscriptionPayloadPromise
  extends Promise<SessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SessionPreviousValuesPromise>() => T;
}

export interface SessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SessionPreviousValuesSubscription>() => T;
}

export interface SessionPreviousValues {
  id: ID_Output;
  sessionName: String;
  sessionCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SessionPreviousValuesPromise
  extends Promise<SessionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  sessionName: () => Promise<String>;
  sessionCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SessionPreviousValuesSubscription
  extends Promise<AsyncIterator<SessionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  sessionName: () => Promise<AsyncIterator<String>>;
  sessionCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubDivisionSubscriptionPayload {
  mutation: MutationType;
  node: SubDivision;
  updatedFields: String[];
  previousValues: SubDivisionPreviousValues;
}

export interface SubDivisionSubscriptionPayloadPromise
  extends Promise<SubDivisionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubDivisionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubDivisionPreviousValuesPromise>() => T;
}

export interface SubDivisionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubDivisionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubDivisionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubDivisionPreviousValuesSubscription>() => T;
}

export interface SubDivisionPreviousValues {
  id: ID_Output;
  subDivName: String;
  subDivCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SubDivisionPreviousValuesPromise
  extends Promise<SubDivisionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subDivName: () => Promise<String>;
  subDivCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubDivisionPreviousValuesSubscription
  extends Promise<AsyncIterator<SubDivisionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subDivName: () => Promise<AsyncIterator<String>>;
  subDivCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubjectSubscriptionPayload {
  mutation: MutationType;
  node: Subject;
  updatedFields: String[];
  previousValues: SubjectPreviousValues;
}

export interface SubjectSubscriptionPayloadPromise
  extends Promise<SubjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubjectPreviousValuesPromise>() => T;
}

export interface SubjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubjectPreviousValuesSubscription>() => T;
}

export interface SubjectPreviousValues {
  id: ID_Output;
  subjName: String;
  subjCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SubjectPreviousValuesPromise
  extends Promise<SubjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subjName: () => Promise<String>;
  subjCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SubjectPreviousValuesSubscription
  extends Promise<AsyncIterator<SubjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subjName: () => Promise<AsyncIterator<String>>;
  subjCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TownSubscriptionPayload {
  mutation: MutationType;
  node: Town;
  updatedFields: String[];
  previousValues: TownPreviousValues;
}

export interface TownSubscriptionPayloadPromise
  extends Promise<TownSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TownPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TownPreviousValuesPromise>() => T;
}

export interface TownSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TownSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TownSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TownPreviousValuesSubscription>() => T;
}

export interface TownPreviousValues {
  id: ID_Output;
  townName: String;
  townCode: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TownPreviousValuesPromise
  extends Promise<TownPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  townName: () => Promise<String>;
  townCode: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TownPreviousValuesSubscription
  extends Promise<AsyncIterator<TownPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  townName: () => Promise<AsyncIterator<String>>;
  townCode: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Item",
    embedded: false
  },
  {
    name: "Region",
    embedded: false
  },
  {
    name: "Division",
    embedded: false
  },
  {
    name: "SubDivision",
    embedded: false
  },
  {
    name: "Town",
    embedded: false
  },
  {
    name: "ExamCenter",
    embedded: false
  },
  {
    name: "Series",
    embedded: false
  },
  {
    name: "EducationType",
    embedded: false
  },
  {
    name: "Exam",
    embedded: false
  },
  {
    name: "Subject",
    embedded: false
  },
  {
    name: "Presence",
    embedded: false
  },
  {
    name: "Session",
    embedded: false
  },
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "Candidate",
    embedded: false
  },
  {
    name: "Rank",
    embedded: false
  },
  {
    name: "CenterAdmin",
    embedded: false
  },
  {
    name: "Report",
    embedded: false
  },
  {
    name: "Score",
    embedded: false
  },
  {
    name: "Registration",
    embedded: false
  },
  {
    name: "AnnualExamSubjectSeries",
    embedded: false
  },
  {
    name: "AnotherType",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
